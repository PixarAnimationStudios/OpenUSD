#usda 1.0
(
    subLayers = [
        @usdGeom/schema.usda@,
        @usdLux/schema.usda@,
        @usd/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName = "usdRiPxr"
        bool skipCodeGeneration = 1
        bool useLiteralIdentifier = 1
    }
)
{
}

class "PxrProjectionPluginBase" (
    customData = {
        string className = "ProjectionPluginBase"
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
    }
    doc = """Base Schema class which other PxrProjection plugins will inherit.
    It also provides UsdShade connectability for all classes that derive from
    it."""
    inherits = </Typed>
)
{
    token outputs:result (
        doc = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output"""
    )
}

class "PxrSampleFilterPluginBase" (
    customData = {
        string className = "SampleFilterPluginBase"
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
    }
    doc = """Base Schema class which other PxrSampleFilter plugins will inherit. 
    It also provides UsdShade connectability for all classes that derive from
    it."""
    inherits = </Imageable>
)
{
    token outputs:result (
        doc = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
    )
}

class "PxrDisplayFilterPluginBase" (
    customData = {
        string className = "DisplayFilterPluginBase"
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
    }
    doc = """Base Schema class which other PxrDisplayFilter plugins will inherit.
    It also provides UsdShade connectability for all classes that derive from
    it."""
    inherits = </Imageable>
)
{
    token outputs:result (
        doc = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
    )
}

class "PxrIntegratorPluginBase" (
    customData = {
        string className = "IntegratorPluginBase"
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
    }
    doc = """Base Schema class which other PxrIntegrator plugins will inherit.
    It also provides UsdShade connectability for all classes that derive from
    it."""
    inherits = </Typed>
)
{
    token outputs:result (
        doc = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
    )
}

class "PxrRenderTerminalsAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["RenderSettings"]
        token[] apiSchemaCanOnlyApplyTo = ["RenderSettings"]
        string className = "RenderTerminalsAPI"
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
            bool requiresUsdShadeEncapsulation = 0
        }
        dictionary schemaTokens = {
            dictionary displayFilters = {
                string doc = "Terminal for connecting display filters"
            }
            dictionary integrator = {
                string doc = "Terminal for connecting an integrator"
            }
            dictionary sampleFilters = {
                string doc = "Terminal for connecting sample filters"
            }
        }
    }
    doc = """API schema that provides a means of connecting a sample filter,
    display filter and an integrator. The API can be applied to provide hooks to
    the same for rman settings."""
    inherits = </APISchemaBase>
)
{
    token outputs:ri:displayFilters (
        customData = {
            string apiName = "displayFilters"
        }
        displayGroup = "OutputFilters"
        doc = """Represents the display filter terminals for a render setting. A
        display filter inheriting PxrDisplayFilterPluginBase can be connected to
        this terminal."""
    )
    token outputs:ri:integrator (
        customData = {
            string apiName = "integrator"
        }
        doc = """Represents the integrator terminal for a render setting. A
        integrator inheriting PxrIntegratorPluginBase can be connected to this
        terminal."""
    )
    token outputs:ri:sampleFilters (
        customData = {
            string apiName = "sampleFilters"
        }
        displayGroup = "OutputFilters"
        doc = """Represents the sample filter terminals for a render setting. A
        sample filter inheriting PxrSampleFilterPluginBase can be connected to
        this terminal."""
    )
}

class "PxrCameraProjectionAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["Camera"]
        token[] apiSchemaCanOnlyApplyTo = ["Camera"]
        string className = "CameraProjectionAPI"
        dictionary extraPlugInfo = {
            bool isUsdShadeContainer = 0
            bool providesUsdShadeConnectableAPIBehavior = 1
            bool requiresUsdShadeEncapsulation = 0
        }
        dictionary schemaTokens = {
            dictionary projection = {
                string doc = "Describes the <i>projection</i> output terminal"
            }
        }
    }
    doc = """API schema that is auto-applied _only_ to UsdGeomCamera and 
    provides a RenderMan-specific projection output terminal to UsdGeomCamera
    """
    inherits = </APISchemaBase>
)
{
    token outputs:ri:projection (
        customData = {
            string apiName = "projection"
        }
        displayGroup = "Outputs"
        doc = "Represents the projection output terminal on a camera prim."
    )
}

class "PxrAttributesAPI" (
    customData = {
        string apiSchemaType = "singleApply"
        string className = "AttributesAPI"
    }
    inherits = </APISchemaBase>
)
{
    string primvars:ri:attributes:bake:activeudims = "" (
        displayGroup = "Common"
        displayName = "Active Udims"
        doc = '''
                Active udims for Integrator baking of texture atlases.  Lists and ranges of udims 
                can be provided in the string, for example:
                  Attribute "bake" "string activeudims" "1001,1003,1005-1006".
                The default is "" which means all udims get baked.
            '''
    )
    string primvars:ri:attributes:bake:udimresolutions = "" (
        displayGroup = "Common"
        displayName = "Udim Resolutions"
        doc = '''
                Udim texure resolutions for Integrator baking of texture atlases.  Lists and ranges
                of udims can be provided in the string, for example:
                Attribute "bake" "string udimresolutions" "1001 512 512  1002,1003 64 32  1005-1006 16 16"
                If the string is empty (the default) then the Display Format resolution will be used.
            '''
    )
    int primvars:ri:attributes:curves:widthaffectscurvature = 1 (
        displayGroup = "Shading"
        displayName = "Width Affects Curvature"
        doc = """
                Indicates whether curve width should be used when computing curve curvature.
                If turned off, only the curvature along the curve spline will be calculated.
            """
    )
    int primvars:ri:attributes:grouping:id = 0 (
        displayGroup = "Common"
        displayName = "Grouping Id"
        doc = """
                Grouping id used for raytrace disambiguation purposes.
            """
    )
    string primvars:ri:attributes:grouping:membership = "" (
        displayGroup = "Common"
        displayName = "Membership"
        doc = """
                Grouping membership used for linking.
            """
    )
    int primvars:ri:attributes:identifier:id = 0 (
        displayGroup = "Common"
        displayName = "Identifier Id"
        doc = """
                Lower 32 bits of 64 bit object id.
            """
    )
    int primvars:ri:attributes:identifier:id2 = 0 (
        displayGroup = "Common"
        displayName = "Identifier Id 2"
        doc = """
                Upper 32 bits of 64 bit object id.
            """
    )
    string primvars:ri:attributes:identifier:lpegroup = "" (
        displayGroup = "Common"
        displayName = "Identifier LPE Group"
        doc = """
                Grouping membership used for light path expressions.
            """
    )
    string primvars:ri:attributes:identifier:name = "" (
        displayGroup = "Common"
        displayName = "Identifier Name"
        doc = """
                Object instance name.
            """
    )
    string primvars:ri:attributes:lightfilter:subset = "" (
        displayGroup = "Shading"
        displayName = "Light Filter Subset"
        doc = """
                Active light filter groups in lighting.
            """
    )
    string primvars:ri:attributes:lighting:excludesubset = "" (
        displayGroup = "Shading"
        displayName = "Lighting Excludesubset"
        doc = """
                Exclude light groups from lighting.
            """
    )
    int primvars:ri:attributes:lighting:mute = 0 (
        displayGroup = "Shading"
        displayName = "Lighting Mute"
        doc = """
                Mutes light emission.
            """
    )
    string primvars:ri:attributes:lighting:subset = "" (
        displayGroup = "Shading"
        displayName = "Lighting Subset"
        doc = """
                Light groups active in lighting.
            """
    )
    int primvars:ri:attributes:Ri:Matte = 0 (
        displayGroup = "Shading"
        displayName = "Matte"
        doc = """
                Indicates matte object.
            """
    )
    int primvars:ri:attributes:Ri:ReverseOrientation = 0 (
        displayGroup = "Shading"
        displayName = "Reverse Orientation"
        doc = """
                Flip shading normals.
            """
    )
    int primvars:ri:attributes:Ri:Sides = 2 (
        displayGroup = "Shading"
        displayName = "Sides"
        doc = """
                Geometry can be one or two sided.
            """
    )
    float primvars:ri:attributes:shade:indexofrefraction = -1 (
        displayGroup = "Shading"
        displayName = "Index Of Refraction"
        doc = """
                Override material IOR for nested dielectrics.
            """
    )
    int primvars:ri:attributes:shade:minsamples = 1 (
        displayGroup = "Shading"
        displayName = "Min Samples"
        doc = """
                Min Pixel Samples.  For fine-tuning adaptive sampling.
            """
    )
    float primvars:ri:attributes:shade:relativepixelvariance = 1 (
        displayGroup = "Shading"
        displayName = "Relative Pixel Variance"
        doc = """
                PixelVariance multiplier for camera visible objects.  For fine-tuning adaptive sampling.
            """
    )
    string primvars:ri:attributes:stats:identifier = "" (
        displayGroup = "Common"
        displayName = "Stats Identifier"
        doc = """
                Identifier string used by the stats system when referring to this instance.
            """
    )
    int primvars:ri:attributes:trace:holdout = 0 (
        displayGroup = "Shading"
        displayName = "Holdout"
        doc = """
                Indicates holdout object.
            """
    )
    int primvars:ri:attributes:trace:intersectpriority = 0 (
        displayGroup = "Shading"
        displayName = "Intersect Priority"
        doc = """
                Raytrace intersection priority for nested dielectrics.
            """
    )
    int primvars:ri:attributes:trace:maxdiffusedepth = 1 (
        displayGroup = "Shading"
        displayName = "Max Diffuse Depth"
        doc = """
                Maximum diffuse light bounces.
            """
    )
    int primvars:ri:attributes:trace:maxspeculardepth = 2 (
        displayGroup = "Shading"
        displayName = "Max Specular Depth"
        doc = """
                Maximum specular light bounces.
            """
    )
    string primvars:ri:attributes:trace:reflectexcludesubset = "" (
        displayGroup = "Shading"
        displayName = "Reflect Exclude Subset"
        doc = """
                Exclude object groups from relections.
            """
    )
    string primvars:ri:attributes:trace:reflectsubset = "" (
        displayGroup = "Shading"
        displayName = "Reflect Subset"
        doc = """
                Object groups visible to reflections.
            """
    )
    string primvars:ri:attributes:trace:shadowexcludesubset = "" (
        displayGroup = "Shading"
        displayName = "Shadow Exclude Subset"
        doc = """
                Exclude object groups from casting shadows.
            """
    )
    string primvars:ri:attributes:trace:shadowsubset = "" (
        displayGroup = "Shading"
        displayName = "Shadow Subset"
        doc = """
                Object groups active in shadows.
            """
    )
    string primvars:ri:attributes:trace:transmitexcludesubset = "" (
        displayGroup = "Shading"
        displayName = "Transmit Exclude Subset"
        doc = """
                Exclude object groups from refractions.
            """
    )
    string primvars:ri:attributes:trace:transmitsubset = "" (
        displayGroup = "Shading"
        displayName = "Transmit Subset"
        doc = """
                Object groups visible to refractions.
            """
    )
    int primvars:ri:attributes:visibility:camera = 1 (
        displayGroup = "Shading"
        displayName = "Camera Visibility"
        doc = """
                Indicates if object is visible to camera rays.
            """
    )
    int primvars:ri:attributes:visibility:indirect = 1 (
        displayGroup = "Shading"
        displayName = "Indirect Visibility"
        doc = """
                Indicates if object is visible to indirect (reflection and refraction) rays.
            """
    )
    int primvars:ri:attributes:visibility:transmission = 1 (
        displayGroup = "Shading"
        displayName = "Transmission Visibility"
        doc = """
                Indicates if object is visible to shadow rays.
            """
    )
}

class "PxrCameraAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["Camera"]
        token[] apiSchemaCanOnlyApplyTo = ["Camera"]
        string apiSchemaType = "singleApply"
        string className = "CameraAPI"
    }
    inherits = </APISchemaBase>
)
{
    float ri:apertureAngle = 0 (
        displayGroup = "Common"
        displayName = "Aperture Angle"
        doc = "<help />"
    )
    float ri:apertureDensity = 0 (
        displayGroup = "Common"
        displayName = "Aperture Density"
        doc = "<help />"
    )
    int ri:apertureNSides = 0 (
        displayGroup = "Common"
        displayName = "Aperture Number Of Sides"
        doc = "<help />"
    )
    float ri:apertureRoundness = 1 (
        displayGroup = "Common"
        displayName = "Aperture Roundness"
        doc = "<help />"
    )
    float ri:dofaspect = 1 (
        displayGroup = "Common"
        displayName = "DOF Aspect"
        doc = """
                Depth of field aspect.
            """
    )
    float ri:shutterCloseTime = 1 (
        displayGroup = "Common"
        displayName = "Shutter Close Time"
        doc = "<help />"
    )
    float[] ri:shutterOpening = [0, 0, 0, 0, 1, 1, 1, 1] (
        displayGroup = "Common"
        displayName = "Shutter Opening"
        doc = "<help />"
    )
    float ri:shutterOpenTime = 0 (
        displayGroup = "Common"
        displayName = "Shutter Open Time"
        doc = "<help />"
    )
    float[] ri:stereoplanedepths = [] (
        displayGroup = "Common"
        displayName = "Stereo Plane Depths"
        doc = '''
                Control "ray bending" to enable multi-stereo camera workflows. Each depth element
                defines a depth plane where camera rays bend by a horizontal (camera x) offset.
                Every depth element must have a corresponding offset element. Values should be
                positive and in increasing order.
            '''
    )
    float[] ri:stereoplaneoffsets = [] (
        displayGroup = "Common"
        displayName = "Stereo Plane Offsets"
        doc = '''
                Control "ray bending" to enable multi-stereo camera workflows. Each offset element
                defines a horizontal offset (camera x) of a virtual camera origin that bends rays
                at the corresponding depth plane. Every offset element must have a corresponding
                depth element.
            '''
    )
}

class "PxrDisplayChannelAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["RenderVar"]
        token[] apiSchemaCanOnlyApplyTo = ["RenderVar"]
        string apiSchemaType = "singleApply"
        string className = "DisplayChannelAPI"
    }
    inherits = </APISchemaBase>
)
{
    token ri:displayChannel:filter = "box" (
        allowedTokens = ["min", "max", "average", "zmin", "zmax", "sum", "gaussian", "box", "triangle", "catmull-rom", "separable-catmull-rom", "mitchell", "blackman-harris", "sinc", "bessel", "disk", "lanczos"]
        displayGroup = "Common"
        displayName = "Filter Type"
        doc = """
                Reconstruction filter or rule.
            """
    )
    float2 ri:displayChannel:filterwidth = (1, 1) (
        displayGroup = "Common"
        displayName = "Filter Width"
        doc = "<help />"
    )
    float ri:displayChannel:relativepixelvariance = 0 (
        displayGroup = "Common"
        displayName = "Relative Pixel Variance"
        doc = "<help />"
    )
    float3 ri:displayChannel:remap = (0, 0, 0) (
        displayGroup = "Common"
        displayName = "Remap"
        doc = "<help />"
    )
    float ri:displayChannel:shadowthreshold = 0.01 (
        displayGroup = "Common"
        displayName = "Shadow Threshold"
        doc = """
                Threshold used to compute shadowing contributions in LPEs containing 
                the 'shadow' token. 
                If the shadow is cut, lower the threshold. 
                If there are white pixels in shadowed areas, raise the threshold.
            """
    )
    token ri:displayChannel:statistics = "none" (
        allowedTokens = ["none", "variance", "mse", "even", "odd"]
        displayGroup = "Common"
        displayName = "Statistics"
        doc = "<help />"
    )
}

class "PxrOptionsAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["RenderSettings"]
        token[] apiSchemaCanOnlyApplyTo = ["RenderSettings"]
        string apiSchemaType = "singleApply"
        string className = "OptionsAPI"
    }
    inherits = </APISchemaBase>
)
{
    token ri:bucket:order = "horizontal" (
        allowedTokens = ["horizontal", "vertical", "zigzag-x", "zigzag-y", "spacefill", "random", "spiral", "circle"]
        displayGroup = "Display"
        displayName = "Bucket Order"
        doc = """
                Render bucket order.
            """
    )
    int2 ri:bucket:orderorigin = (0, 0) (
        displayGroup = "Display"
        displayName = "Bucket Origin"
        doc = '''
                First bucket for "spiral" and "circle" order. Image center is [-1 -1].
            '''
    )
    bool ri:checkpoint:asfinal = 0 (
        displayGroup = "Display"
        displayName = "Checkpoint As Final"
        doc = """
                When enabled, this keeps the extra channels and the
                checkpoint tag when writing the final image for the render.
                The final image will be identical to any other checkpoint,
                rather than a slimmed down image. This means that once your
                image has reached the quality you've set and it completes,
                it can always be restarted by the user later.
            """
    )
    string ri:checkpoint:command = "" (
        displayGroup = "Display"
        displayName = "Checkpoint Command"
        doc = """
                System command to be called after checkpoint.  If
                system calls are enabled, then after a checkpoint has been
                written, the specified command will be called.  This is
                synchronous; the rendering threads are quiescent while this
                runs and will not resume again until the process returns,
                avoiding possible race conditions if the command takes a
                token %i will be replaced with the current increment,
                zero-padded to 5 digits.  The token %e will be replaced
                with the elapsed time in seconds, zero-padded to 6 digits.
                The token %r will be replaced with the reason for this
                update to the checkpoint files (either completely
                `finished`, `exiting` early due to exitat option, or a
                normal `checkpoint`).  Literal % characters may be inserted
                with %%.
            """
    )
    string ri:checkpoint:exitat = "" (
        displayGroup = "Display"
        displayName = "Checkpoint Exit At"
        doc = '''
                How long render should run before writing a final
                checkpoint and terminating.  Value can also be a string such
                as "10m" or "0.5h". Set to 0 or empty to disable.
            '''
    )
    string ri:checkpoint:interval = "" (
        displayGroup = "Display"
        displayName = "Checkpoint Interval"
        doc = '''
                Write framebuffers to disk every N progressive steps.
                If value is positive the units will be interpreted as
                seconds.  If value is negative its units will be
                interpreted as increments.  Value can also be a string such
                as "10m" or "0.5h".  Setting option to 0 or empty will disable
                checkpoints.
            '''
    )
    bool ri:checkpoint:keepfiles = 0 (
        displayGroup = "Display"
        displayName = "Keep Files"
        doc = """
                If set to true then prman will write to a new,
                numbered image for each checkpoint.  Note:  This will
                disable the final write of a checkpoint file which means
                the render cannot be recovered using the 'recover' option.
            """
    )
    float ri:curve:minwidth = 0 (
        displayGroup = "Dicing"
        displayName = "Min Width"
        doc = """
                Minimum curve width in raster coordinates.
            """
    )
    int ri:deep:flagvolumes = 1 (
        displayGroup = "Display"
        displayName = "Deep Flag Volumes"
        doc = """
                Auto is off for dtex, on otherwise.
            """
    )
    float ri:dice:offscreenmultiplier = 1 (
        displayGroup = "Dicing"
        displayName = "Dice Off Screen Multiplier"
        doc = """
                Dicing rate multiplier for objects outside the viewing frustum.
            """
    )
    token ri:dice:triangle = "trim" (
        allowedTokens = ["trim", "blp"]
        displayGroup = "Dicing"
        displayName = "Dice Triangle"
        doc = '''
                The method used for dicing "triangles". The default method "trim" renders
                triangles by trimming a quad. The "blp" method renders a quad with two points
                being coincident.
            '''
    )
    bool ri:hider:adaptall = 0 (
        displayGroup = "Common"
        displayName = "Adapt All"
        doc = '''
                Enable adaptive sampling of all AOVs. When enabled, all channels (beauty pass +
                AOVs) are considered when deciding if a pixel is converging. The default (off)
                will ignore the AOVs and only the beauty pass is considered for pixel
                convergence. So turning off "adaptall" may speed up your render if some of
                your AOVs never reach the specified variance threshold.
            '''
    )
    token ri:hider:adaptivemetric = "variance" (
        allowedTokens = ["contrast", "variance", "halfbuffer", "contrast-v22", "variance-v22"]
        displayGroup = "Common"
        displayName = "Adaptive Metric"
        doc = '''
                Specifies the metric used to drive adaptive sampling.
                "contrast" measures the contrast between samples in a pixel.
                "variance" measures the variance of the samples in a pixel.
                "halfbuffer" splits the samples into two classes and measures the
                  difference between the average of each of the two sample classes.
                "contrast-v22" uses the relative contrast computation of RenderMan 22 and older.
                "variance-v22" uses the relative variance computation of RenderMan 22 and older.
            '''
    )
    point3f ri:hider:bakebboxmax = (1e30, 1e30, 1e30) (
        displayGroup = "Baking"
        displayName = "Baking bbox max"
        doc = '''
                Bounding box max for "integrator" baking of 3D point clouds (and for the integrator
                part of "all" baking.  In world space.  Ignored for "pattern" baking and for 2D baking.
            '''
    )
    point3f ri:hider:bakebboxmin = (-1e30, -1e30, -1e30) (
        displayGroup = "Baking"
        displayName = "Baking bbox min"
        doc = '''
                Bounding box min for "integrator" baking of 3D point clouds (and for the integrator
                part of "all" baking.  In world space.  Ignored for "pattern" baking and for 2D baking.
            '''
    )
    token ri:hider:bakemode = "pattern" (
        allowedTokens = ["pattern", "integrator", "all"]
        displayGroup = "Baking"
        displayName = "Bake Mode"
        doc = """
                Specifies whether the renderer should bake Pattern results or Integrator results
                or both.
            """
    )
    int ri:hider:bakeudimoffset = 0 (
        displayGroup = "Baking"
        displayName = "Baking udim offset"
        doc = """
                Offset when baking for a subset of udims.  Used together with bakeudimstride.
                Default 0 means bake all udims when bakeudimstride is 1.
            """
    )
    int ri:hider:bakeudimstride = 1 (
        displayGroup = "Baking"
        displayName = "Baking udim stride"
        doc = """
                Stride when baking for a subset of udims.  Default 1 means bake all udims.
            """
    )
    bool ri:hider:bluenoise = 1 (
        displayGroup = "Common"
        displayName = "Blue Noise Samples"
        doc = """
                Setting to control whether the samples should have a visually
                pleasing blue noise distribution or not.  Default is 1 (on).
                Set to 0 (off) if the samples in adjacent pixels need to be
                completely decorrelated.
            """
    )
    float ri:hider:darkfalloff = 0.025 (
        displayGroup = "Common"
        displayName = "Dark Falloff"
        doc = """
                De-prioritize low luminance samples in the adaptive sampler.
                Use this parameter to avoid oversampling dark areas while maintaining
                overall image quality. Higher values cull more samples, speeding
                up render time while increasing noise in darker areas.
            """
    )
    int ri:hider:decidither = 0 (
        displayGroup = "Common"
        displayName = "Interactive Refinement"
        doc = """
                Maximum allowed pixel decimation rate for interactive
                rendering.  When making rapid edits to heavy scenes and
                this setting is non-zero, the renderer will try to reduce
                tearing by updating the whole screen progressively with a
                dissolve-like effect.  Set this to zero to disable this and
                force it to fully update the buckets that it can get to.
            """
    )
    float2 ri:hider:exposurebracket = (-1, 1) (
        displayGroup = "Common"
        displayName = "Exposure Bracket"
        doc = """
                Intended exposure Bracket [min max] in post-production to help inform
                the adaptive sampling.
            """
    )
    bool ri:hider:extrememotiondof = 0 (
        displayGroup = "Common"
        displayName = "Extreme Motion DOF"
        doc = """
                Enable improved sampling accuracy. In some cases where a large amount of
                motion blur is used with depth of field, sampling artifacts could cause an
                undesirable result. This flag causes a slower but more accurate sampling
                method to be used to alleviate the artifacts. Due to the performance
                degradations of this sampling method, this flag should only be used when
                necessary.
            """
    )
    bool ri:hider:geomShadowTermBias = 1 (
        displayGroup = "Common"
        displayName = "Geometric Shadow Terminator on Poly Meshes"
        doc = """
                This setting will control when to compute and apply a bias to Poly Meshes
                to avoid the geometric shadow terminator artifacts that appear for shading points
                when they are visible from a light wrt their shading normal, but not visible wrt
                their geometric normal. The default value is 1 (on). Set to 0 (off) if you don't
                want this bias to be applied to the Poly Meshes in your scene.
            """
    )
    bool ri:hider:incremental = 0 (
        displayGroup = "Common"
        displayName = "Incremental"
        doc = """
                Enables the progressive display of results (rather than bucketed results).
            """
    )
    bool ri:hider:invert = 1 (
        displayGroup = "Baking"
        displayName = "Baking Invert T"
        doc = """
                Specifies whether or not to invert the T texture coordinate when baking integrator
                results.
            """
    )
    bool ri:hider:jitter = 1 (
        displayGroup = "Common"
        displayName = "Jitter"
        doc = """
                This option toggles the jitter (variation) in camera samples.
                By default, this hider option is enabled (set to 1), meaning that camera samples
                will be placed randomly in a pixel location. When it is turned off,
                camera rays are placed in the center of the pixel. When turned off, 
                surface edges will appear aliased and jagged.
            """
    )
    int ri:hider:maxsamples = 0 (
        displayGroup = "Common"
        displayName = "Max Samples"
        doc = """
                An explicit limit for the number of samples. If maxsamples is equal to its
                default then the maximum number of samples will be set equal to 64.
                Note that minsamples defaults to the square root of the maxsamples setting.
            """
    )
    int ri:hider:minextrasamples = -1 (
        displayGroup = "Common"
        displayName = "Min Extra Samples"
        doc = """
                This is the minimum number of extra samples that a pixel
                should continue shooting with after a sample fails to meet
                its convergence test with the adaptive sampler.
                Defaults to matching minsamples.
            """
    )
    int ri:hider:minsamples = -1 (
        displayGroup = "Common"
        displayName = "Min Samples"
        doc = """
                Specifies the minimum number of samples for adaptive sampling. The default value
                is the square root of maxsamples.
            """
    )
    token ri:hider:pixelfiltermode = "importance" (
        allowedTokens = ["weighted", "importance"]
        displayGroup = "Common"
        displayName = "Pixel Filter Mode"
        doc = '''
                Specifies how pixel filtering of camera samples is performed.
                "Importance" (the default) warps the samples in screen space around the
                pixel center, and does not share sample results between pixels. "Importance" is
                needed by some postprocessing algorithms such as denoisers, and is necessary to
                get the visual benefit of blue-noise samples. It is also needed to produce
                variance AOVs.  "Weighted" is the older method that blends together sample results
                 from neighboring pixels.
            '''
    )
    string[] ri:hider:primvar = ["st"] (
        displayGroup = "Baking"
        displayName = "Baking PrimVars"
        doc = """
                Specifies dicing manifold used when baking integrator results.
            """
    )
    bool ri:hider:samplemotion = 1 (
        displayGroup = "Common"
        displayName = "Sample Motion"
        doc = """
                This option toggles the sampling of motion blurred micropolygon in the
                hider, and is thus only meaningful if motion blur is being used in your scene.
                By default, this hider option is enabled (set to 1), meaning that micropolygons
                will be blurred and sampled in the hider. When disabled (set to 0),
                micropolygons will no longer be blurred before sampling; however, the dPdtime
                variable will still be computed for all objects. This variable can be output
                into a separate image using an arbitrary output variable (aov) and used to
                perform motion blur as a postprocess.
            """
    )
    int ri:hider:sampleoffset = 0 (
        displayGroup = "Common"
        displayName = "Sample Offset"
        doc = """
                This allows several images to be rendered in parallel (with different
                sampleoffset values) and then combined.

                With non-adaptive sampling:
                Let's say you render four images with 256 samples each, with
                sampleoffsets 0, 256, 512, and 768. If you combine those four images,
                you'll get exactly the same image as if you had rendered a single image
                with 1024 samples.

                With adaptive sampling:
                Let's say you again render four images, each with \"maxsamples\" 256,
                with sampleoffsets 0, 256, 512, and 768. Let's say that due to
                adaptive sampling, some given pixel only gets 64 pixel samples in each
                of the four images. Then the combined image has been rendered with
                sample numbers 0-63, 256-319, 512-575, and 768-831. Due to the
                stratification of the samples, this is not quite as good as if you had
                rendered a single image with 256 consecutive samples.  However, it
                is still better than rendering a single image with only 64 samples.
            """
    )
    int ri:hider:samplestride = 1 (
        displayGroup = "Common"
        displayName = "Sample Stride"
        doc = """
                This facilitates rendering several images in parallel (with the same 
                aamplestride but different sampleoffset) and then combine them 
                incrementally during interactive rendering.  Default value is 1.

                With non-adaptive sampling:
                Let's say you render four images with 256 samples each, with
                samplestride 4 and sampleoffsets 0, 1, 2, and 3.  If you combine those
                four images, you'll get exactly the same image as if you had rendered
                a single image with 1024 samples, and during incremental/interactive
                rendering you'll get the benefit of best use of the stratified
                progressive sample sequences.  If you can \"assemble\" images with
                samples 0-3, 4-7, 8-12, etc during interactive rendering, you've
                got the benefits of faster rendering without jumping to high samples
                early on.

                With adaptive sampling:
                Let's say you again render four images, each with \"maxsamples\" 256,
                with samplestride 4 and sampleoffsets 0, 1, 2, and 3.  This time with
                adaptive sampling (PixelVariance > 0).  Since each of the four images
                is more noisy than the combined image, the adaptive sampling will use
                more samples before deciding that the image error is acceptable than
                if it had been rendered as a single image.  So the PixelVariance 
                setting may need to be adjusted.
            """
    )
    token ri:hider:type = "raytrace" (
        allowedTokens = ["raytrace", "bake"]
        displayGroup = "Common"
        displayName = "Hider Type"
        doc = """
                Render mode.
            """
    )
    float ri:lighting:minimumestimate = 0.000001 (
        displayGroup = "Shading"
        displayName = "Light Minimum Estimate"
        doc = """
                Minimum estimate for light selection. Local lights whose estimate 
                falls below this value will be ignored. Increasing this value may 
                help speed up direct lighting at the expense of accuracy.
            """
    )
    bool ri:lighting:selectionlearningscheme = 1 (
        displayGroup = "Shading"
        displayName = "Light Learning Scheme"
        doc = """
                Employs a machine learning algorithm to more accurately importance
                sample lights, taking into account occlusion and light filters.
            """
    )
    int ri:limits:brickmemory = 2097152 (
        displayGroup = "Configuration"
        displayName = "Brick Memory Limit"
        doc = """
                Brickmap cache size in kB.
            """
    )
    int2 ri:limits:bucketsize = (0, 0) (
        displayGroup = "Configuration"
        displayName = "Bucket Size Limit"
        doc = """
                Size of render buckets in pixels.
            """
    )
    float ri:limits:deepshadowerror = 0.01 (
        displayGroup = "Configuration"
        displayName = "Deep Shadow Error Limit"
        doc = """
                Control lossy compression scheme to reduce file size of deep output. Setting to
                a high value will result in lower numbers of samples stored for each pixel.
            """
    )
    int ri:limits:geocachememory = 2097152 (
        displayGroup = "Configuration"
        displayName = "Geo Cache Memory Limit"
        doc = """
                Geometry cache size in kB.
            """
    )
    int ri:limits:gridsize = 289 (
        displayGroup = "Configuration"
        displayName = "Grid Size Limit"
        doc = "<help />"
    )
    int ri:limits:matrixcachememory = 0 (
        displayGroup = "Configuration"
        displayName = "Matrix Cache Memory"
        doc = """
                Matrix cache in kB.
            """
    )
    int ri:limits:nurbcurvaturedicefactor = 3 (
        displayGroup = "Configuration"
        displayName = "Nurb Curvature Dice Factor Limit"
        doc = """
                NURBs max curvature multiplier.
            """
    )
    int ri:limits:octreememory = 20480 (
        displayGroup = "Configuration"
        displayName = "Octree Memory Limit"
        doc = """
                None cache size in kB.
            """
    )
    int ri:limits:opacitycachememory = 1048576 (
        displayGroup = "Configuration"
        displayName = "Opacity Cache Memory Limit"
        doc = """
                Opacity cache in kB.
            """
    )
    float3 ri:limits:othreshold = (0.99609375, 0.99609375, 0.99609375) (
        displayGroup = "Configuration"
        displayName = "Opacity Threshold Limit"
        doc = """
                Opacity Culling: When rendering scenes with a large number
                of semi-transparent layered objects (e.g. hair), the opacity
                culling threshold can be set for a significant time and memory savings.
                Essentially, a stack of visible points whose accumulated opacity is
                greater (in each channel) than the specified limit will be considered
                fully opaque by the hider, and objects behind the stack will be culled.
            """
    )
    int ri:limits:pointmemory = 20480 (
        displayGroup = "Configuration"
        displayName = "Point Memory Limit"
        doc = """
                Point cache size in kB.
            """
    )
    int ri:limits:proceduralbakingclumpsize = 0 (
        displayGroup = "Configuration"
        displayName = "Procedural Baking Clump Size Limit"
        doc = "<help />"
    )
    int ri:limits:ptexturemaxfiles = 128 (
        displayGroup = "Configuration"
        displayName = "Ptex Max Files Limit"
        doc = "<help />"
    )
    int ri:limits:ptexturememory = 32768 (
        displayGroup = "Configuration"
        displayName = "Ptex Memory Limit"
        doc = """
                PTex cache size in kB.
            """
    )
    float ri:limits:rendermemory = 0 (
        displayGroup = "Configuration"
        displayName = "Render Memory Limit"
        doc = """
                Memory limit as percentage of machine memory.
            """
    )
    int ri:limits:rendertime = 0 (
        displayGroup = "Configuration"
        displayName = "Render Time Limit"
        doc = """
                Maximum render time in minutes.
            """
    )
    int ri:limits:shadesize = 289 (
        displayGroup = "Configuration"
        displayName = "Shade Size Limit"
        doc = """
                The maximum number of vertices, not grid.
            """
    )
    int ri:limits:texturememory = 2097152 (
        displayGroup = "Configuration"
        displayName = "Texture Memory Limit"
        doc = """
                Texture cache size in kB.
            """
    )
    float ri:limits:textureperthreadmemoryratio = 0.5 (
        displayGroup = "Configuration"
        displayName = "Texture Per Thread Memory Ratio"
        doc = "<help />"
    )
    int ri:limits:threads = 0 (
        displayGroup = "Configuration"
        displayName = "Thread Limit"
        doc = """
                Set the number of threads that the renderer uses. If a value of 0 is specified
                then all CPUs will be utilized for rendering.  If a negative value '-N' is
                specified then prman will use all but N CPUs for rendering.
            """
    )
    bool ri:osl:batched = 1 (
        displayGroup = "OSL"
        displayName = "SIMD Execution"
        doc = """
                Enable OSL optimizations that allow execution of multiple shading points
                via vectorized instructions on supported processors (AVX, AVX2, AVX512).
            """
    )
    int ri:osl:statisticslevel = 0 (
        displayGroup = "OSL"
        displayName = "Statistics Output Level"
        doc = """
                Set the level of OSL statistics to track. Level 2 and above
                introduces timing which can have a small effect on performance.
                Level 4 and above includes internal OSL statistics.
                Level 5 includes statistics per shader. Other levels reserved
                for future use.
            """
    )
    int ri:osl:verbose = 4 (
        displayGroup = "OSL"
        displayName = "Message Verbosity"
        doc = """
               Sets the level of OSL messages to pass through.
            """
    )
    float4 ri:Ri:CropWindow = (0, 1, 0, 1) (
        displayGroup = "Display"
        displayName = "Crop Window"
        doc = """
                Crop window [left right top bottom] in NDC space.
            """
    )
    float ri:Ri:FormatPixelAspectRatio = 1 (
        displayGroup = "Display"
        displayName = "Pixel Aspect Ratio"
        doc = """
                Output image pixel aspect ratio.
            """
    )
    int2 ri:Ri:FormatResolution = (0, 0) (
        displayGroup = "Display"
        displayName = "Resolution"
        doc = """
                Output image resolution.
            """
    )
    int ri:Ri:Frame = 0 (
        displayGroup = "Common"
        displayName = "Frame Number"
        doc = """
                Frame number.
            """
    )
    float ri:Ri:FrameAspectRatio = -1 (
        displayGroup = "Display"
        displayName = "Frame Aspect Ratio"
        doc = """
                Output image aspect ratio.
            """
    )
    float ri:Ri:PixelVariance = 0.015 (
        displayGroup = "Common"
        displayName = "Pixel Variance"
        doc = """
                Controls adaptive sampling. This sets the upper bound on the acceptable estimated
                variance of the pixel values from the true pixel values.
            """
    )
    float4 ri:Ri:ScreenWindow = (0, 0, 0, 0) (
        displayGroup = "Display"
        displayName = "Screen Window"
        doc = """
                Screen window [left right top bottom] in screen space.
            """
    )
    float ri:shade:chiangCompatibilityVersion = 24 (
        displayGroup = "Statistics"
        displayName = "PxrChiangHair compatibility version"
        doc = """
                Setting to allow PxrChiang to work in compatibility mode for older versions
                of the Bxdf, so renders from different versions can match their results.
                The default value is 24.0.
            """
    )
    bool ri:shade:debug = 0 (
        displayGroup = "Statistics"
        displayName = "Enable Shader Debug"
        doc = """
                Shading debug level.
            """
    )
    float ri:shade:roughnessmollification = 1 (
        displayGroup = "Statistics"
        displayName = "Specular Roughness Mollification"
        doc = """
                Specular Roughness Mollification.  This selectively increases material
                roughness on secondary bounces after diffuse or broad glossy reflections
                and on highly curved surfaces.  This reduces noise and fireflies, but can
                also make caustics blurrier or disappear entirely.  Set this value to 0.0
                when you want to render ground-truth caustics.  The default value is 1.0.
            """
    )
    bool ri:shade:shadowBumpTerminator = 1 (
        displayGroup = "Statistics"
        displayName = "Shadow bump terminator"
        doc = """
                Setting to control whether bump shadow terminators are smoothed in non-hair bxdfs.
            """
    )
    bool ri:shade:subsurfaceTypeDefaultFromVersion24 = 0 (
        displayGroup = "Statistics"
        displayName = "Use old subsurfaceType default (0) in PxrSurface bxdf"
        doc = """
                Use old default value for PxrSurface 'surfaceType' parameter.  Old default is 0 (Jensen
                dipole diffusion), new default is 5 (path-traced subsurface scattering).
            """
    )
    float ri:Shutter:offset = 0 (
        displayGroup = "Common"
        displayName = "Shutter Offset"
        doc = """
                Offset shutter open/close.
            """
    )
    float2 ri:statistics:displace_ratios = (0.1, 1) (
        displayGroup = "Statistics"
        displayName = "Displace Ratios"
        doc = """
                Suppress reporting of displacements that, when divided by the max
                displacement, fall in the specified range.
            """
    )
    string ri:statistics:filename = "" (
        displayGroup = "Statistics"
        displayName = "Filename"
        doc = """
                File name for summary statistics reported in plain text.
            """
    )
    bool ri:statistics:level = 0 (
        displayGroup = "Statistics"
        displayName = "Enable Statistics"
        doc = """
                Enable statistics reporting.
            """
    )
    int ri:statistics:maxdispwarnings = 100 (
        displayGroup = "Statistics"
        displayName = "Max Displace Warnings"
        doc = """
                Modify the maximum reported displacement issues. If the value is set to 0,
                then all displacements issues are reported.
            """
    )
    string ri:statistics:shaderprofile = "" (
        displayGroup = "Statistics"
        displayName = "Shader Profile"
        doc = "<help />"
    )
    string ri:statistics:stylesheet = "" (
        displayGroup = "Statistics"
        displayName = "Style Sheet"
        doc = """
                Stylesheet for XML detailed statistics.
            """
    )
    bool ri:statistics:texturestatslevel = 0 (
        displayGroup = "Statistics"
        displayName = "Enable Texture Statistics"
        doc = """
                Enable texture statistics reporting.
            """
    )
    string ri:statistics:xmlfilename = "" (
        displayGroup = "Statistics"
        displayName = "Xml Filename"
        doc = """
                File name for detailed statistics reported as XML.
            """
    )
    bool ri:stitch:refwarning = 1 (
        displayGroup = "Dicing"
        displayName = "Enable Stitch Ref Warning"
        doc = """
                Enable stitch warnings.
            """
    )
    float ri:trace:bvhcompression = 0 (
        displayGroup = "Shading"
        displayName = "BVH Compression"
        doc = """
                Provides a hint to the system to favor memory utilization versus speed when
                constructing the ray accelerator. Valid values are in the range [0, 1], where
                the higher the values the more compact the memory representation.
                The control behaves almost lineraly with some discontinuities in the compression
                rate as different strategies are activated. The result obtained is likely to be
                scene dependent.
                As a rule of thumb, leave this control to 0 unless you need to reduce memory
                utilization in order to render a given scene or sequence. When tuning, set the
                control to 1 at first to see how much memory can be saved through compression and
                what time overhead is generated, then dial the number back to a lower value (if
                possible) and reach the deired balance between speed and memory usage.
            """
    )
    float3 ri:trace:worldoffset = (0, 0, 0) (
        displayGroup = "Shading"
        displayName = "World Offset"
        doc = '''
                Used as the origin when the worldorigin option is set to "worldoffset".
            '''
    )
    token ri:trace:worldorigin = "camera" (
        allowedTokens = ["world", "worldoffset", "camera"]
        displayGroup = "Shading"
        displayName = "World Origin"
        doc = """
                Set a new world origin to give better floating point precision.
            """
    )
    string ri:volume:aggregatespace = "world" (
        displayGroup = "Volumes"
        displayName = "Aggregate space"
        doc = '''
                Space in which to compute aggregate volume metadata. Valid spaces are
                "world" and "camera". Generally the space should be chosen to minimize
                the range of motion of the volumes.
            '''
    )
}

class "PxrPrimvarsAPI" (
    customData = {
        string apiSchemaType = "singleApply"
        string className = "PrimvarsAPI"
    }
    inherits = </APISchemaBase>
)
{
    int primvars:ri:curve:opacitysamples = 0 (
        displayGroup = "Curves"
        displayName = "Opacity Samples"
        doc = """
                number of opacity/presence shading samples along a curve for opacity caching, if equal to zero then the value is determined using the dicing oracle and the length of each curve.
            """
    )
    bool primvars:ri:curve:widthaffectscurvature = 1 (
        displayGroup = "Curves"
        displayName = "Width Affects Curvature"
        doc = """
                When true the curve width of round curves is taken into account in the computation of the tube curvature, otherwise only the curvature along the curve is. This control does not affect curve ribbons.
            """
    )
    token primvars:ri:derivatives:extrapolate (
        displayGroup = "Shading"
        displayName = "derivatives:extrapolate"
        doc = """
                Extrapolated smooth normals across grid boundaries.
            """
    )
    float primvars:ri:dice:micropolygonlength = 1 (
        displayGroup = "Dicing"
        displayName = "Micropolygon Length"
        doc = '''
                Micropolygon distance in raster space for "instanceprojection" dicing. Values
                are expressed in pixel size.
            '''
    )
    float primvars:ri:dice:minlength = -1 (
        displayGroup = "Volume"
        displayName = "Min Length"
        doc = """
                Volume minimum dice length. Negative indicates to automatically compute this value.
            """
    )
    string primvars:ri:dice:minlengthspace = "" (
        displayGroup = "Volume"
        displayName = "Min Length Space"
        doc = """
                Coordinate space of dice:minlength.
            """
    )
    float primvars:ri:dice:offscreenmultiplier = -1 (
        displayGroup = "Dicing"
        displayName = "Dice Off Screen Multiplier"
        doc = """
                Dicing rate multiplier for objects outside the viewing frustum. If a value
                less than zero is specified, the value from the Option with the same name 
                will be used instead.
            """
    )
    token primvars:ri:dice:offscreenstrategy = "viewfrustumdistance" (
        allowedTokens = ["viewfrustumdistance", "worlddistance", "objectdistance", "planarprojection"]
        displayGroup = "Dicing"
        displayName = "Off Screen Dicing Strategy"
        doc = """
                Dicing method of objects outside the viewing frustum.
            """
    )
    token primvars:ri:dice:pretessellate (
        displayGroup = "SubdivisionMesh"
        displayName = "Pretessellate"
        doc = """
                Pre-tessellate subdivision geometry to polygons.
            """
    )
    token primvars:ri:dice:rasterorient (
        displayGroup = "Dicing"
        displayName = "Raster Oriented Dicing"
        doc = """
                Turning this off enables non-oriented dicing, a mode of dicing that
                computes micropolygon sizes using non-oriented raster space rather than
                screen-aligned raster space. Non-oriented dicing is useful for displacement
                around edges where projected micropolygon distance can be arbitrarily small.
            """
    )
    string primvars:ri:dice:referencecamera = "" (
        displayGroup = "Dicing"
        displayName = "Reference Camera"
        doc = """
                Specify the camera used for dicing. If no reference camera is specified, RenderMan
                will use the primary camera.
            """
    )
    string primvars:ri:dice:referenceinstance = "" (
        displayGroup = "Dicing"
        displayName = "Reference Instance"
        doc = """
                Specify the reference instance used for dicing and displacement shading.
                The reference instance is used to drive dicing and displacement based on its
                position, scale, user attributes, and scoped coordinate systems. Reference
                instances are specified by its identifier:name attribute (instance name). If no
                reference instance is specified, RenderMan will automatically pick the nearest
                instance inside the primary camera's view frustum.
            """
    )
    token primvars:ri:dice:strategy = "instanceprojection" (
        allowedTokens = ["instanceprojection", "worlddistance", "objectdistance"]
        displayGroup = "Dicing"
        displayName = "Dicing strategy"
        doc = """
                Dicing method of objects within the viewing frustum.
            """
    )
    token primvars:ri:dice:watertight (
        displayGroup = "SubdivisionMesh"
        displayName = "Watertight"
        doc = """
                Tessellate geometry with no holes. Watertight geometry requires less raytrace bias.
            """
    )
    float primvars:ri:dice:worlddistancelength = -1 (
        displayGroup = "Dicing"
        displayName = "Dicing Distance Length"
        doc = '''
                Micropolygon distance in world space for "worlddistance" dicing or object space for
                "objectdistance" dicing.
            '''
    )
    int primvars:ri:displacement:ignorereferenceinstance = 0 (
        displayGroup = "Shading"
        displayName = "Displacement Ignores Reference Instance"
        doc = """
                Indicates if displacement shading should ignore properties of the reference instance.
            """
    )
    string primvars:ri:displacementbound:CoordinateSystem = "object" (
        displayGroup = "Shading"
        displayName = "displacement Bound Coordinate System"
        doc = """
                The name of the coordinate system that the displacement bound is measured in.
            """
    )
    int primvars:ri:displacementbound:offscreen = 0 (
        displayGroup = "Shading"
        displayName = "Displacement Bound Off Screen"
        doc = """
                Apply displacementbound to offscreen geometry when dicing. Geometry that is
                entirely offscreen, but displaces into view may be prone to undertessellation
                because of the offscreen dicing strategy. This can be corrected by enabling this
                control and setting a reasonable displacementbound. Doing so will incur a
                performance penalty commensurate with the size of the displacement bound.
            """
    )
    float primvars:ri:displacementbound:sphere = 0 (
        displayGroup = "Shading"
        displayName = "Displacement Bound Radius"
        doc = """
                Maximum displacement distance used to compute object bounds. This value should
                be as tight as possible.
            """
    )
    float primvars:ri:falloffpower = 0 (
        displayGroup = "Points"
        displayName = "Falloff Power"
        doc = '''
                For use with points, if not supplied, or set to zero, the points will have a hard edge. A value of 1 is a "reasonable" value that emulates the usual cosine based falloff; this will likely be the goto value for most people doing volumetric particle effects. Values between 0 and 1 makes the falloff faster, eroding the point faster - point has "less presence". Values higher than 1 (up to infinity) makes the falloff slower to the point of being non-existent.
            '''
    )
    string primvars:ri:identifier:object = "" (
        displayGroup = "Common"
        displayName = "Identifier Object"
        doc = """
                Object shape name.
            """
    )
    token primvars:ri:polygon:concave (
        displayGroup = "PolygonMesh"
        displayName = "Concave"
        doc = """
                Allow concave polygons.
            """
    )
    token primvars:ri:polygon:smoothdisplacement (
        displayGroup = "PolygonMesh"
        displayName = "Prevent Polygon Cracking"
        doc = """
                Output smoothed (per-vertex) normals as Ndsp primvar, if
                polygon:smoothnormals hasn't already inserted smooth normals.
            """
    )
    token primvars:ri:polygon:smoothnormals (
        displayGroup = "PolygonMesh"
        displayName = "Smooth Normals"
        doc = """
                Smooth (per-vertex) normals if not provided.
            """
    )
    token primvars:ri:procedural:immediatesubdivide (
        displayGroup = "Procedural"
        displayName = "Immediate Subdivide"
        doc = "<help />"
    )
    token primvars:ri:procedural:reentrant (
        displayGroup = "Procedural"
        displayName = "Reentrant"
        doc = "<help />"
    )
    float[] primvars:ri:Ri:Bound = [0, 0, 0, 0, 0, 0] (
        displayGroup = "Volume"
        displayName = "Bound"
        doc = """
                Volume bounds.
            """
    )
    float primvars:ri:Ri:GeometricApproximationFocusFactor = 0 (
        displayGroup = "Dicing"
        displayName = "Focus Factor"
        doc = """
                Allows the renderer to use more coarse dicing for blurry objects due to
                depth of field.
            """
    )
    token primvars:ri:Ri:Orientation = "outside" (
        allowedTokens = ["inside", "outside"]
        displayGroup = "Shading"
        displayName = "Orientation"
        doc = """
                Geometry winding order that determines surface normal. This attribute effects
                lighting and displacement.
            """
    )
    token primvars:ri:shade:faceset (
        displayGroup = "SubdivisionMesh"
        displayName = "Face Set"
        doc = """
                Active geometry face indexes.
            """
    )
    string primvars:ri:stats:prototypeIdentifier = "" (
        displayGroup = "Common"
        displayName = "Stats Prototype Identifier"
        doc = """
                Identifier string used by the stats system when referring to this prototype.
            """
    )
    string primvars:ri:stitchbound:CoordinateSystem = "" (
        displayGroup = "SubdivisionMesh"
        displayName = "Stitch Bound Coordinate System"
        doc = "<help />"
    )
    float primvars:ri:stitchbound:sphere = 0 (
        displayGroup = "SubdivisionMesh"
        displayName = "Stitch Bound Radius"
        doc = "<help />"
    )
    token primvars:ri:trace:autobias (
        displayGroup = "Shading"
        displayName = "Auto Trace Bias"
        doc = """
                Enable automatic raytrace bias.
            """
    )
    float primvars:ri:trace:bias = 0.01 (
        displayGroup = "Shading"
        displayName = "Trace Bias"
        doc = """
                Manual raytrace bias in object space. Small values should be used to avoid
                artifacts such as shadow acne.
            """
    )
    token primvars:ri:trace:displacements (
        displayGroup = "Shading"
        displayName = "Enable Displacement"
        doc = """
                Enable displacement shading.
            """
    )
    token primvars:ri:trace:sssautobias (
        displayGroup = "Shading"
        displayName = "Auto Trace Bias for Subsurface scattering"
        doc = """
                Enable automatic raytrace bias for subsurface scattering rays.
            """
    )
    float primvars:ri:trace:sssbias = 0.0001 (
        displayGroup = "Shading"
        displayName = "Trace Bias for Subsurface scattering"
        doc = """
                Manual raytrace bias (in object space) for subsurface scattering rays.
                Small values should be used to avoid artifacts such as surface acne.
            """
    )
    token primvars:ri:trimcurve:sense = "inside" (
        allowedTokens = ["inside", "outside"]
        displayGroup = "NuPatch"
        displayName = "Trim Curve Sense"
        doc = "<help />"
    )
    string primvars:ri:volume:aggregate = "globalVolumeAggregate" (
        displayGroup = "Volume"
        displayName = "Aggregate"
        doc = """
                The name of the volume aggregate to which a volume
                belongs. If non-empty, the volume will only be
                rendered if the integrator explicitly uses that named
                aggregate, or if a surface shader such as PxrSurface
                binds the named aggregate to its interior.
            """
    )
    bool primvars:ri:volume:aggregaterespectvisibility = 1 (
        displayGroup = "Volume"
        displayName = "Aggregate Respect Visibility"
        doc = """
                If set to 1, standard visibility attributes will be respected by
                the volume if it is part of an aggregate. If set to 0, the visibility 
                attributes will be ignored and only the integrator visibility settings
                will apply.
            """
    )
    bool primvars:ri:volume:dsominmax (
        displayGroup = "Volume"
        displayName = "DSO Min/Max"
        doc = """
                Currently only used for aggregate volumes, and only
                for volumes that use an ImplicitField DSO. If set to
                1, the DSO may be able to use stored information from
                the file directly to compute the minimum and maximum
                values within the volume. This may allow the renderer to
                avoid shading the volume up front, greatly decreasing
                time to first pixel. This can only be enabled if the
                density signal from the volume is used directly, or if
                the density signal is modulated only by the DSO
                itself. Any shading modifications of the density
                signal requires setting this parameter to off.
            """
    )
    bool primvars:ri:volume:dsovelocity (
        displayGroup = "Volume"
        displayName = "DSO Velocity"
        doc = """
                Used only for aggregate volumes that use an ImplicitField DSO. If set to 1,
                the DSO can provide velocity bounds to the renderer directly via the BoxMotion
                call. This can allow the renderer to avoid upfront shading of the volume's
                velocity data when using Eulerian velocity, improving render time and time to
                first pixel greatly. This can only be enabled if the velocity signal from the DSO
                is used directly.
            """
    )
    float primvars:ri:volume:fps = 1 (
        displayGroup = "Volume"
        displayName = "Velocity frames per second"
        doc = """
                The frames per second for volumetric velocity data. The 
                velocity data will be divided by this quantity to derive
                the velocity for the frame.
            """
    )
    float primvars:ri:volume:shutteroffset = 1 (
        displayGroup = "Volume"
        displayName = "Shutter offset"
        doc = """
                The shutter offset used to interpret volumetric velocity.
                A value of 1 will use the current position of the 
                object and the position of the object on the next frame 
                as the time interval to use for motion blur. A value of -1 
                will use the position of the object on the previous frame 
                and the current position of the object as the time. A value 
                of 0 will generate an interval which begins halfway through 
                the previous frame and ends halfway into the next frame.
            """
    )
    token primvars:ri:volume:temporalmethod (
        allowedTokens = ["0", "1"]
        displayGroup = "Volume"
        displayName = "Temporal Method"
        doc = """
                Method of generating temporal data for volume rendering.
            """
    )
    bool primvars:ri:volume:velocityshuttercorrection = 0 (
        displayGroup = "Volume"
        displayName = "Velocity Shutter Correction"
        doc = """
                If set to 1, volumetric velocity data for Eulerian motion 
                blur will be assumed to be relative to the entire frame, 
                and will be corrected to match the current shutter interval.
                If set to 0, no correction will be made.
            """
    )
}

class PxrBlockerLightFilter "PxrBlockerLightFilter" (
    customData = {
        string className = "BlockerLightFilter"
    }
    inherits = </LightFilter>
)
{
    int inputs:ri:lightFilter:colorRamp = 4 (
        displayGroup = "Color Ramp"
        doc = """colorRamp: This is Optional.  It sets the color gradient
                  for the transition.
           """
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (Technically, they are applied one after the other.)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = "density: How much effect the filter has (0-1)."
    )
    float inputs:ri:lightFilter:depth = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Depth"
        doc = "depth: Depth of inner region of the rod (z axis)."
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    float inputs:ri:lightFilter:edge = 0.25 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Edge"
        doc = "edge: Thickness of edge region."
    )
    int inputs:ri:lightFilter:falloff = 6 (
        connectability = "interfaceOnly"
        displayGroup = "Falloff"
        doc = "falloff: Controls the transition from the core to the edge."
    )
    float[] inputs:ri:lightFilter:falloff_Floats = [0, 0, 0.2, 0.8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Falloff"
        hidden = true
    )
    token inputs:ri:lightFilter:falloff_Interpolation = "bspline" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Falloff"
        hidden = true
    )
    float[] inputs:ri:lightFilter:falloff_Knots = [0, 0, 0.3, 0.7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Falloff"
        hidden = true
    )
    float inputs:ri:lightFilter:height = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Height"
        doc = "height: Height of inner region of the rod (y axis)."
    )
    float inputs:ri:lightFilter:intensity = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = """intensity: Multiplier for both the diffuse and specular result.
            """
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = "invert: Inverts the entire effect of the filter."
    )
    float inputs:ri:lightFilter:radius = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Radius"
        doc = "radius: Radius of corners of inner rod box."
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Saturation"
        doc = """saturation: Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors)."""
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    float inputs:ri:lightFilter:width = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Width"
        doc = "width: Width of inner region of the rod (x axis)."
    )
    uniform token ri:lightFilter:shaderId = "PxrBlockerLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrGoboLightFilter "PxrGoboLightFilter" (
    customData = {
        string className = "GoboLightFilter"
    }
    inherits = </LightFilter>
)
{
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (technically: they are applied one after the other)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = "density: Controls the strength of the projected effect."
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    color3f inputs:ri:lightFilter:fillColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Fill Color"
        doc = """
                fillColor: If the texture is not repeating, this specifies the
                color for the region outside of and behind the projected rectangle.
            """
    )
    float inputs:ri:lightFilter:height = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Height"
        doc = "height: Height of the rect the light is shining through."
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = """intensity: Multiplier for both the diffuse and specular result.
            """
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = """invert: When this is on, the texture will be inverted before it is applied.
            """
    )
    bool inputs:ri:lightFilter:linearize = 0 (
        displayGroup = "Map"
        displayName = "Linearize"
        doc = "Linearize the texture, assuming an sRGB transfer function."
    )
    asset inputs:ri:lightFilter:map = @ratGrid.tex@ (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Map"
        doc = "map: Filename of the projected texture."
    )
    float inputs:ri:lightFilter:offsetU = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Offset U"
        doc = "offsetU: Offset of the texture in the U direction"
    )
    float inputs:ri:lightFilter:offsetV = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Offset V"
        doc = "offsetV: Offset of the texture in the V direction"
    )
    bool inputs:ri:lightFilter:premultipliedAlpha = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Premultiplied Alpha"
        doc = """
                premultipliedAlpha: Textures are usually premultiplied by their alpha. If this not
                the case, uncheck this.
            """
    )
    int inputs:ri:lightFilter:refreshMap = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        doc = """
                Press this button to force a refresh of the texture during
                Live Rendering.
            """
    )
    float inputs:ri:lightFilter:scaleU = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Scale U"
        doc = "scaleU: Scale of the texture in the U direction"
    )
    float inputs:ri:lightFilter:scaleV = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Scale V"
        doc = "scaleV: Scale of the texture in the V direction"
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    int inputs:ri:lightFilter:tileMode = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Tile Mode"
        doc = '''tileMode:
                "No Repeat"   - texture does not repeat.
                "Edge Extent" - extends the color of the edge to infinity.
                "Tile"        - texture repeats (tileable texture).
            '''
    )
    float inputs:ri:lightFilter:width = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Width"
        doc = "width: Width of the rect the light is shining through."
    )
    uniform token ri:lightFilter:shaderId = "PxrGoboLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrUnified "PxrUnified" (
    customData = {
        string className = "Unified"
    }
    inherits = </PxrIntegratorPluginBase>
)
{
    bool inputs:ri:accumOpacity = 1 (
        displayName = "Accumulate Opacity"
        doc = "When enabled, refractive objects produce partial alpha.\\nWhen disabled, refractive objects produce full alpha."
    )
    int inputs:ri:allowMultilobeIndirect = 0 (
        displayGroup = "Sampling"
        displayName = "Multi-Lobe Indirect"
        doc = "if enabled, Hair may converge faster but this might break any LPE related operations."
    )
    float inputs:ri:catchAllLights = 0 (
        displayName = "Catch Light on last Hit"
        doc = """
           On a path's last hit, the lights can be evaluated without shadowing to avoid a black contribution.
           This parameter scales the last hit's intensity from 0 (no light evaluation) and 1 (light evaluation).
        """
    )
    float inputs:ri:causticClamp = 1000000 (
        displayGroup = "Sampling:Intensity Clamping"
        displayName = "Max Caustics Value"
        doc = "Maximum value of caustics samples."
    )
    float inputs:ri:directClamp = 1000000 (
        displayGroup = "Sampling:Intensity Clamping"
        displayName = "Max Direct Lighting Value"
        doc = "Maximum value of direct lighting samples."
    )
    float inputs:ri:emissionMultiplier = 1 (
        displayName = "Emission Multiplier"
        doc = "Internally multiplies all emission values (light/glow) during lighting integration."
    )
    bool inputs:ri:enableSampleTimers = 0 (
        displayGroup = "Diagnostic"
        displayName = "Enable Sample Timers"
        doc = "enable the timers that track pixel sample iteration cost"
    )
    bool inputs:ri:enableShadingTimers = 0 (
        displayGroup = "Diagnostic"
        displayName = "Enable Shading Timers"
        doc = "enable the timers that will track shading cost grouped by the profileGroup user attribute"
    )
    bool inputs:ri:enableVolumeCaustics = 0 (
        displayGroup = "ManifoldWalk"
        displayName = "Enable Volume Caustics"
        doc = '''
                Enable volume integrator when evaluating throughput along the caustic path.
                Volume GPrims need to be member of the group "mw_volume_include_subset".
                If this is turned on, shadow computation will be more expensive.
                Should only be used when necessary.
            '''
    )
    float inputs:ri:indirectClamp = 8 (
        displayGroup = "Sampling:Intensity Clamping"
        displayName = "Max Indirect Value"
        doc = "Maximum value of indirect samples."
    )
    float inputs:ri:indirectDirectionalBlurRadius = 0 (
        displayGroup = "IndirectGuiding"
        displayName = "Directional Blur Radius"
        doc = """
                Blurs the node contributions of the directional tree.
                This only affects the sampling distribution.
            """
    )
    int inputs:ri:indirectOversampling = 2 (
        connectability = "interfaceOnly"
        displayGroup = "IndirectGuiding"
        displayName = "Oversampling"
        doc = """
                Oversample the tree lookups for better estimates.
            """
    )
    float inputs:ri:indirectSpatialBlurRadius = 0.25 (
        displayGroup = "IndirectGuiding"
        displayName = "Spatial Blur Radius"
        doc = """
                Blurs the node contributions of the spatial tree to hide node boundaries.
                This only affects the sampling distribution.
            """
    )
    int inputs:ri:indirectTrainingSamples = 0 (
        displayGroup = "IndirectGuiding"
        displayName = "Training Samples"
        doc = """
                The number of samples used to learn the scene's illumination.
                This number should never be larger than minsamples and represent 10-20% of maxsamples.
                64 training samples is a bare minimum and you will get better results with larger numbers.
            """
    )
    bool inputs:ri:manifoldWalk = 0 (
        displayGroup = "ManifoldWalk"
        displayName = "Enable Manifold Walk"
        doc = "Enable Manifold Walk"
    )
    int inputs:ri:maxIndirectBounces = 8 (
        displayName = "Max Indirect Bounces"
        doc = '''
            The maximum number of bounces of indirect illumination in your scene.
            0 means direct illumination only, 1 means one bounce of indirect, etc.
            Note: this parameter used to be called "maxPathLength" -- the new name
            is more descriptive, but the effect is the same.
        '''
    )
    int inputs:ri:maxInterfaces = 2 (
        displayGroup = "ManifoldWalk"
        displayName = "Max Number of Interfaces"
        doc = """
                Maximum number of transmitive interfaces in the caustic sub-path found by the manifold walk.
            """
    )
    int inputs:ri:maxIterations = 10 (
        displayGroup = "ManifoldWalk"
        displayName = "Max Iterations"
        doc = """
                Maximum number of iterations before the walk gives up on a caustic path.
            """
    )
    int inputs:ri:maxNonStochasticOpacityEvents = 0 (
        connectability = "interfaceOnly"
        displayName = "Stochastic Opacity Depth"
        doc = '''
    Defines the camera ray depth for which opacity
    calculations are computed with no noise (using
    continuation rays). Once this depth is exceeded,
    the opacity computation will switch to a stochastic
    "presence" style of opacity, which may introduce
    noise.
    The default is 0.
        '''
    )
    float inputs:ri:maxRayDistance = 10000 (
        displayName = "Max Ray Distance"
        doc = "Objects beyond that distance will NOT be hit."
    )
    int inputs:ri:numBxdfSamples = 1 (
        displayGroup = "Sampling"
        displayName = "BxDF Samples"
        doc = "Number of BxDF samples for each iteration."
    )
    int inputs:ri:numIndirectSamples = 1 (
        displayGroup = "Sampling"
        displayName = "Indirect Samples"
        doc = "Number of indirect samples for each iteration."
    )
    int inputs:ri:numLightSamples = 1 (
        displayGroup = "Sampling"
        displayName = "Light Samples"
        doc = "Number of light samples for each iteration."
    )
    int inputs:ri:numVolumeAggregateSamples = 1 (
        displayGroup = "Sampling"
        displayName = "Volume Aggregate Samples"
        doc = "Number of volume aggregate samples for each iteration."
    )
    bool inputs:ri:photonAdaptive = 0 (
        displayGroup = "Photons"
        displayName = "Adaptive Photons"
        doc = "Enables robust progressive photon mapping"
    )
    int inputs:ri:photonEstimationNumber = 64 (
        displayGroup = "Photons"
        displayName = "Estimation Number"
        doc = "Estimation Number"
    )
    float inputs:ri:photonEstimationRadius = 0 (
        displayGroup = "Photons"
        displayName = "Estimation Radius"
        doc = "in scene units"
    )
    bool inputs:ri:photonVisibilityRod = 0 (
        displayGroup = "Photons"
        displayName = "Visibility Rod"
        doc = "Visibility Rod"
    )
    float inputs:ri:photonVisibilityRodDirectProb = 0 (
        displayGroup = "Photons"
        displayName = "Visibility Rod Probability"
        doc = "Visibility Rod Probability"
    )
    point3f inputs:ri:photonVisibilityRodMax = (0, 0, 0) (
        displayGroup = "Photons"
        displayName = "Visibility Rod Max"
        doc = "Visibility Rod Max"
    )
    point3f inputs:ri:photonVisibilityRodMin = (0, 0, 0) (
        displayGroup = "Photons"
        displayName = "Visibility Rod Min"
        doc = "Visibility Rod Min"
    )
    bool inputs:ri:risPathGuiding = 0 (
        displayGroup = "Sampling"
        displayName = "RIS path guiding"
        doc = "Use learnt results to guide indirect path sampling. Requires light learning to be enabled"
    )
    int inputs:ri:rouletteDepth = 1 (
        displayGroup = "Sampling:Russian Roulette"
        displayName = "Start Depth"
        doc = """
                    The path length at which the integrator will begin performing Russian roulette (a method of probabilistically terminating a ray path).
                    Decreasing this setting will lead to shorter paths and faster renders, but will result in more noise.
                """
    )
    int inputs:ri:rouletteLightDepth = 1 (
        displayGroup = "Sampling:Russian Roulette"
        displayName = "Light Start Depth"
        doc = """
                    Path length at which the integrator will start to drop low contribution lights.
                    Only available during bidirectional integration.
                """
    )
    float inputs:ri:rouletteThreshold = 0.2 (
        displayGroup = "Sampling:Russian Roulette"
        displayName = "Threshold"
        doc = """
                    The path throughput threshold below which Russian roulette is applied.
                    It is usually preferable to apply Russian roulette only to paths of low importance in order to avoid noise.
                    Increasing this setting will apply Russian roulette to more paths and thus increase the speed of the render, but may also increase noise.
                """
    )
    int inputs:ri:sssOversampling = 8 (
        displayGroup = "Sampling"
        displayName = "SubSurface Over-Sampling"
        doc = "Number of importance-resampled samples taken for subsurface scattering events."
    )
    int inputs:ri:suppressNaNs = 0 (
        displayGroup = "Diagnostic"
        displayName = "Suppress NaNs"
        doc = "Suppresses individual invalid samples (NaN or inf), preventing them from reaching the final image. Be aware that there is a cost to checking for this, and it should not be enabled broadly or blindly."
    )
    int inputs:ri:traceLightPaths = 0 (
        displayName = "Trace Light Paths"
        doc = """
        PxrUnified has 4 integration modes:
        - Off: unidirectional path tracing
        - On: bidirectional path tracing
        - Photons Only: progressive photon mapping
        - UPS/VCM: bidirectional path tracing with vertex connection and merging.
        """
    )
    bool inputs:ri:useTraceDepth = 0 (
        displayName = "Use Trace Depth"
        doc = """
           When enabled, the trace:maxdiffusedepth and
           trace:maxspeculardepth attributes are also used to limit
           the ray depth. When disabled, only the maxPathLength
           parameter is used.
        """
    )
    float inputs:ri:walkThreshold = 0.005 (
        displayGroup = "ManifoldWalk"
        displayName = "Threshold"
        doc = """
                Convergence threshold for the manifold walk algorithm.
            """
    )
    uniform token ri:integrator:shaderId = "PxrUnified" (
        displayGroup = "Internal"
    )
}

class PxrAovLight "PxrAovLight" (
    customData = {
        string className = "AovLight"
    }
    inherits = </NonboundableLightBase>
)
{
    string inputs:ri:light:aovName = "" (
        connectability = "interfaceOnly"
        displayName = "AOV Name"
        doc = """
            The name of the AOV to write to.
        """
    )
    bool inputs:ri:light:inPrimaryHit = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "In Primary Hit"
        doc = """
                If this is on, the usual mask of the illuminated objects is
                generated. If this is off, you can get a mask of only in
                the refraction or reflection.
            """
    )
    bool inputs:ri:light:inReflection = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "In Reflection"
        doc = """
                If this is on, the rays are traced through the specular reflections to get
                the masking signal.

                Warning: this will require some amount of samples to get a clean mask.
            """
    )
    bool inputs:ri:light:inRefraction = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "In Refraction"
        doc = """
                If this is on, the rays are traced through the glass refractions
                to get the masking signal.

                Warning: this will require some amount of samples to get a clean mask.
            """
    )
    bool inputs:ri:light:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Invert"
        doc = """
                If this is on, it inverts the signal for the AOV.
            """
    )
    bool inputs:ri:light:onVolumeBoundaries = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "On Volume Boundaries"
        doc = """
                If this is on, the bounding box or shape of volumes will appear in
                the mask. Since this is not always desirable, this can be turned off.
            """
    )
    bool inputs:ri:light:useColor = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Use Color"
        doc = """
                If this is on, it outputs a RGB color image instead of a float image
                for the AOV.
            """
    )
    bool inputs:ri:light:useThroughput = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Use Throughput"
        doc = """
                If this is on, the values in the mask for the reflected or refracted
                rays will be affected by the strength of the reflection or refraction.
                This can lead to values below and above 1.0. Turn this off if you
                want a more solid mask.
            """
    )
    uniform token ri:light:shaderId = "PxrAovLight" (
        displayGroup = "Internal"
    )
}

class "PxrCylinderLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["CylinderLight"]
        string apiSchemaType = "singleApply"
        string className = "CylinderLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
        doc = """
                diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a diffuse surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
        doc = """
                 When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light.
                 (Note that there is no way to set emissionFocusTint in this mode).
             """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator. It's recommended to leave this at the default unless
                you experience unsolvable noise from the light.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
        doc = """
                intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter. This may help you avoid hot spots and
                sampling issues where a light is near a surface.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful to
                generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
        doc = """
                specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a specular surface. 
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrCylinderLight" (
        displayGroup = "Internal"
    )
}

class "PxrDiskLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["DiskLight"]
        string apiSchemaType = "singleApply"
        string className = "DiskLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
        doc = """
                diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a diffuse surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
        doc = """
                 When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light.
                 (Note that there is no way to set emissionFocusTint in this mode).
             """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator.  It's recommended to leave this at the default unless
                you experience unsolvable noise from the light.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
        doc = """
                intensityNearDist: Near distance between the point being illuminated and
                the light at which the sample doesn't get brighter. This may help you
                avoid hot spots and sampling issues where a light is near a surface.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful to
                generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
        doc = """
                specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a specular surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrDiskLight" (
        displayGroup = "Internal"
    )
}

class "PxrDistantLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["DistantLight"]
        string apiSchemaType = "singleApply"
        string className = "DistantLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used
                to prevent occlusion during the search of caustic paths.
            """
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
        doc = """
                 When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light.
                 (Note that there is no way to set emissionFocusTint in this mode).
             """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator. You might find need for this if you have
                unsolvable noise from this light and need more samples.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is
                useful to generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrDistantLight" (
        displayGroup = "Internal"
    )
}

class "PxrDomeLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["DomeLight"]
        string apiSchemaType = "singleApply"
        string className = "DomeLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    float3 inputs:ri:light:colorMapGamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Map Gamma"
        doc = """
                colorMapGamma: Gamma-correct the texture.
            """
    )
    float inputs:ri:light:colorMapSaturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Map Saturation"
        doc = """
                colorMapSaturation: Adjust the texture's saturation.
            """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator. It's recommended to leave this at the
                default unless you experience unsolvable noise from the light.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful to
                generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrDomeLight" (
        displayGroup = "Internal"
    )
}

class PxrEnvDayLight "PxrEnvDayLight" (
    customData = {
        string className = "EnvDayLight"
    }
    inherits = </NonboundableLightBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    int inputs:ri:light:day = 20 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Day"
        doc = """
                day: Day of the month, 1 through 31.

                This is ignored if month is 0.
            """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator. You might find need for this if you have
                unsolvable noise from this light and need more samples.
            """
    )
    color3f inputs:ri:light:groundColor = (0.18, 0.18, 0.18) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Ground Color"
        doc = """
              groundColor: A flat color for the diffuse ground floor.
            """
    )
    int inputs:ri:light:groundMode = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Ground Mode"
        doc = """
              Legacy: Old behavior,
              Horizon Clamping: Smear horizon values on the virtual ground plane,
              Diffuse Ground: A fake infinite ground plane with diffuse color
            """
    )
    float inputs:ri:light:haziness = 2 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Haziness"
        doc = """
              haziness: The turbidity of the sky.  The lower limit of the model is 1.7 for
              an exceptionally clear sky, and 10, for an inversion, is the upper
              limit.
            """
    )
    float inputs:ri:light:hour = 14.633333 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Hour"
        doc = """
              hour: Hours since midnight, local standard time.  May be fractional to
              include minutes and seconds.  If daylight saving time is in effect,
              subtract 1 to correct to standard time.

              This is ignored if month is 0.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:latitude = 47.6019 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Latitude"
        doc = """
                latitude: Latitude in degrees.  Positive for north, negative for south.  Ranges frmo -90 to +90 degrees.

                This is ignored if month is 0.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful to
                generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:longitude = -122.3318 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Longitude"
        doc = """
                longitude: Longitude in degrees.  Positive for east, negative for west.  Ranges frmo -180 to +180 degrees.

                This is ignored if month is 0.
            """
    )
    int inputs:ri:light:month = 11 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Month"
        doc = """
                month: Month of the year, 1 through 12.
                The default, 0, means to use the explicitly given sun direction
                instead of automatically computing it.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:skyTint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Sky Tint"
        doc = """
              skyTint: Tweak the sky's contribution and color.  The default, white (1,1,1),
              gives results based on measured physical values.
            """
    )
    vector3f inputs:ri:light:sunDirection = (0, 1, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Direction"
        doc = """
              sunDirection: The *apparent* direction towards the center of
              the sun.  The zenith is at +Y (for noon light) and the
              horizon is in the XZ plane (for sunrise/set).  Note that the
              Y component must non-negative.  Ignored if a month is given.
            """
    )
    float inputs:ri:light:sunSize = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Sun Size"
        doc = """
              sunSize: Scale the apparent size of the sun in the sky.  Leave at 1 for a
              realistic sun size with an 0.55 degree angular diameter.
            """
    )
    color3f inputs:ri:light:sunTint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Sun Tint"
        doc = """
              sunTint: Tweak the sun's contribution and color.  The default, white (1,1,1),
              gives results based on measured physical values. Setting this to black removes the
              sun contribution.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    int inputs:ri:light:year = 2014 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Year"
        doc = """
              year: Four-digit year.

              This is ignored if month is 0.
            """
    )
    float inputs:ri:light:zone = -8 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Time Zone"
        doc = """
                zone: Standard time zone offset from GMT/UTC in hours.  Positive for east,
                negative for west.  For example, this would be -8 for Pacific time.

                This is ignored if month is 0.
            """
    )
    uniform token ri:light:shaderId = "PxrEnvDayLight" (
        displayGroup = "Internal"
    )
}

class "PxrMeshLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["MeshLightAPI", "VolumeLightAPI"]
        string apiSchemaType = "singleApply"
        string className = "MeshLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic path.
            """
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
        doc = """
                diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a diffuse surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
        doc = """
                intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter. This may help you avoid hot spots and
                sampling issues where a light is near a surface.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup: Specify the light group name used for light group LPEs. This is useful to generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
        doc = """
                specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a specular surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Cheap Caustics is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrMeshLight" (
        displayGroup = "Internal"
    )
}

class "PxrPortalLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["PortalLight"]
        string apiSchemaType = "singleApply"
        string className = "PortalLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    float3 inputs:ri:light:colorMapGamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Map Gamma"
        doc = """
                colorMapGamma: Gamma-correct the texture.
            """
    )
    float inputs:ri:light:colorMapSaturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Map Saturation"
        doc = """
                colorMapSaturation: Adjust the texture's saturation.
            """
    )
    string inputs:ri:light:domeColorMap = "" (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        hidden = true
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator. You might find need for this if you have
                unsolvable noise from this light and need more samples.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:intensityMult = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Intensity Multiplier"
        doc = """
                intensityMult:  Intensity adjustment relative to the dome intensity. This gets
                multiplied by the parent dome light's intensity and power.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful
                to generate per-light AOVs for later adjustment in compositing
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    string inputs:ri:light:portalName (
        displayGroup = "Advanced"
        hidden = true
    )
    matrix4d inputs:ri:light:portalToDome (
        displayGroup = "Advanced"
        hidden = true
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    color3f inputs:ri:light:tint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Color Tint"
        doc = """
               tint: This parameter tints the color from the dome texture.
            """
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrPortalLight" (
        displayGroup = "Internal"
    )
}

class "PxrRectLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["RectLight"]
        string apiSchemaType = "singleApply"
        string className = "RectLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    float3 inputs:ri:light:colorMapGamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Map Gamma"
        doc = """
                colorMapGamma: Gamma-correct the texture.
            """
    )
    float inputs:ri:light:colorMapSaturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        displayName = "Map Saturation"
        doc = """
                colorMapSaturation: Adjust the texture's saturation.
            """
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
        doc = """
                diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a diffuse surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
        doc = """
                 When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light.
                 (Note that there is no way to set emissionFocusTint in this mode).
             """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator and can result in a performance impact. For scenes that
                have lots of lights, resulting in some lights that are under-sampled, you may want to set it
                to non-zero.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
        doc = """
                intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter. This may help you avoid hot spots and
                sampling issues where a light is near a surface.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful to
                generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
        doc = """
                specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a specular surface. 
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrRectLight" (
        displayGroup = "Internal"
    )
}

class "PxrSphereLightAPI" (
    customData = {
        token[] apiSchemaAutoApplyTo = ["SphereLight"]
        string apiSchemaType = "singleApply"
        string className = "SphereLightAPI"
    }
    inherits = </APISchemaBase>
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
        doc = """
                Enable manifold walk computation and disable thin shadow for this light.
                This parameter will be ignored if Trace Light Paths is enabled.
            """
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Manifold Walk Caustics Exclude Group"
        doc = """
                Specifies the exclude shadow subset for manifold walk. Will be used to prevent occlusion during the search of caustic paths.
            """
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
        doc = """
                diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a diffuse surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
        doc = """
                 When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light.
                 (Note that there is no way to set emissionFocusTint in this mode).
             """
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Samples"
        doc = """
                fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source. If set to something other than zero, it will override the
                sampling performed by the integrator. It's recommended to leave this at the default unless
                you experience unsolvable noise from the light.
            """
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
        doc = """
                Importance of this light for noise control.
            """
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
        doc = """
                intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter. This may help you avoid hot spots and
                sampling issues where a light is near a surface.
            """
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Light Group"
        doc = """
                lightGroup:  Specify the light group name used for light group LPEs. This is useful to
                generate per-light AOVs for later adjustment in compositing.
            """
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
        doc = """
                msApprox: Enable multi-scattering approximation. When enabled, multi-scattering approximation mimics
                the effect of multi-scattering in aggregate volumes.

                NOTE: Values other than 0 or 1 may produce incorrect results.
            """
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
        doc = """
                msApproxBleed: The color of the light bleed from multi-scattering approximation. Controls how much
                light bleeds into the volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
        doc = """
                msApproxContribution: The color of the contribution of light from multi-scattering approximation.
                Controls how much the light bleed contributes to the brightness of volumes illuminated by this light.
                Has no effect if msApprox is set to 0.
            """
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
        doc = """
                specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter. This may help you 
                avoid hot spots and sampling issues where a light is near a specular surface.
                Note that this value will not apply to lights as seen from the camera.
            """
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
        doc = '''
                thinShadow: Enable thin shadow and disable refraction caustics for this light.
                This parameter will be ignored if Trace Light Paths is enabled. This is a
                non-physical control that creates "fake" colored shadows for transmissive
                objects without needing to generate photons for caustics.
                Also for the paths where Cheap Caustics is enabled (surfaces marked "MWWalkable"),
                then thinShadow is ignored as well.
            '''
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
        doc = """
                Enables light and photon tracing from this light. This value enforces a 
                physically-based light and as a side-effect disables thinShadow and 
                visibleInRefractionPath. Users may use this feature to selectively decide 
                which lights emit photons when using the PxrVCM or PxrUnified Integrators. 
                Because it will automatically disable thin shadows, this should not be 
                enabled when using the PxrPathTracer integrator.
            """
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
        doc = """
                visibleInRefractionPath: Make this light source visible in refraction paths.
                This parameter will be ignored if Manifold Walk is enabled.
            """
    )
    uniform token ri:light:shaderId = "PxrSphereLight" (
        displayGroup = "Internal"
    )
}

class PxrBarnLightFilter "PxrBarnLightFilter" (
    customData = {
        string className = "BarnLightFilter"
    }
    inherits = </LightFilter>
)
{
    float inputs:ri:lightFilter:apex = 25 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Apex"
        doc = """apex: Distance between center of barn and center of projection.
            """
    )
    int inputs:ri:lightFilter:barnMode = 0 (
        connectability = "interfaceOnly"
        displayName = "Barn Mode"
        doc = """barnMode:

        In 'physical' mode the barn behaves like an open window through which
        light falls. The falloff and blur are determined by the size of the
        light, the distance to the light and distance from the barn.

        In 'analytic' mode, the barn has a fixed projection and manual
        falloff controls.
        """
    )
    float inputs:ri:lightFilter:bottom = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Bottom"
        doc = "bottom: Additional offset of the bottom region (-y axis)."
    )
    float inputs:ri:lightFilter:bottomEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Bottom Edge"
        doc = """
                    bottomEdge: When edge is > 0, this scales the edge of the bottom region (-y axis).
                """
    )
    int inputs:ri:lightFilter:colorRamp = 4 (
        displayGroup = "Color Ramp"
        doc = """colorRamp: This is Optional.  This sets the color gradient 
                  for the transition.
            """
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (Technically, they are applied one after the other.)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = "density: How much effect the component has (0-1)."
    )
    float inputs:ri:lightFilter:densityFar = 10 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Far"
        doc = "densityFar: Distance from the barn where the density interpolation ends."
    )
    float inputs:ri:lightFilter:densityFarVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Far Val"
        doc = "densityFarVal: Density multiplier where the blur interpolation ends."
    )
    float inputs:ri:lightFilter:densityNear = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Near"
        doc = "densityNear: Distance from the barn where the density interpolation starts."
    )
    float inputs:ri:lightFilter:densityNearVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Near Val"
        doc = "densityNearVal: Density multiplier where the blur interpolation starts."
    )
    float inputs:ri:lightFilter:densityPow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Exponent"
        doc = "densityPow: Exponent of the density interpolation."
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    bool inputs:ri:lightFilter:directional = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Directional"
        doc = """directional: Whether or not the light projects along a direction or
            out from a point.
            """
    )
    float inputs:ri:lightFilter:edge = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape"
        displayName = "Edge Thickness"
        doc = """edge: Thickness of the edge region.  Greater value will add
                  more softness to the edges of the barn shape.
            """
    )
    float inputs:ri:lightFilter:height = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape"
        displayName = "Height"
        doc = "height: Height of the inner region of the barn (y axis)."
    )
    float inputs:ri:lightFilter:intensity = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = """intensity: Multiplier for both the diffuse and specular result.
            """
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = """invert: When this is on, invert the entire effect of the light
                  filter.
            """
    )
    float inputs:ri:lightFilter:left = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Left"
        doc = "left: Additional offset of the left region (-x axis)."
    )
    float inputs:ri:lightFilter:leftEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Left Edge"
        doc = """
                    leftEdge: When edge is > 0, this scales the edge of the left region (-x axis).
                """
    )
    int inputs:ri:lightFilter:preBarn = 2 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape"
        displayName = "Pre Barn Effect"
        doc = "preBarn: The effect on the light before it reaches the barn."
    )
    float inputs:ri:lightFilter:radius = 0.5 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape"
        displayName = "Radius"
        doc = "radius: Radius of the corners of the inner barn square."
    )
    float inputs:ri:lightFilter:right = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Right"
        doc = "right: Additional offset of the right region (+x axis)."
    )
    float inputs:ri:lightFilter:rightEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Right Edge"
        doc = """
                    rightEdge: When edge is > 0, this scales the edge of the right region (+x axis).
                """
    )
    float inputs:ri:lightFilter:scaleHeight = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Scale"
        displayName = "Scale Height"
        doc = """
                   scaleHeight: Scale the height of the inner barn shape (y axis).
                   This includes scaling the radius.
                """
    )
    float inputs:ri:lightFilter:scaleWidth = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Scale"
        displayName = "Scale Width"
        doc = """
                    scaleWidth: Scale the width of the inner barn shape (x axis).
                    This includes scaling the radius.
                """
    )
    float inputs:ri:lightFilter:shearX = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Shear X"
        doc = "shearX: Shear the projection along the x-axis."
    )
    float inputs:ri:lightFilter:shearY = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Shear Y"
        doc = "shearY: Shear the projection along the y-axis."
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    float inputs:ri:lightFilter:top = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Top"
        doc = "top: Additional offset of the top region (+y axis)."
    )
    float inputs:ri:lightFilter:topEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Top Edge"
        doc = """
                    topEdge: When edge is > 0, this scales the edge of the top region (+y axis).
                """
    )
    bool inputs:ri:lightFilter:useLightDirection = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Use Light Direction"
        doc = """ useLightDirection: If checked the projection direction
                   is determined by the position of the center of the light source.
                   Otherwise it only follows the orientation of the cookie.
                   WARNING: this does not work with dome and geometric area lights.
            """
    )
    float inputs:ri:lightFilter:width = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Barn Shape"
        displayName = "Width"
        doc = "width: Width of the inner region of the barn (x axis)."
    )
    uniform token ri:lightFilter:shaderId = "PxrBarnLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrCombinerLightFilter "PxrCombinerLightFilter" (
    customData = {
        string className = "CombinerLightFilter"
    }
    inherits = </LightFilter>
)
{
    bool inputs:ri:lightFilter:combineShadows = 0 (
        connectability = "interfaceOnly"
        displayName = "Combine shadows"
        doc = """
            Enables the shadow manipulation abilities of any connected light filters.
        """
    )
    token inputs:ri:lightFilter:max (
        displayName = "Max"
        doc = """
            max: Combining light filters by returning the maximum result.
        """
    )
    token inputs:ri:lightFilter:min (
        displayName = "Min"
        doc = """
            min: Combining light filters by returning the mininum result.
        """
    )
    token inputs:ri:lightFilter:mult (
        displayName = "Mult"
        doc = """
            mult: Combining light filters by multiplying.
        """
    )
    token inputs:ri:lightFilter:screen (
        displayName = "Screen"
        doc = '''
            screen: Combining light filters by returning the "screen" result.
            Screen operation is similar to the max operation, but it combines gradients
            in a smoother way.
        '''
    )
    uniform token ri:lightFilter:shaderId = "PxrCombinerLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrCookieLightFilter "PxrCookieLightFilter" (
    customData = {
        string className = "CookieLightFilter"
    }
    inherits = </LightFilter>
)
{
    float inputs:ri:lightFilter:apex = 25 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Apex"
        doc = """apex: Distance between the center of cookie and the center of projection.
            """
    )
    float inputs:ri:lightFilter:blur = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur"
        doc = """
                blur: Blurriness of texture (0-1, multiplied by blurNear/blurFar interp).
            """
    )
    float inputs:ri:lightFilter:blurFarDist = 10 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Far Dist"
        doc = "blurFarDist: Distance from the cookie where the blur interpolation ends."
    )
    float inputs:ri:lightFilter:blurFarVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Far Value"
        doc = "blurFarVal: Blur multiplier where the blur interpolation ends."
    )
    float inputs:ri:lightFilter:blurMidpoint = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Midpoint"
        doc = "blurMidpoint: Distance between near and far, where the midValue is located."
    )
    float inputs:ri:lightFilter:blurMidVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Mid Value"
        doc = "blurMidVal: Blur multiplier in the middle of the blur interpolation."
    )
    float inputs:ri:lightFilter:blurNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Near Dist"
        doc = "blurNearDist: Distance from the cookie where the blur interpolation starts."
    )
    float inputs:ri:lightFilter:blurNearVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Near Value"
        doc = "blurNearVal: Blur multiplier where the blur interpolation starts."
    )
    float inputs:ri:lightFilter:blurPow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "Blur Exponent"
        doc = "blurPow: Exponent of the blur interpolation."
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (technically: they are applied one after the other)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:contrast = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Contrast"
        doc = """
                contrast: Contrast control (less than 1 = contrast reduction,
                larger than 1 = contrast increase).
            """
    )
    int inputs:ri:lightFilter:cookieMode = 0 (
        connectability = "interfaceOnly"
        displayName = "Cookie Mode"
        doc = """
            cookieMode:

            In 'physical' mode the cookie behaves like a stained glass window
            through which light falls. The falloff and blur are determined by the
            size of the light, the distance to the light and distance from the
            cookie.

            In 'analytic' mode, the cookie has a fixed projection and manual
            blur and falloff controls.
        """
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = "density: Controls the strength of the projected effect."
    )
    float inputs:ri:lightFilter:densityFarDist = 10 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Far Dist"
        doc = "densityFarDist: Distance from the cookie where the density interpolation ends."
    )
    float inputs:ri:lightFilter:densityFarVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Far Value"
        doc = "densityFarVal: Density multiplier where the blur interpolation ends."
    )
    float inputs:ri:lightFilter:densityMidpoint = 0.5 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Midpoint"
        doc = "densityMidpoint: Distance between near and far, where the midValue is located."
    )
    float inputs:ri:lightFilter:densityMidVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Mid Value"
        doc = "densityMidVal: Density multiplier in the middle of the density interpolation."
    )
    float inputs:ri:lightFilter:densityNearDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Near Dist"
        doc = "densityNearDist: Distance from the cookie where the density interpolation starts."
    )
    float inputs:ri:lightFilter:densityNearVal = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Near Value"
        doc = "densityNearVal: Density multiplier where the blur interpolation starts."
    )
    float inputs:ri:lightFilter:densityPow = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Density Falloff"
        displayName = "Density Exponent"
        doc = "densityPow: Exponent of the density interpolation."
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    bool inputs:ri:lightFilter:directional = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Directional"
        doc = """directional:  When this is on, the texture projects along a
                  direction using the orthographic projection. When it is off,
                  the texture projects using a focal point specified by the Apex.
            """
    )
    color3f inputs:ri:lightFilter:fillColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Fill Color"
        doc = """
                fillColor: If the texture is not repeating, this specifies the
                color for the region outside of and behind the projected rectangle.
            """
    )
    float inputs:ri:lightFilter:height = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Height"
        doc = "height: Height of the rect the light is shining through."
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = """intensity: Multiplier for both the diffuse and specular result.
            """
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = """invert: When this is on, the texture will be inverted before it is applied.
            """
    )
    bool inputs:ri:lightFilter:invertU = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Invert U"
        doc = "invertU: flip the texture from left to right."
    )
    bool inputs:ri:lightFilter:invertV = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Invert V"
        doc = "invertV: flip the texture from bottom to top."
    )
    bool inputs:ri:lightFilter:linearize = 0 (
        displayGroup = "Map"
        displayName = "Linearize"
        doc = "Linearize the texture, assuming an sRGB transfer function."
    )
    asset inputs:ri:lightFilter:map = @ratGrid.tex@ (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Map"
        doc = "map: Filename of the projected texture."
    )
    float inputs:ri:lightFilter:midpoint = 0.18 (
        connectability = "interfaceOnly"
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Midpoint"
        doc = "midpoint: Midpoint for the contrast control."
    )
    float inputs:ri:lightFilter:offsetU = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Offset U"
        doc = "offsetU: Offset of the texture in the U direction"
    )
    float inputs:ri:lightFilter:offsetV = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Offset V"
        doc = "offsetV: Offset of the texture in the V direction"
    )
    bool inputs:ri:lightFilter:premultipliedAlpha = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Premultiplied Alpha"
        doc = """
                premultipliedAlpha: Textures are usually premultiplied by their alpha. If this not
                the case, uncheck this.
            """
    )
    int inputs:ri:lightFilter:refreshMap = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        doc = """
                Press this button to force a refresh of the texture during
                Live Rendering.
            """
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Saturation"
        doc = """
                saturation: Saturation of the result (0=greyscale,1=normal,>1=boosted colors).
            """
    )
    float inputs:ri:lightFilter:sBlurMult = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "S Blur Mult"
        doc = "sBlurMult: Blur multiplier in S direction."
    )
    float inputs:ri:lightFilter:scaleU = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Scale U"
        doc = "scaleU: Scale of the texture in the U direction"
    )
    float inputs:ri:lightFilter:scaleV = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Scale V"
        doc = "scaleV: Scale of the texture in the V direction"
    )
    float inputs:ri:lightFilter:shearX = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Shear X"
        doc = "shearX: Shear the projection along the x-axis."
    )
    float inputs:ri:lightFilter:shearY = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Shear Y"
        doc = "shearY: Shear the projection along the y-axis."
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    bool inputs:ri:lightFilter:spherical = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Spherical"
        doc = """spherical:  When this is on, the texture projects to a sphere
            instead of to a plane.
            """
    )
    float inputs:ri:lightFilter:tBlurMult = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blur"
        displayName = "T Blur Mult"
        doc = "tBlurMult: Blur multiplier in T direction."
    )
    int inputs:ri:lightFilter:tileMode = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Texture Mapping"
        displayName = "Tile Mode"
        doc = '''tileMode:
                "No Repeat"   - texture does not repeat.
                "Edge Extent" - extends the color of the edge to infinity.
                "Tile"        - texture repeats (tileable texture).
            '''
    )
    color3f inputs:ri:lightFilter:tint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Tint"
        doc = "tint: Tint of the resulting color after saturation, contrast and clamp."
    )
    int inputs:ri:lightFilter:useAlpha = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Use Alpha"
        doc = """
                useAlpha: This should always be on otherwise it will create hard edges
                from the cookie.  This parameter is hidden in case we need to
                expose it later.

                When on, if there is no alpha channel in the projected texture, it will
                use the installed $RMANTREEE/lib/textures/white.tex for blending
                with the fill color. Otherwise, it will use the alpha channel.
            """
        hidden = true
    )
    bool inputs:ri:lightFilter:useLightDirection = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Use Light Direction"
        doc = """
                useLightDirection: When this is on, the projection direction is determined by the
                position of the center of the light source. Otherwise, it only
                follows the orientation of the cookie.

                WARNING: This does not work with lights that have no direction such as
                PxrDomeLight and PxrMeshLight.
            """
    )
    float inputs:ri:lightFilter:whitepoint = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "White Point"
        doc = "whitepoint: White point for the contrast control if (contrast > 1.0)."
    )
    float inputs:ri:lightFilter:width = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Map"
        displayName = "Width"
        doc = "width: Width of the rect the light is shining through."
    )
    uniform token ri:lightFilter:shaderId = "PxrCookieLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrIntMultLightFilter "PxrIntMultLightFilter" (
    customData = {
        string className = "IntMultLightFilter"
    }
    inherits = </LightFilter>
)
{
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (technically: they are applied one after the other)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = """density: How much effect the filter has (0-1).
            """
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    float inputs:ri:lightFilter:exposure = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Exposure"
        doc = "exposure: Exposure control for the multiplier."
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = "intensity: Multiplier for the light intensity."
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = """
                invert: When this is on, invert the multiplier.  For instance, if we
                set the light filter's intensity to 2, the final light's intensity
                will be divided by (instead of multiplied by) the light filter's
                intensity.
            """
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Color Saturation"
        doc = """Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors).
            """
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    color3f inputs:ri:lightFilter:tint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Tint"
        doc = "Tint of the light color after saturation."
    )
    uniform token ri:lightFilter:shaderId = "PxrIntMultLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrRampLightFilter "PxrRampLightFilter" (
    customData = {
        string className = "RampLightFilter"
    }
    inherits = </LightFilter>
)
{
    float inputs:ri:lightFilter:beginDist = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Ramp Direction"
        displayName = "Begin Distance"
        doc = "beginDist: Distance where the ramp starts."
    )
    int inputs:ri:lightFilter:colorRamp = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Color Ramp"
        displayName = "Color Ramp"
        doc = "Color Ramp"
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (technically: they are applied one after the other)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = "density: How much effect the filter has (0-1)."
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    float inputs:ri:lightFilter:endDist = 10 (
        connectability = "interfaceOnly"
        displayGroup = "Ramp Direction"
        displayName = "End Distance"
        doc = "endDist: Distance where the ramp ends."
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = "intensity: Multiplier for both the diffuse and specular result."
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = "invert: If the multipliers should be inverted"
    )
    int inputs:ri:lightFilter:ramp = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Float Ramp"
        displayName = "Ramp"
        doc = "Ramp"
    )
    float[] inputs:ri:lightFilter:ramp_Floats = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Float Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Float Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:ramp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Float Ramp"
        hidden = true
    )
    int inputs:ri:lightFilter:rampType = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Ramp Direction"
        displayName = "Ramp Type"
        doc = "rampType: In which direction the ramp is applied."
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Saturation"
        doc = """saturation: Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors). From Begin to End Distance, the value will ramp between the original light color and the Saturation adjusted color (and opposite if the ramp is inverted)."""
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    uniform token ri:lightFilter:shaderId = "PxrRampLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrRodLightFilter "PxrRodLightFilter" (
    customData = {
        string className = "RodLightFilter"
    }
    inherits = </LightFilter>
)
{
    float inputs:ri:lightFilter:back = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Back"
        doc = "back: Additional size of the back region (-Z axis)."
    )
    float inputs:ri:lightFilter:backEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Back Edge"
        doc = """
                    backEdge: When edge is > 0, this scales the back edge up or down (-z axis).
                """
    )
    float inputs:ri:lightFilter:bottom = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Bottom"
        doc = "bottom: Additional size of the bottom region (-Y axis)."
    )
    float inputs:ri:lightFilter:bottomEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Bottom Edge"
        doc = """
                    bottomEdge: When edge is > 0, this scales the bottom edge up or down (-y axis).
                """
    )
    int inputs:ri:lightFilter:colorRamp = 4 (
        displayGroup = "Color Ramp"
        doc = """colorRamp: This is Optional.  This sets the color gradient
                  for the transition.
            """
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        displayName = "Combine Mode"
        doc = """
\t<p>
        combineMode: Light filters on a light are grouped by their combine mode. Light filters
        in the same group are executed together and combined by the corresponding
        operation:
        </p>
\t<ol>
\t\t<li>max: the maximum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>min: the minimum result from all filters is used.
              This works best for grey scale light filters.</li>
\t\t<li>screen: similar to the max operation, but it combines gradients
              in a smoother way. This works best for grey scale light filters.</li>
\t\t<li>mult (default): the results of all the filters are multiplied together
              (Technically, they are applied one after the other.)</li>
\t</ol>
\t<p>
        The groups are executed in the above order and are multiplied together,
        which means a filter that turns things black in the mult group will zero out
        all other filters.
        </p>
"""
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Density"
        doc = "density: How much effect the filter has (0-1)."
    )
    float inputs:ri:lightFilter:depth = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Depth"
        doc = "depth: Depth of the inner region of the rod (Z-axis)."
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Diffuse"
        doc = "diffuse: How much this light filter affects diffuse lighting."
    )
    float inputs:ri:lightFilter:edge = 0.25 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Edge Thickness"
        doc = "edge: Thickness of the edge region."
    )
    int inputs:ri:lightFilter:falloff = 6 (
        connectability = "interfaceOnly"
        displayGroup = "Falloff"
        doc = "falloff: Controls the transition from the core to the edge."
    )
    float[] inputs:ri:lightFilter:falloff_Floats = [0, 0, 0.2, 0.8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Falloff"
        hidden = true
    )
    token inputs:ri:lightFilter:falloff_Interpolation = "bspline" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Falloff"
        hidden = true
    )
    float[] inputs:ri:lightFilter:falloff_Knots = [0, 0, 0.3, 0.7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Falloff"
        hidden = true
    )
    float inputs:ri:lightFilter:front = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Front"
        doc = "front: Additional size of the frontal region (+Z axis)."
    )
    float inputs:ri:lightFilter:frontEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Front Edge"
        doc = """
                    frontEdge: When edge is > 0, this scales the frontal edge up or down (+z axis).
                """
    )
    float inputs:ri:lightFilter:height = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Height"
        doc = "height: Height of the inner region of the rod (Y-axis)."
    )
    float inputs:ri:lightFilter:intensity = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Intensity"
        doc = """intensity: Multiplier for both the diffuse and specular result.
            """
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Invert"
        doc = "invert: Inverts the entire effect of the filter."
    )
    float inputs:ri:lightFilter:left = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Left"
        doc = "left: Additional size of the left region (-X axis)."
    )
    float inputs:ri:lightFilter:leftEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Left Edge"
        doc = """
                   leftEdge: When edge is > 0, this scales the left edge up or down (-x axis).
                """
    )
    float inputs:ri:lightFilter:radius = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Radius"
        doc = "radius: Radius of the corners of the inner rod box."
    )
    float inputs:ri:lightFilter:right = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Right"
        doc = "right: Additional size of the right region (+X axis)."
    )
    float inputs:ri:lightFilter:rightEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Right Edge"
        doc = """
                    rightEdge: When edge is > 0, this scales the right edge up or down (+x axis).
                """
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Color Saturation"
        doc = """saturation: Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors)."""
    )
    float inputs:ri:lightFilter:scaleDepth = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale"
        displayName = "Scale Depth"
        doc = "scaleDepth: Scale the depth of the inner rod shape (Z axis)."
    )
    float inputs:ri:lightFilter:scaleHeight = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale"
        displayName = "Scale Height"
        doc = "scaleHeight: Scale the height of the inner rod shape (Y axis)."
    )
    float inputs:ri:lightFilter:scaleWidth = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale"
        displayName = "Scale Width"
        doc = "scaleWidth: Scale the width of the inner rod shape (X axis)."
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Multiplier"
        displayName = "Specular"
        doc = "specular: How much this light filter affects specular lighting."
    )
    float inputs:ri:lightFilter:top = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Top"
        doc = "top: Additional size of the top region (+Y axis)."
    )
    float inputs:ri:lightFilter:topEdge = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Top Edge"
        doc = """
                    topEdge: When edge is > 0, this scales the top edge up or down (+y axis).
                """
    )
    float inputs:ri:lightFilter:width = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Rod Shape"
        displayName = "Width"
        doc = "width: Width of the inner region of the rod (X-axis)."
    )
    uniform token ri:lightFilter:shaderId = "PxrRodLightFilter" (
        displayGroup = "Internal"
    )
}

class PxrCamera "PxrCamera" (
    customData = {
        string className = "Camera"
    }
    doc = """
    A camera model that approximates a number of real world physical
    effects.  This supports all of the traditional prman perspective camera
    settings including shaped motion blur and bokeh.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    float inputs:ri:assymX = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Assymetric Distortion X"
        doc = """
        Distortion applied only in the X direction.  Horizontal lines will
        remain straight.  Positive values produce pincushion-like
        distortion.  Negative values produce barrel-like distortion.
      """
        hidden = true
    )
    float inputs:ri:assymY = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Assymetric Distortion Y"
        doc = """
        Distortion applied only in the Y direction.  Vertical lines will
        remain straight.  Positive values produce pincushion-like
        distortion.  Negative values produce barrel-like distortion.
      """
        hidden = true
    )
    color3f inputs:ri:axial = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Chromatic Aberration"
        displayName = "Axial"
        doc = """
        Axial (or longitudinal) chromatic aberration.  This specifies the
        chromatic focal shift for the red, green, and blue primaries
        respectively.  When unequal, this can produce a tinge on bokeh and
        out of focus objects.  It will increase color noise, however.
      """
    )
    asset inputs:ri:cocTexture (
        displayGroup = "DOF Distortion"
        displayName = "Circle of Confusion Texture"
        doc = "If set, this overrides the lens's circle of confusion."
    )
    float inputs:ri:detail = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Detail Bias"
        doc = """
        Detail bias.  Positive values will shift all texture lookups
        towards coarser, lower resolution, MIP map levels than would
        normally be used.  Negative values will shift them towards finer,
        higher resolution, levels.  Also affects the level-of-detail
        selected for geometry.
      """
    )
    float2 inputs:ri:distortionCtr = (0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Distortion Center"
        doc = """
        Controls the center of the applied distortion. This is applied to
        the anchored screen window space coordinates, where anchored 
        screen window space is the natural space for comupting lens effects.
      """
    )
    float inputs:ri:dofMult = 1 (
        displayGroup = "DOF Distortion"
        displayName = "Depth of Field Multipler"
        doc = " Global multiplier on depth of field. "
    )
    float3 inputs:ri:dofPivotCenter = (0, 0, 0) (
        displayGroup = "DOF Distortion"
        displayName = "Pivot Center"
        doc = " Point (relative to focal plane and center-of-frame) where no dof distorion occurrs. "
    )
    float inputs:ri:dofRadiusFalloff = 1 (
        displayGroup = "DOF Distortion"
        displayName = "RadiusFalloff"
        doc = " Sharpness of depth of field radial effect. "
    )
    float inputs:ri:dofRadiusStrength = 0 (
        displayGroup = "DOF Distortion"
        displayName = "Radius Strength"
        doc = " Strength of depth of field radial effect. "
    )
    float inputs:ri:dofSqAnamorph = 1 (
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Anamorph"
        doc = ' Anamorphic aspect ratio of radial dof "squeeze" effect. '
    )
    float3 inputs:ri:dofSqCtr = (0, 0, 0) (
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Center"
        doc = " Point (relative to focal plane and center-of-frame) corresponding to the center of the DOF squeeze effect. "
    )
    float inputs:ri:dofSqFalloff = 1 (
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Falloff"
        doc = ' Radial strength falloff of the DOF "squeeze" effect. Larger numbers correspond to sharper falloff. Negative values are valid. '
    )
    float inputs:ri:dofSqStrength = 0 (
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Strength"
        doc = ' Strength of DOF "squeeze" effect. Positive values squeeze along the circumference; negative values squeeze along the radius. 0 is off.'
    )
    float inputs:ri:duration = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Shutter"
        displayName = "Duration"
        doc = """
        Exposure duration.  Zero means an ideal rolling shutter where each
        line is exposed instantaneously when read.  The default, one, is
        equivalent to a global shutter where all lines are exposed and read
        at the same time.
      """
    )
    float3 inputs:ri:enhance = (0, 0, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Enhancement"
        doc = """
        Enhancement.  Embiggens the region around a pixel (X,Y) by zoom
        factor Z for trouble-shooting.  The magnified pixel will remain
        anchored in place relative to the image.  Camera effects such as
        vignetting will be scaled accordingly.  Intentionally does not
        affect level-of-detail, dicing, displacement, or MIP map levels.
      """
    )
    bool inputs:ri:enhanceDiffAdjust = 0 (
        displayGroup = "Enhance"
        displayName = "Adjust differentials in enhance"
        doc = " Should enhance mode use the ray differentials of the un-enhanced image (unchecked), or adjust them to reflect the smaller size of each pixel in the enhanced image (checked)? The former shows the true contents of the un-enhanced pixels, the latter lets you resolve  "
    )
    bool inputs:ri:enhanceDisableDOF = 0 (
        displayGroup = "Enhance"
        displayName = "Disable DOF in enhance"
        doc = " Disable modification of ray origins in enhance mode. Renderman still thinks DOF is enabled, so focus factor will apply to geometry tessellation, but DOF-related blurring will not occur. This option and the one below enable you to get a fully accurate enhanced view of the geometry, without lens effects obscuring it. "
    )
    bool inputs:ri:enhanceDisableMoBlur = 0 (
        displayGroup = "Enhance"
        displayName = "Disable Motion Blur in enhance"
        doc = " Disable distribution of samples over time in enhance mode. Renderman still thinks motion blur is enabled, so motion factor will apply to geometry tessellation, but blurring due to motion blur will not occur. "
    )
    float inputs:ri:focalDistance = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Standard Perspective"
        displayName = "Focal Distance"
        doc = """
         Distance at which objects will be in focus.  This should be in
         units of distance along the view direction in camera coordinates.
         Effectively ignored if F-stop is huge.
      """
    )
    float inputs:ri:focalLength = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Standard Perspective"
        displayName = "Focal Length"
        doc = """
         Focal length of the camera lens.  Used to determine depth of
         field and defocus.  This should be in units of distance along the
         view direction in camera coordinates.  Effectively ignored if
         F-stop is huge.
      """
    )
    point3f inputs:ri:focus1 = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Focus 1"
        doc = """
        First point to keep in focus.  Specified in world space.  If all
        three focus points are set then the tilt angles and focal distance
        will be automatically solved to match the plane of focus they
        define.  Note that there may not be a solution.
      """
    )
    point3f inputs:ri:focus2 = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Focus 2"
        doc = """
        Second point to keep in focus.  Specified in world space.  If all
        three focus points are set then the tilt angles and focal distance
        will be automatically solved to match the plane of focus they
        define.  Note that there may not be a solution.
      """
    )
    point3f inputs:ri:focus3 = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Focus 3"
        doc = """
        Third point to keep in focus.  Specified in world space.  If all
        three focus points are set then the tilt angles and focal distance
        will be automatically solved to match the plane of focus they
        define.  Note that there may not be a solution.
      """
    )
    float inputs:ri:fov = 90 (
        connectability = "interfaceOnly"
        displayGroup = "Standard Perspective"
        displayName = "Field of View"
        doc = """
        Field of view (FOV) in degrees at the beginning of the frame.  For
        rectangular images this is normally the FOV along the narrower
        image dimension.
      """
    )
    float inputs:ri:fovEnd = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Standard Perspective"
        displayName = "Field of View (End)"
        doc = """
        Field of view (FOV) in degrees at the end of the frame.  Used to
        motion blur very fast zooms.  The default, zero, means to assume it
        is the same as at the beginning of the frame.
      """
    )
    float inputs:ri:fStop = 16 (
        connectability = "interfaceOnly"
        displayGroup = "Standard Perspective"
        displayName = "F-stop"
        doc = """
        F-stop or aperture number.  Used to determine depth of field and
        defocus.  This determines the lens diameter.  If the f-stop is a
        huge number, then effectively a pin-hole camera is used and depth
        of field is turned off.
      """
    )
    float inputs:ri:lensAsymmetryX = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Assymetric Distortion X"
        doc = """
        Distortion applied only in the X direction.  Horizontal lines will
        remain straight.  Positive values produce pincushion-like
        distortion.  Negative values produce barrel-like distortion.
      """
    )
    float inputs:ri:lensAsymmetryY = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Assymetric Distortion Y"
        doc = """
        Distortion applied only in the Y direction.  Vertical lines will
        remain straight.  Positive values produce pincushion-like
        distortion.  Negative values produce barrel-like distortion.
      """
    )
    float inputs:ri:lensScale = 1 (
        displayGroup = "Lens Distortion"
        displayName = "Lens Scale"
        doc = " Scale of lens distortion effect. "
    )
    int inputs:ri:lensType = 2 (
        displayName = "Lens Type"
        doc = " Lens model type. "
    )
    asset inputs:ri:matte = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Advanced"
        displayName = "Matte file"
        doc = """
        Matte file.  An EXR image that cuts away parts of the render.  If
        it is a deep image, it removes anything in the render that is
        farther away than opaque objects in the matte file, leaving behind
        transparent holes.  If it is a shallow image, it removes parts of
        the render where the matte file is opaque.
      """
    )
    float inputs:ri:natural = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Vignetting"
        displayName = "Natural"
        doc = """
        Natural vignetting.  When one, directions off of the primary camera
        axis will be darkened realistically.  Wide-angle perspectives will
        show this effect more strongly.  Setting to zero disables this and
        intermediate values will blend accordingly.
      """
    )
    int inputs:ri:numSplitDiopters = 0 (
        displayGroup = "Split Diopter"
        displayName = "Number of Split Diopters"
        doc = " Number of split diopters lens (minimum 0, maximum 2) being enabled. "
    )
    float inputs:ri:optical = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Vignetting"
        displayName = "Optical"
        doc = """
        Optical vignetting.  Simulates light blockage due to a hood or
        other additional lens elements.  With depth of field enabled, this
        creates cat's eye bokeh.  However, it also increases image noise.
      """
    )
    float inputs:ri:radial1 = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Radial Distortion 1"
        doc = """
        Quadratic radial lens distortion coefficient.  Positive values
        produce pincushion distortion.  Negative values produce barrel
        distortion.
      """
    )
    float inputs:ri:radial2 = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Radial Distortion 2"
        doc = """
        Quartic radial lens distortion coefficient.  Positive values
        produce pincushion distortion.  Negative values produce barrel
        distortion.
      """
    )
    float inputs:ri:roll = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Roll Angle"
        doc = """
        Roll the lens clockwise.  If the lens tilt is non-zero this can be
        used to rotate the plane of focus around the image center.  Ignored
        if focus points are set.
      """
    )
    float inputs:ri:shiftX = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Shift X"
        doc = """
        Shift the lens horizontally.  This can be used to correct for
        perspective distortion.  Positive values shift towards the right.
      """
    )
    float inputs:ri:shiftY = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Shift Y"
        doc = '''
        Shift the lens vertically.  This can be used to correct for
        perspective distortion "keystone" effects.  To keep vertical lines
        parallel, aim the camera horizontally and adjust this to include
        the subject.  Positive values shift towards the top.
      '''
    )
    float inputs:ri:splitDiopterAngle = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Angle"
        doc = " Angle of the split diopter line(s), CW from the up-axis. "
    )
    float inputs:ri:splitDiopterFocusDistance1 = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Focus Distance 1"
        doc = " Focal distance for the first split diopter region, in world space. "
    )
    float inputs:ri:splitDiopterFocusDistance2 = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Focus Distance 2"
        doc = " Focal distance for the second split diopter region, in world space. "
    )
    float inputs:ri:splitDiopterOffset1 = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Offset 1"
        doc = " Distance of the first split diopter line from the image center, perpendicular to the split diopter axis. Unit is such that distance from the image center to the left (or right) edge is 1. "
    )
    float inputs:ri:splitDiopterOffset2 = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Offset 2"
        doc = " Distance of the second split diopter line from the image center, perpendicular to the split diopter axis. Unit is such that distance from the image center to the left (or right) edge is 1. "
    )
    float inputs:ri:splitDiopterWidth1 = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Width 1"
        doc = " Width of the band between the center and first split diopter region, perpendicular to the split diopter axis, where the focal distance is smoothly interpolated. Unit is such that distance from the image center to the left (or right) edge is 1. "
    )
    float inputs:ri:splitDiopterWidth2 = 0 (
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Width 2"
        doc = " Width of the band between the center and second split diopter region, perpendicular to the split diopter axis, where the focal distance is smoothly interpolated. Unit is such that distance from the image center to the left (or right) edge is 1. "
    )
    float inputs:ri:squeeze = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Lens Distortion"
        displayName = "Anamorphic Squeeze"
        doc = """
        Anamorphic lens squeeze.  Values greater than one decrease the
        effect of the lens distortion in the X direction.  Values less than
        one increase it.
      """
    )
    token inputs:ri:sweep = "down" (
        allowedTokens = ["down", "right", "up", "left"]
        connectability = "interfaceOnly"
        displayGroup = "Shutter"
        displayName = "Sweep"
        doc = """
        Shutter direction.  Specifies the direction that the shutter
        sweeps.  The default, down, is the most common direction for
        rolling shutters.
      """
    )
    float inputs:ri:tilt = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Tilt-Shift"
        displayName = "Tilt Angle"
        doc = """
        Angle in degrees to tilt the lens.  Makes the plane of focus
        non-parallel to the image plane.  Has no effect unless depth of
        field is enabled.  Positive tilts up, bringing the focus in the top
        of the image closer and pushing the focus in the bottom further.
        Negative does the reverse.  Ignored if focus points are set.
      """
    )
    color3f inputs:ri:transverse = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Chromatic Aberration"
        displayName = "Transverse"
        doc = """
        Transverse (or lateral) chromatic aberration.  This specifies the
        magnification factors for the red, green, and blue primaries
        respectively.  When unequal, this can produce a tinge which is most
        pronounced near the image edges.  It will increase color noise,
        however.
      """
    )
    uniform token ri:projection:shaderId = "PxrCamera" (
        displayGroup = "Internal"
    )
}

class PxrCylinderCamera "PxrCylinderCamera" (
    customData = {
        string className = "CylinderCamera"
    }
    doc = """
    A simple camera model that projects through a section of a cylinder
    from the point at the cylinder's center.  For very wide aspect images,
    this may be useful for rendering a circular panorama.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    float inputs:ri:hsweep = 360 (
        connectability = "interfaceOnly"
        displayName = "Horizontal Sweep"
        doc = """
      The horizontal angle of the cylinder subtended by the image.  The
      default, 360, means that the image wraps all the way around and the
      left and right edges of the image align.
    """
    )
    float inputs:ri:vsweep = 90 (
        connectability = "interfaceOnly"
        displayName = "Vertical Sweep"
        doc = """
      The vertical field of view of the image.
    """
    )
    uniform token ri:projection:shaderId = "PxrCylinderCamera" (
        displayGroup = "Internal"
    )
}

class PxrLightProbe "PxrLightProbe" (
    customData = {
        string className = "LightProbe"
    }
    doc = """
    A simple camera model that renders an image as though photographing a
    perfectly specular mirrored ball.  Note that the view direction is
    flipped and the image mirrored compared to a real ball so that the
    orientation appears similar to other projections.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    uniform token ri:projection:shaderId = "PxrLightProbe" (
        displayGroup = "Internal"
    )
}

class PxrOrthographic "PxrOrthographic" (
    customData = {
        string className = "Orthographic"
    }
    doc = """
    A simple parallel projection camera.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    uniform token ri:projection:shaderId = "PxrOrthographic" (
        displayGroup = "Internal"
    )
}

class PxrPanini "PxrPanini" (
    customData = {
        string className = "Panini"
    }
    doc = """
    The Panini projection is designed for producing ultra-wide angle images
    with large fields of view.  It can be particularly effective for
    architectural scenes.  Like the traditional rectilinear perspective
    projection, vertical lines remain vertical when the view direction is
    horizontal, and radial lines that converge towards the vanishing point
    also remain straight.  However, it can do this while accommodating wide
    angles up to 180 degrees and beyond.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    float inputs:ri:compression = 1 (
        connectability = "interfaceOnly"
        displayName = "Compression"
        doc = """
      Determines the type of projection and the amount of compression at
      the peripheriphy.  At 0.0, this produces the equivalent of the
      traditional perspective projection and the FOV is limited to less
      than 180 degrees.  At 1.0, this produces the full Panini projection
      and allows the FOV to go up to almost 360 degrees.
    """
    )
    float inputs:ri:fov = 90 (
        connectability = "interfaceOnly"
        displayName = "Field of View"
        doc = """
      Field of view (FOV) in degrees.  For rectangular images this is
      normally the FOV along the wider image dimension.  Note that the
      actual FOV may be limited to somewhere between 180 and 360 depending
      on the Compression setting.
    """
    )
    uniform token ri:projection:shaderId = "PxrPanini" (
        displayGroup = "Internal"
    )
}

class PxrPerspective "PxrPerspective" (
    customData = {
        string className = "Perspective"
    }
    doc = """
    A simple pinhole camera.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    float inputs:ri:focalDistance = 1 (
        connectability = "interfaceOnly"
        displayName = "Focal Distance"
        doc = """
       Distance at which objects will be in focus.  This should be in
       units of distance along the view direction in camera coordinates.
       Effectively ignored if F-stop is huge.
    """
    )
    float inputs:ri:focalLength = 0 (
        connectability = "interfaceOnly"
        displayName = "Focal Length"
        doc = """
       Focal length of the camera lens.  Used to determine depth of
       field and defocus.  This should be in units of distance along the
       view direction in camera coordinates.  Effectively ignored if
       F-stop is huge.
    """
    )
    float inputs:ri:fov = 90 (
        connectability = "interfaceOnly"
        displayName = "Field of View"
        doc = """
      Field of view (FOV) in degrees.  For rectangular images this is
      normally the FOV along the narrower image dimension.
    """
    )
    float inputs:ri:fovEnd = 0 (
        connectability = "interfaceOnly"
        displayName = "Field of View (End)"
        doc = """
      Field of view (FOV) in degrees at the end of the frame.  Used to
      motion blur very fast zooms.  The default, zero, means to assume it
      is the same as at the beginning of the frame.
    """
    )
    float inputs:ri:fStop = 16 (
        connectability = "interfaceOnly"
        displayName = "F-stop"
        doc = """
      F-stop or aperture number.  Used to determine depth of field and
      defocus.  This determines the lens diameter.  If the f-stop is a
      huge number, then effectively a pin-hole camera is used and depth
      of field is turned off.
    """
    )
    uniform token ri:projection:shaderId = "PxrPerspective" (
        displayGroup = "Internal"
    )
}

class PxrSphereCamera "PxrSphereCamera" (
    customData = {
        string className = "SphereCamera"
    }
    doc = """
    A simple camera model that projects through a section of a sphere from
    the point at the sphere's center.  With its default settings, this may
    be useful for rendering a latlong environment map.
  """
    inherits = </PxrProjectionPluginBase>
)
{
    float inputs:ri:hsweep = 360 (
        connectability = "interfaceOnly"
        displayName = "Horizontal Sweep"
        doc = """
      The horizontal angle of the sphere subtended by the image.  The
      default, 360, means that the image wraps all the way around and the
      left and right edges of the image align.
    """
    )
    float inputs:ri:vsweep = 180 (
        connectability = "interfaceOnly"
        displayName = "Vertical Sweep"
        doc = """
      The vertical angle of the sphere subtended by the image.  The
      default, 180, means that the top and bottom of the image shows the
      through the sphere's poles directly above and below the camera.
    """
    )
    uniform token ri:projection:shaderId = "PxrSphereCamera" (
        displayGroup = "Internal"
    )
}

class OmnidirectionalStereo "OmnidirectionalStereo" (
    customData = {
        string className = "OmnidirectionalStereo"
    }
    doc = """
        This camera projection renders the scene as a stereo pair of 360 degree
        projections. It is intended to be rendered in a square format with
        the top half as the left eye and the bottom half as the right eye.

        Author: Mach Kobayashi
  """
    inherits = </PxrProjectionPluginBase>
)
{
    float inputs:ri:interpupilaryDistance = 0.0635 (
        connectability = "interfaceOnly"
        displayName = "Interpupilary Distance"
        doc = """
        The distance between the two eyes. The default, 0.0635, should work if
        your scene is measured in meters.
      """
    )
    uniform token ri:projection:shaderId = "OmnidirectionalStereo" (
        displayGroup = "Internal"
    )
}

class PxrBackgroundDisplayFilter "PxrBackgroundDisplayFilter" (
    customData = {
        string className = "BackgroundDisplayFilter"
    }
    doc = """
    Display filter plugin to color the background.
  """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    string inputs:ri:aovAlpha = "a" (
        connectability = "interfaceOnly"
        displayName = "Alpha"
        doc = "Name of AOV to get alpha values from."
    )
    color3f inputs:ri:backgroundColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Background Color"
        doc = """
        Color of the background.
    """
    )
    uniform token ri:displayFilter:shaderId = "PxrBackgroundDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrCopyAOVDisplayFilter "PxrCopyAOVDisplayFilter" (
    customData = {
        string className = "CopyAOVDisplayFilter"
    }
    doc = """
    Display filter plugin to look up a named AOV and copy it
    to Ci.
  """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:readAov = "" (
        connectability = "interfaceOnly"
        displayName = "Read AOV"
        doc = "Name of AOV to read from."
    )
    string inputs:ri:writeAov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "Write AOV"
        doc = "Name of AOV to write to."
    )
    uniform token ri:displayFilter:shaderId = "PxrCopyAOVDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrDisplayFilterCombiner "PxrDisplayFilterCombiner" (
    customData = {
        string className = "DisplayFilterCombiner"
    }
    doc = """
        Display filter combiner.
    """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    token inputs:ri:filter (
        displayName = "Display Filter"
        doc = """
            Display filters.
        """
    )
    uniform token ri:displayFilter:shaderId = "PxrDisplayFilterCombiner" (
        displayGroup = "Internal"
    )
}

class PxrEdgeDetect "PxrEdgeDetect" (
    customData = {
        string className = "EdgeDetect"
    }
    doc = """
    A small example display filter that demonstrates image processing.
    This filter replaces the image in the beauty pass (or any other AOV)
    with its gradient magnitude computed from a Sobel edge-detection
    filter.
  """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = """
      Name of a color AOV to do edge detection on.
    """
    )
    uniform token ri:displayFilter:shaderId = "PxrEdgeDetect" (
        displayGroup = "Internal"
    )
}

class PxrFilmicTonemapperDisplayFilter "PxrFilmicTonemapperDisplayFilter" (
    customData = {
        string className = "FilmicTonemapperDisplayFilter"
    }
    doc = """
        Display filter plugin based on Naughty Dog's Filmic Tonemapper from GDC Uncharted 2 HDR Lighting presentation.
    """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    float inputs:ri:A = 0.22 (
        connectability = "interfaceOnly"
        displayName = "Shoulder"
        doc = """
            Shoulder strength.
        """
    )
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    float inputs:ri:B = 0.3 (
        connectability = "interfaceOnly"
        displayName = "Linear"
        doc = """
            Linear strength.
        """
    )
    float inputs:ri:C = 0.1 (
        connectability = "interfaceOnly"
        displayName = "Linear Angle"
        doc = """
            Linear angle.
        """
    )
    float inputs:ri:D = 0.2 (
        connectability = "interfaceOnly"
        displayName = "Toe"
        doc = """
            Toe strength.
        """
    )
    float inputs:ri:E = 0.01 (
        connectability = "interfaceOnly"
        displayName = "Toe Numerator"
        doc = """
            Toe numerator.
        """
    )
    float inputs:ri:exposureAdjust = 1 (
        connectability = "interfaceOnly"
        displayName = "Exposure Adjustment"
        doc = """
            Exposure adjustment. This parameter is multiplied by the incoming
            pixel.
        """
    )
    float inputs:ri:F = 0.3 (
        connectability = "interfaceOnly"
        displayName = "Toe Denominator"
        doc = """
            Toe denominator.
        """
    )
    float inputs:ri:linearWhitePoint = 11.2 (
        connectability = "interfaceOnly"
        displayName = "White Point"
        doc = """
            Linear white point value.
        """
    )
    uniform token ri:displayFilter:shaderId = "PxrFilmicTonemapperDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrGradeDisplayFilter "PxrGradeDisplayFilter" (
    customData = {
        string className = "GradeDisplayFilter"
    }
    doc = """
        Nuke-like grade display filter. Allows simple grading of the beauty pass.
    """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    color3f inputs:ri:blackPoint = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Black Point"
        doc = """
            Ci is remapped so that this color becomes 0.
        """
    )
    bool inputs:ri:clampBlack = 1 (
        connectability = "interfaceOnly"
        displayName = "Clamp Black"
        doc = """
            Clamp Ci so that no value is less than 0. This is useful for compositing so that adding channels will not result in unexpected results.
        """
    )
    bool inputs:ri:clampWhite = 0 (
        connectability = "interfaceOnly"
        displayName = "Clamp White"
        doc = """
            Clamp Ci so that no value exceeds 1.
        """
    )
    color3f inputs:ri:gain = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Gain"
        doc = """
            Multiply Ci by this color.
        """
    )
    color3f inputs:ri:gamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Gamma"
        doc = """
            Gamma Ci by this color.
        """
    )
    color3f inputs:ri:lift = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Lift"
        doc = """
            Add this value to Ci.
        """
    )
    color3f inputs:ri:mask = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Mask"
        doc = """
            Mask the color correction result with this color.
        """
    )
    color3f inputs:ri:multiply = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Multiply"
        doc = """
            Multiply Ci by this color.
        """
    )
    color3f inputs:ri:offset = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Offset"
        doc = """
            Offset Ci (Ci + offset) by this color.
        """
    )
    color3f inputs:ri:whitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "White Point"
        doc = """
            Ci is remapped so that this color becomes 1.
        """
    )
    uniform token ri:displayFilter:shaderId = "PxrGradeDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrHalfBufferErrorFilter "PxrHalfBufferErrorFilter" (
    customData = {
        string className = "HalfBufferErrorFilter"
    }
    doc = """
    Estimate the error of an image by comparing two half buffers.  If two
    statistically-independent images are each produced from half the camera
    samples, then we can estimate the mean-squared-error between the ground
    truth and their average and as one-quarter of the squared difference of
    the two.  The AOVs may be either all scalar or all color.
  """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:aov1 = "even" (
        connectability = "interfaceOnly"
        displayName = "AOV 1"
        doc = """
      Name of the first half-buffer AOV to read from.
    """
    )
    string inputs:ri:aov2 = "odd" (
        connectability = "interfaceOnly"
        displayName = "AOV 2"
        doc = """
      Name of the second half-buffer AOV to read from.
    """
    )
    string inputs:ri:result = "mse" (
        connectability = "interfaceOnly"
        displayName = "Result"
        doc = """
      Name of the AOV to write the estimated error to.
    """
    )
    uniform token ri:displayFilter:shaderId = "PxrHalfBufferErrorFilter" (
        displayGroup = "Internal"
    )
}

class PxrImageDisplayFilter "PxrImageDisplayFilter" (
    customData = {
        string className = "ImageDisplayFilter"
    }
    doc = "Display filter plugin to render image planes including holdouts."
    inherits = </PxrDisplayFilterPluginBase>
)
{
    color3f inputs:ri:colorGain = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Color Gain"
        doc = "Color gain."
    )
    color3f inputs:ri:colorOffset = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Color Offset"
        doc = "Color offset."
    )
    asset inputs:ri:filename = @@ (
        connectability = "interfaceOnly"
        displayName = "Filename"
        doc = "The name of the plate image to display."
    )
    float inputs:ri:filmMaxX = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Right"
        doc = "Film window max X"
    )
    float inputs:ri:filmMaxY = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Top"
        doc = "Film window max Y"
    )
    float inputs:ri:filmMinX = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Left"
        doc = "Film window min X"
    )
    float inputs:ri:filmMinY = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Bottom"
        doc = "Film window min Y"
    )
    int inputs:ri:fit = 0 (
        connectability = "interfaceOnly"
        displayName = "Fit"
        doc = "Fit image to display."
    )
    string inputs:ri:holdoutShadowAov = "" (
        connectability = "interfaceOnly"
        displayName = "Holdout Shadow AOV"
        doc = "The name of the holdout shadow AOV to look up."
    )
    bool inputs:ri:linearize = 0 (
        connectability = "interfaceOnly"
        displayName = "Linearize"
        doc = "Linearize"
    )
    float inputs:ri:offsetX = 0 (
        connectability = "interfaceOnly"
        displayName = "Offset X"
        doc = "Offset in X."
    )
    float inputs:ri:offsetY = 0 (
        connectability = "interfaceOnly"
        displayName = "Offset Y"
        doc = "Offset in Y."
    )
    float inputs:ri:rotate = 0 (
        connectability = "interfaceOnly"
        displayName = "Rotate"
        doc = "Rotation."
    )
    float inputs:ri:scaleX = 1 (
        connectability = "interfaceOnly"
        displayName = "Scale X"
        doc = "Scale in X."
    )
    float inputs:ri:scaleY = 1 (
        connectability = "interfaceOnly"
        displayName = "Scale Y"
        doc = "Scale in Y."
    )
    uniform token ri:displayFilter:shaderId = "PxrImageDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrLightSaturation "PxrLightSaturation" (
    customData = {
        string className = "LightSaturation"
    }
    doc = """
    A small example display filter that changes the color saturation in the
    beauty pass (or any other AOV) according to whether a region is lit or
    shadowed by particular light group.
  """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = """
      Name of a color AOV to adjust saturation in.
    """
    )
    bool inputs:ri:invert = 0 (
        connectability = "interfaceOnly"
        displayName = "Invert?"
        doc = """
      If unset then areas lit by the light will be modified and areas fully
      in shadow will be left alone.  Set this to invert that and change the
      saturation of the shadows of this light.
    """
    )
    string inputs:ri:light = "" (
        connectability = "interfaceOnly"
        displayName = "Light AOV"
        doc = """
      Name of the color AOV with the contribution from the light group.
      The AOV should be populated using a direct-lighting LPE such as:
      <p>
        Display \"+satlighttiny\" \"null\" \"color lpe:C[DGS]<L.'tiny'>\"
      </p>
      in which case the value of this parameter would be \"satlighttiny\".
      This AOV shows direct illumination from any lights with parameter:
      <p>
        \"string __group\" \"tiny\"
      </p>
    """
    )
    float inputs:ri:shift = 1 (
        connectability = "interfaceOnly"
        displayName = "Shift"
        doc = """
      Amount and direction to shift saturation.  Positive values increase
      saturation, negative values desaturate.  Recommended range is -2.0 to
      2.0.
    """
    )
    float inputs:ri:threshold = 1 (
        connectability = "interfaceOnly"
        displayName = "Threshold"
        doc = """
      Luminance in the light AOV less than this is considered shadowed.
    """
    )
    uniform token ri:displayFilter:shaderId = "PxrLightSaturation" (
        displayGroup = "Internal"
    )
}

class PxrShadowDisplayFilter "PxrShadowDisplayFilter" (
    customData = {
        string className = "ShadowDisplayFilter"
    }
    doc = "Display filter plugin to calculate shadow AOV output from occluded and unoccluded AOV inputs."
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:occludedAov = "" (
        connectability = "interfaceOnly"
        displayName = "Occluded AOV"
        doc = "The name of the occluded AOV to look up."
    )
    string inputs:ri:shadowAov = "" (
        connectability = "interfaceOnly"
        displayName = "Shadow AOV"
        doc = "The name of the shadow AOV to write to."
    )
    float inputs:ri:shadowThreshold = 0.01 (
        connectability = "interfaceOnly"
        displayName = "Shadow Threshold"
        doc = "Reduce shadow noise by ignoring small differences illumination."
    )
    string inputs:ri:unoccludedAov = "" (
        connectability = "interfaceOnly"
        displayName = "Unoccluded AOV"
        doc = "The name of the unoccluded AOV to look up."
    )
    uniform token ri:displayFilter:shaderId = "PxrShadowDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrStylizedHatching "PxrStylizedHatching" (
    customData = {
        string className = "StylizedHatching"
    }
    doc = """
        Required AOVs: 
        P 
        Nn
        diffuse
        albedo
        directSpecular
        NPRalbedo
        NPRlineAlbedo
        NPRtextureCoords
        NPRPtriplanar
        NPRNtriplanar
  """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    bool inputs:ri:alpha_black_hatch_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "Alpha Hatch Switch"
        doc = """
        When using Light Mask, black areas of hatch are transparent to previously daisy-chained or physically based layers
    """
    )
    color3f inputs:ri:BGColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Compositing:Canvas"
        displayName = "Canvas Color"
        doc = """
      Background color outside of alpha
    """
    )
    asset inputs:ri:BGTex = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Compositing:Canvas"
        displayName = "Canvas Texture"
        doc = "Provide BG texture, if blank uses BG Color"
    )
    bool inputs:ri:blending_black = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Blending"
        displayName = "Last Texture is Black"
        doc = """
      After the darkest texture, tex8, add solid color black
    """
    )
    float inputs:ri:blending_hold = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Blending"
        displayName = "Hold"
        doc = """ Hold texture full value
    """
    )
    token inputs:ri:blending_mode = "mix" (
        allowedTokens = ["mix", "weighted"]
        connectability = "interfaceOnly"
        displayGroup = "Blending"
        displayName = "Blending Mode"
        doc = "<help />"
    )
    float inputs:ri:blending_overlap = 0.125 (
        connectability = "interfaceOnly"
        displayGroup = "Blending"
        displayName = "Overlap"
        doc = """ Overlap of the Bell Curve weighting function. 0.125 is minimum and blends 2 textures, higher values blend more up to 8 textures.
"""
    )
    bool inputs:ri:blending_test_colors_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Blending"
        displayName = "Color Blend Signal"
        doc = """
      Replace tex1-tex8 with RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET, TORQOISE for previewing blending
    """
    )
    bool inputs:ri:blending_white = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Blending"
        displayName = "First Texture is White"
        doc = """
          After the lightest texture, tex1, add solid color white
        """
    )
    bool inputs:ri:camera_range_mask_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Camera Range Mask Switch"
        doc = """
        Mask out regular hatching (When Visualizer on Hatching On Color, Hatching Final) by Camera Range defined by Z_min and Z_max below
    """
    )
    bool inputs:ri:flip_min_max = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Flip Min Max"
        doc = """
        Flip Cam Dist Z Min Max
    """
    )
    bool inputs:ri:flip_tex = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Flip"
        doc = "Flip"
    )
    float inputs:ri:Hatch_Gamma = 0.5 (
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Gamma"
        doc = """
        Gamma (Contrast)
    """
    )
    token inputs:ri:Hatch_On = "color" (
        allowedTokens = ["color", "bg", "multiply", "screen"]
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Mode"
        doc = """ Hatch on Color or previous layer (BG)
    """
    )
    color3f inputs:ri:hatchColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Color"
        displayName = "Color"
        doc = """
      Hatching color
    """
    )
    token inputs:ri:hatchColorFrom = "colorSwatch" (
        allowedTokens = ["colorSwatch", "NPRalbedoAOV", "albedoAOV", "NPRlineAlbedoAOV", "texture"]
        connectability = "interfaceOnly"
        displayGroup = "Color"
        displayName = "Color From"
        doc = """Select which AOV to determine the coloring of the hatching
    """
    )
    token inputs:ri:hatching_aov_channel = "green" (
        allowedTokens = ["red", "green", "blue"]
        connectability = "interfaceOnly"
        displayGroup = "Output"
        displayName = "Channel"
        doc = """Which channel to write grayscale hatching output to
    """
    )
    string inputs:ri:hatching_aov_string = "NPRhatchOut" (
        connectability = "interfaceOnly"
        displayGroup = "Output"
        displayName = "AOV"
        doc = """
      Name of a color AOV to use for this specific Hatching node. Default goes to GREEN channel of NPRhatchOut, use this for additional AOV support for use in compositing.
    """
    )
    float inputs:ri:hatching_freq = 0.2 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Frequency"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    token inputs:ri:hatching_freq_mode = "8Values" (
        allowedTokens = ["1Value", "8Values", "camdistRange", "lightSignalRange"]
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Mode"
        doc = "<help />"
    )
    float inputs:ri:hatching_freq_tex1 = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 1"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex2 = 2 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 2"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex3 = 2.5 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 3"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex4 = 3 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 4"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex5 = 3.5 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 5"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex6 = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 6"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex7 = 4.5 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 7"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    float inputs:ri:hatching_freq_tex8 = 5 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 8"
        doc = """Higher numbers, higher frequency. For screen start at 1. For triplanar start at 0.005.
    """
    )
    bool inputs:ri:hatchingMask_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "PxrStylizedControl Mask"
        doc = """Mult by hatching mask from PxrStylizedControl node in AOV NPRlineMask GREEN channel
  """
    )
    asset inputs:ri:hatchingTex1 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 1"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex2 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 2"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex3 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 3"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex4 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 4"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex5 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 5"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex6 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 6"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex7 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 7"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTex8 = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatching Texture 8"
        doc = "Provide COLOR texture"
    )
    asset inputs:ri:hatchingTexSetCustom = @@ (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Texture Set"
        doc = """Provide Texture Set Directory
        A texture set is the name of a directory of pre-organized textures.
        We don't actually go searching the texture path for the files to validate, we
        just rely on the naming convention for the eight filenames when they are a set.

        For set named \"myset\" we assume that there is a directory on the
        texture path named \"myset\" containing myset-01.tex, myset-02.tex, etc.
        
        Stock texture sets are like
        [rmantree/lib/textures/]StylizedLooks/pxrStylized-woven/pxrStylized-woven-01.tex
    """
    )
    token inputs:ri:hatchingTexSetStock = "StylizedLooks/pxrStylized-woven" (
        allowedTokens = ["StylizedLooks/pxrStylized-aquatint", "StylizedLooks/pxrStylized-charcoal", "StylizedLooks/pxrStylized-crosshatch", "StylizedLooks/pxrStylized-curl", "StylizedLooks/pxrStylized-halftone", "StylizedLooks/pxrStylized-patches", "StylizedLooks/pxrStylized-random", "StylizedLooks/pxrStylized-scumble", "StylizedLooks/pxrStylized-splatter", "StylizedLooks/pxrStylized-stipple", "StylizedLooks/pxrStylized-wash", "StylizedLooks/pxrStylized-woven"]
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Texture Set"
        doc = """
    Select a hatching texture set from the built-in predefined collection.
    """
    )
    token inputs:ri:hatchingTexType = "texSetStock" (
        allowedTokens = ["texSetStock", "texSetCustom", "texIndividualFiles"]
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Type"
        doc = """
    Select the source for hatching textures.
    """
    )
    color3f inputs:ri:HatchOnColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Hatch On Color"
        doc = """
      Ignore albedo color for base color, use this color on all objects
    """
    )
    bool inputs:ri:hatchTex_invert_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Invert"
        doc = """
          Invert order of progression of hatch texture lookups. For diffuse signals, typically left OFF (default)
      """
    )
    float inputs:ri:hatchTexClr_mix = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Hatch Tex Color Mix"
        doc = "<help />"
    )
    bool inputs:ri:Invert_Signal = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Invert Signal"
        doc = """
        Invert Signal Energy
    """
    )
    bool inputs:ri:light_mask_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "Input Mask"
        doc = """
        Use light aov defined in signal_aov_string above as mask for previously daisy-chained Stylized shaders and/or physically based lighting
    """
    )
    float inputs:ri:Light_max_freq = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Light Max Hatch Frequency"
        doc = "<help />"
    )
    float inputs:ri:Light_min_freq = 5 (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Light Min Hatch Frequency"
        doc = "<help />"
    )
    float inputs:ri:NPR_mix = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Mix"
        doc = """0: disables this Hatching Node and shows previous node if daisy chained, or original beauty if no previous Stylized Looks nodes. 1: full Hatching from this node.
  """
    )
    bool inputs:ri:progressive_tex_switch = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Progressive"
        doc = """
    Composites textures on top of each other if not originally created that way (each texture progressively is added to the previous one). 
    <br />
\t<br />
    Useful when using 8-val frequency mode.
  """
    )
    token inputs:ri:projection = "screen" (
        allowedTokens = ["screen", "triplanar", "NPRtextureCoordsAOV"]
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Projection"
        doc = "<help />"
    )
    int inputs:ri:ramp = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Input Remap"
        displayName = "Ramp"
        doc = "Ramp"
    )
    float[] inputs:ri:ramp_Floats = [0, 0, 1, 1] (
        displayGroup = "Input:Input Remap"
        hidden = true
    )
    token inputs:ri:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Input:Input Remap"
        hidden = true
    )
    float[] inputs:ri:ramp_Knots = [0, 0, 1, 1] (
        displayGroup = "Input:Input Remap"
        hidden = true
    )
    bool inputs:ri:remapSplineSwitch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Input Remap"
        displayName = "Enable Ramp"
        doc = "Enable Ramp"
    )
    token inputs:ri:signal = "diffuse" (
        allowedTokens = ["beauty", "diffuse", "directSpecular", "cameraRange", "aov"]
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Signal"
        doc = """
        Choose the input signal to run the hatching algorithm on. Typically light signals like diffuse, directSpecular. 
        Camera Range - uses camera min and max depth set in paremeters below instead.
        Custom AOV - type in color AOV in Signal String below.
    """
    )
    string inputs:ri:signal_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Signal String"
        doc = """
      Name of a color AOV to use for the signal to hatching. Typically diffuse, can put any light AOV here. This AOV has to be setup in Maya/Katana/Houdini or DisplayFilter will exit.
    """
    )
    float inputs:ri:Signal_Pre_Gain = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Input Remap"
        displayName = "Gain"
        doc = """ Gain on incoming signal
    """
    )
    float inputs:ri:Signal_Pre_Gamma = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Input Remap"
        displayName = "Gamma"
        doc = """ Gamma on incoming signal
    """
    )
    bool inputs:ri:Toon_Colors_Switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Textures"
        displayName = "Toon Mode"
        doc = "Toon Mode"
    )
    float inputs:ri:triplanar_blending = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Triplanar Blending"
        doc = """0 - no blending, 1 - full blending
    """
    )
    token inputs:ri:triplanar_N = "NPRNtriplanar" (
        allowedTokens = ["NPRNtriplanar", "Nn", "__Nref", "aov"]
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Triplanar N"
        doc = """
      NPRNtriplanar - set with PxrStylizedControl
      N - factory RenderMan N, make sure AOV exists in render
      __Nref - normal rest position, must be set (Maya: Texture Reference Object) and AOV exists in render
      string - custom string to use any N AOV that exists in render
    """
    )
    string inputs:ri:triplanar_N_aov_string = "NPRNtriplanar" (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Triplanar N String"
        doc = '''
      Name of a color AOV to use for the triplanar blending of N. If set to "NPRNtriplanar": need to plug PxrManifold3d into PxrStylizedControl node to provide custom co-ordinate system. Can also be factory "N" "__Nref" if those AOVs are setup.
    '''
    )
    token inputs:ri:triplanar_P = "NPRPtriplanar" (
        allowedTokens = ["NPRPtriplanar", "P", "__Pref", "aov"]
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Triplanar P"
        doc = '''
      NPRPtriplanar - set with PxrStylizedControl to be P in "object" space
      P - factory RenderMan P, make sure AOV exists in render
      __Pref - rest position, must be set (Maya: Texture Reference Object) and AOV exists in render
      string - custom string to use any P AOV that exists in render
    '''
    )
    string inputs:ri:triplanar_P_aov_string = "NPRPtriplanar" (
        connectability = "interfaceOnly"
        displayGroup = "Projection"
        displayName = "Triplanar P String"
        doc = '''
      Name of a color AOV to use for the triplanar blending of P. If set to "NPRPtriplanar": need to plug PxrManifold3d into PxrStylizedControl node to provide custom co-ordinate system. Can also be factory "P" "__Pref" "Pworld" if those AOVs are setup.
    '''
    )
    token inputs:ri:visualizer = "hatchingFinal" (
        allowedTokens = ["beauty", "hatchingFinal", "separator", "hatchingBlend", "diffuseLuminance", "diffuseEnergy", "triplanarTestColors"]
        connectability = "interfaceOnly"
        displayName = "Result"
        doc = "<help />"
    )
    token inputs:ri:whiteShader = "signalAovAverage" (
        allowedTokens = ["signalAovMono", "signalAovAverage", "albedoAOV", "NPRalbedoAOV"]
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Mode"
        doc = """ Under the hood a white shader approximation is created based off the Signal AOV to drive the Hatching. By default using average of RGB components of Signal AOV, but can also divide Signal AOV lighting results with a pure albedo from NPRalbedo AOV or albedo AOV. If NPRalbedo AOV chosen, must set Albedo Color in Stylized Controller Pattern node.
    """
    )
    token inputs:ri:z_depth_mode = "lineNZAOV" (
        allowedTokens = ["lineNZAOV", "PAOV"]
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Z Depth Mode"
        doc = """ Slightly different Z depth data from these 2 sources
      """
    )
    float inputs:ri:Z_max = 200 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Cam Dist Z Max"
        doc = """ Linstep Max on Z (blue channel from lineNZ)
    """
    )
    float inputs:ri:Z_max_freq = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Z Max Hatch Frequency"
        doc = "<help />"
    )
    float inputs:ri:Z_min = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Cam Dist Z Min"
        doc = """ Linstep Min on Z (blue channel from lineNZ)
    """
    )
    float inputs:ri:Z_min_freq = 5 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Camera Range"
        displayName = "Z Min Hatch Frequency"
        doc = "<help />"
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedHatching" (
        displayGroup = "Internal"
    )
}

class PxrStylizedLines "PxrStylizedLines" (
    customData = {
        string className = "StylizedLines"
    }
    doc = """
        Required AOVs:

         1) NPRoutline
         2) NPRsections
         3) NPRlineNZ
         4) NPRlineCamdist
         5) NPRalbedo
         6) NPRlineAlbedo
         7) NPRmask
         8) NPRlineWidth
         9) diffuse
        10) albedo
        11) NPRlineOut
        12) NPRlineOutAlpha
        13) sampleCount
        14) NPRcurvature
        15) NPRdistort
"""
    inherits = </PxrDisplayFilterPluginBase>
)
{
    token inputs:ri:activation_function = "spline" (
        allowedTokens = ["spline", "sigmoid"]
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Activation"
        doc = """ During line detection weighting to get variance
    """
    )
    string inputs:ri:aov = "NPRsections" (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Data AOV"
        doc = """
      Name of a color AOV to do line detection on. Manually set if you want to test on your AOV.
    """
    )
    bool inputs:ri:camdist_linstep_switch = 0 (
        connectability = "interfaceOnly"
        displayName = "Linstep Switch"
        doc = """ 
        Use linstep Min Max values below on Z (blue channel from lineNZ)
      """
    )
    float inputs:ri:camdist_Zmax = 100 (
        connectability = "interfaceOnly"
        displayName = "Cam Dist Z Max"
        doc = """ Linstep Max on Z (blue channel from lineNZ)
    """
    )
    float inputs:ri:camdist_Zmin = 1 (
        connectability = "interfaceOnly"
        displayName = "Cam Dist Z Min"
        doc = """ Linstep Min on Z (blue channel from lineNZ)
    """
    )
    float inputs:ri:camdist_zscale = 0.04 (
        connectability = "interfaceOnly"
        displayName = "Z Scale"
        doc = """ Scale Z (from lineNZ blue channel) for line detect
    """
    )
    bool inputs:ri:camdist_zscale_switch = 0 (
        connectability = "interfaceOnly"
        displayName = "Z Scale Switch"
        doc = """ Use Z Scale
      """
    )
    float inputs:ri:compModeMix = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Mix"
        doc = """
    Mix this node to previous result
  """
    )
    token inputs:ri:daisy_chain_comp = "over" (
        allowedTokens = ["over", "plus", "multiply", "screen"]
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Mode"
        doc = """ Comp mode over previous result (if have previous daisy-chained Stylized nodes, or beauty)
    """
    )
    bool inputs:ri:Dilate_Sort_Alpha_Switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Dilation Sorting"
        displayName = "Use Alpha"
        doc = """ If object has alpha, the zero alpha on camera depth will be incorrect, switch to ON to mix between camera depth of object and Dilate_Sort_Max_Depth based on alpha
      """
    )
    float inputs:ri:Dilate_Sort_Depth_Scale = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Dilation Sorting"
        displayName = "Depth Scale"
        doc = """
      Scale Z depth for sorting based on scene scale
    """
    )
    float inputs:ri:Dilate_Sort_Max_Depth = 1000 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Dilation Sorting"
        displayName = "Dilate Sort Max Depth"
        doc = """
      Max Depth to consider for outside of alpha
    """
    )
    float inputs:ri:Dilate_Sort_Radius = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Dilation Sorting"
        displayName = "Radius"
        doc = """
      How big of a radius to dilate Z-sorted signal. Larger values = longer render time. MAX size of 6: will clamp if over.
    """
    )
    bool inputs:ri:Dilate_Sort_Switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input:Dilation Sorting"
        displayName = "Enable"
        doc = """ If using signals to drive line thickness/color, need to dilate and sort by z depth to pickup correct signal since line detection goes half off geo.
      """
    )
    token inputs:ri:Dilate_Sort_Weight_Type = "Bell Curve" (
        allowedTokens = ["Bell Curve", "Hermite", "Clamp"]
        connectability = "interfaceOnly"
        displayGroup = "Input:Dilation Sorting"
        displayName = "Weight"
        doc = """ During dilate sort, weighting
      """
    )
    bool inputs:ri:Distort_Negative_Remap = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Distort"
        displayName = "Remap"
        doc = """Assumes incoming signal to Distort UV is [0..1], remaps to [-1..1]
  """
    )
    bool inputs:ri:Distort_Switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Distort"
        displayName = "Enable"
        doc = """Distort lines using Distort U V fractal plugged into PxrStylizedControl
  """
    )
    float inputs:ri:Distort_UV_Scale = 15 (
        connectability = "interfaceOnly"
        displayGroup = "Line Distort"
        displayName = "Offset"
        doc = """
  Scale UV Offsets from NPRdistort AOV
"""
    )
    vector3f inputs:ri:HSV_Dark = (0, 1, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Line Color"
        displayName = "HSV Dark"
        doc = """
          HSV
      """
    )
    vector3f inputs:ri:HSV_Light = (0, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Line Color"
        displayName = "HSV Light"
        doc = """
          HSV
      """
    )
    bool inputs:ri:light_mask_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "Input Mask"
        doc = """
        Use AOV defined in Input Signal as mask for previously daisy-chained Stylized shaders and/or physically based lighting
    """
    )
    float inputs:ri:Light_max_thickness = 5 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "High Mult"
        doc = """ Scale (multiply) Line Thickness by this value in light areas. Use Line Thickness From Lighting in Visualizer dropdown to preview signal.
    """
    )
    bool inputs:ri:Light_min_max_thickness_invert = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Invert"
        doc = """ Invert min max above: so thicker in shadows
      """
    )
    float inputs:ri:Light_min_thickness = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Low Mult"
        doc = """ Scale (multiply) Line Thickness by this value in shadows. Use Line Thickness From Lighting in Visualizer dropdown to preview signal.
    """
    )
    token inputs:ri:light_response = "none" (
        allowedTokens = ["none", "HSVLightDark", "lineColorShadow"]
        connectability = "interfaceOnly"
        displayGroup = "Line Color"
        displayName = "Light Tint"
        doc = """ Color lines by lighting
    """
    )
    float inputs:ri:Light_thickness_gamma = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Gamma"
        doc = "<help />"
    )
    float inputs:ri:line_thickness_scale = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "PxrStylizedControl Scale"
        doc = """
      Globally scale line thickness. If you have line thickness set per object and they are all different values, and you up the resolution of the render, use this global scale to increase or decrease line thickness of all lines, since they are based on pixel width.
    """
    )
    color3f inputs:ri:lineColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayGroup = "Line Color"
        displayName = "Line Color"
        doc = """
      Lines color
    """
    )
    token inputs:ri:lineColorFrom = "colorSwatch" (
        allowedTokens = ["colorSwatch", "patternShader", "NPRalbedoAOV", "albedoAOV"]
        connectability = "interfaceOnly"
        displayGroup = "Line Color"
        displayName = "From"
        doc = "<help />"
    )
    color3f inputs:ri:lineColorShadow = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        displayGroup = "Line Color"
        displayName = "Line Color Shadow"
        doc = """
      Line color in dark/shadow areas
    """
    )
    bool inputs:ri:lineMask_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "PxrStylizedControl Mask"
        doc = """ Mult by line mask from PxrStylizedControl pattern node in AOV NPRmask
  """
    )
    float inputs:ri:linesGamma = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Compositing"
        displayName = "Gamma"
        doc = """
    After line detection happens, runs gamma on final lines.
  """
    )
    bool inputs:ri:linesInside_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "Lines Inside Alpha"
        doc = """ Mult by alpha for only inside lines from line detect, don't go off geo. Premult.
  """
    )
    float inputs:ri:lineThickness = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness"
        displayName = "Thickness"
        doc = """
        Master Line Thickness, based on pixels
    """
    )
    token inputs:ri:lineType = "sections" (
        allowedTokens = ["outline", "sections", "lineNZ", "curvature", "camdist", "aov"]
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Type"
        doc = """
      outline - line on alpha of object
      sections - line on random id
      lineNZ - line on combination of X Y components of surface normal and Z depth, good for unit scale
      curvature - line on change in surface normal
      camdist - line on change in camera distance
      aov - custom AOV defined below
    """
    )
    bool inputs:ri:overwriteDataAOV = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Write To Type AOV"
        doc = """
        OFF: edge detection results go into NPRlineOutAlpha and NPRlineOut. ON: overwrite original signal, example writes back to NPRlineNZ/NPRsections/etc
    """
    )
    int inputs:ri:ramp = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection:Activation Spline"
        displayName = "Ramp"
        doc = "Ramp"
    )
    float[] inputs:ri:ramp_Floats = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Line Detection:Activation Spline"
        hidden = true
    )
    token inputs:ri:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Line Detection:Activation Spline"
        hidden = true
    )
    float[] inputs:ri:ramp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Line Detection:Activation Spline"
        hidden = true
    )
    string inputs:ri:shaderNotes = "Lines Stylization Display Filter" (
        connectability = "interfaceOnly"
        displayGroup = "Notes"
        displayName = "Note"
        doc = """
        Required AOVs:

         1) NPRoutline
         2) NPRsections
         3) NPRlineNZ
         4) NPRlineCamdist
         5) NPRalbedo
         6) NPRlineAlbedo
         7) NPRmask
         8) NPRlineWidth
         9) diffuse
        10) albedo
        11) NPRlineOut
        12) NPRlineOutAlpha
        13) sampleCount
        14) NPRcurvature
        15) NPRdistort
    """
    )
    float inputs:ri:sigmoid_activation_offset = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Sigmoid Offset"
        doc = """ See: https://www.desmos.com/calculator/1agy4wsmrh and modify offset variable o
    """
    )
    float inputs:ri:sigmoid_activation_sharpness = 25 (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Sigmoid Sharpness"
        doc = """ See: https://www.desmos.com/calculator/1agy4wsmrh and modify sharpness variable a
    """
    )
    float inputs:ri:sigmoid_offset = 0.3 (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Sigmoid Offset"
        doc = """ Offset from the midpoint for each sigmoid. Used for line thickness, the bigger the offset the thicker the weighting. See: https://www.desmos.com/calculator/g4jbxcvtqz and modify variable o
    """
    )
    float inputs:ri:sigmoid_sharpness = 17 (
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Sigmoid Sharpness"
        doc = """ Sharpness of the sigmoid pair. Used for softening/hardening the line edge. See: https://www.desmos.com/calculator/g4jbxcvtqz and modify variable a
    """
    )
    token inputs:ri:signal = "diffuse" (
        allowedTokens = ["beauty", "diffuse", "directSpecular", "aov"]
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Signal"
        doc = """
        Choose the input signal to use for the light signal to line color and line thickness by lighting. Typically diffuse, can put any light AOV here.
        Camera Range - uses camera min and max depth set in paremeters below instead.
        Custom AOV - type in color AOV in Signal String below.
    """
    )
    string inputs:ri:signal_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Signal String"
        doc = """
      Name of a color AOV to use for the light signal to line color and line thickness by lighting. Typically diffuse, can put any light AOV here. This AOV has to be setup in Maya/Katana/Houdini or DisplayFilter will exit.
    """
    )
    bool inputs:ri:thickness_from_lighting_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "by Lighting"
        doc = """
            Hot tips here!
        """
    )
    bool inputs:ri:thickness_from_pattern_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "by PxrStylizedControl"
        doc = """
            Multiply Line Thickness by set here by Line Thickness set on PxrStylizedControl per object
        """
    )
    bool inputs:ri:thickness_from_zdepth_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "by Z Depth"
        doc = """
            Hot tips here!
        """
    )
    token inputs:ri:visualizer = "finalLinesBeauty" (
        allowedTokens = ["beauty", "finalLinesBeauty", "separator", "finalLines", "finalLinesInvert", "finalLinesAlpha", "lineThicknessFromPattern", "lineThicknessFromLighting", "Luminance", "diffuseEnergy", "zCamdist"]
        connectability = "interfaceOnly"
        displayName = "Result"
        doc = "<help />"
    )
    token inputs:ri:weight_type = "bellCurve" (
        allowedTokens = ["bellCurve", "hermite", "doubleSigmoid"]
        connectability = "interfaceOnly"
        displayGroup = "Line Detection"
        displayName = "Weight"
        doc = """ During line detection weighting to get variance
    """
    )
    token inputs:ri:whiteShader = "signalAovAverage" (
        allowedTokens = ["signalAovAverage", "albedoAOV", "NPRalbedoAOV"]
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Mode"
        doc = """ 
        Under the hood a white shader approximation is created based off the Signal AOV to drive the Hatching. By default using average of RGB components of Signal AOV, but can also divide Signal AOV lighting results with a pure albedo from NPRalbedo AOV or albedo AOV. If NPRalbedo AOV chosen, must set Albedo Color in PxrStylizedControl node.
    """
    )
    float inputs:ri:Zmax = 200 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Cam Dist Z Max"
        doc = """ Linstep Max on Z (blue channel from lineNZ)
    """
    )
    float inputs:ri:Zmax_thickness = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Z Max Thickness Scale"
        doc = "<help />"
    )
    float inputs:ri:Zmin = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Cam Dist Z Min"
        doc = """ Linstep Min on Z (blue channel from lineNZ)
    """
    )
    float inputs:ri:Zmin_thickness = 5 (
        connectability = "interfaceOnly"
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Z Min Thickness Scale"
        doc = "<help />"
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedLines" (
        displayGroup = "Internal"
    )
}

class PxrStylizedToon "PxrStylizedToon" (
    customData = {
        string className = "StylizedToon"
    }
    doc = """
        Required AOVs: diffuse albedo directSpecular NPRtoonOut NPRalbedo
    """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    float inputs:ri:albedoLift = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Toon Blending"
        displayName = "Albedo Lift"
        doc = """
            When Step Mode = Albedo or Light to Albedo, lift albedo values
        """
    )
    color3f inputs:ri:backgroundColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Toon"
        displayName = "BG Color"
        doc = """
      BG Color
  """
    )
    int inputs:ri:colorRamp = 4 (
        displayName = "Color Spline Ramp"
        doc = "Color Spline Ramp"
    )
    color3f[] inputs:ri:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        hidden = true
    )
    token inputs:ri:colorRamp_Interpolation = "catmull-rom" (
        allowedTokens = ["catmull-rom", "linear", "constant"]
        hidden = true
    )
    float[] inputs:ri:colorRamp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        hidden = true
    )
    color3f inputs:ri:darks = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Toon Blending"
        displayName = "Darks Color"
        doc = """
          Color to step to
      """
    )
    int inputs:ri:light_mask_switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "Input Mask"
        doc = """
        Use light aov defined in signal_aov_string above as mask for previously daisy-chained Stylized shaders and/or physically based lighting.
    """
    )
    int inputs:ri:ramp = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Input Remap"
        displayName = "Float Spline Ramp"
        doc = "Float Spline Ramp"
    )
    float[] inputs:ri:ramp_Floats = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Input Remap"
        hidden = true
    )
    token inputs:ri:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Input Remap"
        hidden = true
    )
    float[] inputs:ri:ramp_Knots = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] (
        displayGroup = "Input Remap"
        hidden = true
    )
    token inputs:ri:Signal = "diffuse" (
        allowedTokens = ["diffuse", "occlusionIntegrator", "beauty", "aov"]
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Signal"
        doc = ''' Signal to use for Toon Stepping
        When Occlusion Integrator chosen - switch to PxrOcclusion in RenderMan Integrator
        Custom AOV - name of a color AOV to use for the signal to toon shading. Typically "diffuse", can put any light AOV here. This AOV has to be setup in Maya/Katana/Houdini or DisplayFilter will exit.
    '''
    )
    string inputs:ri:signal_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Custom AOV"
        doc = """
      Name of a color AOV to use for the signal to toon shading. Typically diffuse, can put any light AOV here. This AOV has to be setup in Maya/Katana/Houdini or DisplayFilter will exit.
    """
    )
    float inputs:ri:Signal_Energy_Threshold_Max = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Threshold Max"
        doc = """ 1 is off, values smaller than one remap the difference between Signal Energy and Albedo Color to be darker
    """
    )
    float inputs:ri:Signal_Energy_Threshold_Min = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Threshold Min"
        doc = """ 0 is off, values greater than 0 ignore small differences between Signal Energy and Albedo Color
    """
    )
    float inputs:ri:Signal_Pre_Gain = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input Remap"
        displayName = "Gain"
        doc = """ Gain on incoming signal
        """
    )
    float inputs:ri:Signal_Pre_Gamma = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Input Remap"
        displayName = "Gamma"
        doc = """ Gamma on incoming signal
        """
    )
    int inputs:ri:Spline_Ramp_Switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Input Remap"
        displayName = "Spline Ramp Switch"
        doc = "Spline Ramp Switch"
    )
    token inputs:ri:stepMode = "darks" (
        allowedTokens = ["colorSplineRamp", "albedo", "lightToAlbedo", "darks"]
        connectability = "interfaceOnly"
        displayGroup = "Toon Blending"
        displayName = "Mode"
        doc = """Albedo: steps to object albedo from albedo AOV. Light To Albedo: steps from white or light color to albedo color of object (use albedoLift to see more if dark albedo or textures). Darks Color: step to chosen color instead of default black.
      """
    )
    bool inputs:ri:Toon_Mask_Switch = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Mask"
        displayName = "Stylized Control Mask"
        doc = """Mult by Toon mask from PxrStylizedControl node in AOV NPRlineMask BLUE channel
  """
    )
    int inputs:ri:Toon_Steps = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Toon"
        displayName = "Steps"
        doc = """
      Number of steps to quantize lighting
  """
    )
    token inputs:ri:visualizer = "toonDiffuseFinal" (
        allowedTokens = ["beauty", "toonDiffRamp", "toonDiffuseFinal", "separator", "diffuseEnergy", "diffuseLuminance", "albedo"]
        connectability = "interfaceOnly"
        displayName = "Result"
        doc = "<help />"
    )
    token inputs:ri:whiteShader = "signalAovAverage" (
        allowedTokens = ["signalAovAverage", "albedoAOV", "NPRalbedoAOV"]
        connectability = "interfaceOnly"
        displayGroup = "Input"
        displayName = "Grayscale Mode"
        doc = """ Under the hood a white shader approximation is created based off the Signal AOV to drive the Toon response. 
        By default using average of RGB components of Signal AOV, but can also extract Signal AOV lighting results with a pure albedo from NPRalbedo AOV or albedo AOV. 
        If NPRalbedo AOV chosen, must set Albedo Color in Stylized Controller Pattern node. 
        Ignored when using PxrOcclusion integrator.
    """
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedToon" (
        displayGroup = "Internal"
    )
}

class PxrWhitePointDisplayFilter "PxrWhitePointDisplayFilter" (
    customData = {
        string className = "WhitePointDisplayFilter"
    }
    doc = """
        This display filter allows you to adjust the output colors so that the given color temperature is considered white.
    """
    inherits = </PxrDisplayFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    color3f inputs:ri:manualWhitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "White Point"
        doc = """
            Adjust the image so that this color becomes the white value.
        """
    )
    float inputs:ri:temperature = 6500 (
        connectability = "interfaceOnly"
        displayName = "Temperature"
        doc = """
            Allow the user to choose the color temperature of the light.
            Unlike the basic light color this allows the user to easily
            pick plausible light colors based on standard temperature
            measurements.
        """
    )
    bool inputs:ri:useManualWhitePoint = 0 (
        connectability = "interfaceOnly"
        displayName = "Manual White Point?"
        doc = """
           This switch enables using the White Point below rather than rely on
           color temperature for white balance.
        """
    )
    uniform token ri:displayFilter:shaderId = "PxrWhitePointDisplayFilter" (
        displayGroup = "Internal"
    )
}

class PxrDebugShadingContext "PxrDebugShadingContext" (
    customData = {
        string className = "DebugShadingContext"
    }
    doc = '''
        This integrator is used to visualize data in the shading
        context, such as normals and texture coordinates. It is not
        designed to produce "final-quality" images.
    '''
    inherits = </PxrIntegratorPluginBase>
)
{
    token inputs:ri:viewchannel = "Nn" (
        allowedTokens = ["Nn", "Vn", "VLen", "Tn", "InsideOutside", "st", "dsdu_dtdv", "dsdv_dtdu", "uv", "dudv", "LightLeaks", "P", "dPdu", "dPdv", "dPdtime", "id", "Ngn", "Po", "NoN", "mpSize"]
        connectability = "interfaceOnly"
        doc = """
\t   The data to visualize from the shading context.
        """
    )
    uniform token ri:integrator:shaderId = "PxrDebugShadingContext" (
        displayGroup = "Internal"
    )
}

class PxrDefault "PxrDefault" (
    customData = {
        string className = "Default"
    }
    doc = '''
        Even simpler than PxrDirectLighting, the default integrator
        places a virtual light at the camera (the "headlamp
        integrator"). No shadows or indirect lighting are evaluated. A
        good option when all is black - this integrator can help
        narrow down where a problem is occurring (for example, when
        the fault is in the lighting, particularly). Like
        PxrDirectLighting, it is not designed to produce
        "final-quality" images.
    '''
    inherits = </PxrIntegratorPluginBase>
)
{
    uniform token ri:integrator:shaderId = "PxrDefault" (
        displayGroup = "Internal"
    )
}

class PxrDirectLighting "PxrDirectLighting" (
    customData = {
        string className = "DirectLighting"
    }
    doc = """
        This is a debugging or \"draft-quality\" integrator that
        implements only the direct lighting portion of the light
        transport. It is not designed to produce \"final-quality\"
        images. Since it doesn't implement indirect lighting paths it
        cannot produce reflections, refractions, or other global
        illumination effects, nor can it handle any effects that
        require a volume integrator.
    """
    inherits = </PxrIntegratorPluginBase>
)
{
    int inputs:ri:numBxdfSamples = 4 (
        connectability = "interfaceOnly"
        doc = """
    Controls the number of Bxdf samples for direct illumination per
    camera hit point. The default is 4.
        """
    )
    int inputs:ri:numLightSamples = 4 (
        connectability = "interfaceOnly"
        doc = """
    Controls the number of light samples for direct illumination per
    camera hit point. The default is 4.
        """
    )
    uniform token ri:integrator:shaderId = "PxrDirectLighting" (
        displayGroup = "Internal"
    )
}

class PxrOcclusion "PxrOcclusion" (
    customData = {
        string className = "Occlusion"
    }
    doc = """
        Render occlusion.
    """
    inherits = </PxrIntegratorPluginBase>
)
{
    float inputs:ri:cosineSpread = 1 (
        connectability = "interfaceOnly"
        displayName = "Cosine Spread"
        doc = """
            Sample spread for cosine distribution. The default of 1 gives Lambertian distribution.
        """
    )
    int inputs:ri:distribution = 1 (
        connectability = "interfaceOnly"
        displayName = "Sample Distribution"
        doc = """
            Sample distribution can be uniform, cosine, or reflection. Reflection means that
            the sample directions are generated by the Bxdfs. The default is cosine.
        """
    )
    float inputs:ri:falloff = 0 (
        connectability = "interfaceOnly"
        displayName = "Falloff"
        doc = """
            Falloff values greater than zero create a softer look. The default is 0.
        """
    )
    float inputs:ri:maxDistance = 0 (
        connectability = "interfaceOnly"
        displayName = "Max Distance"
        doc = """
            The max distance at which objects may occlude. The default of 0 is infinite.
        """
    )
    int inputs:ri:numSamples = 4 (
        connectability = "interfaceOnly"
        displayName = "Num Samples"
        doc = """
            Controls the number of occlusion samples per camera hit point. The default is 4.
        """
    )
    bool inputs:ri:useAlbedo = 0 (
        connectability = "interfaceOnly"
        displayName = "Use Albedo"
        doc = """
            Tint occlusion by material albedo. The default is 0 (off).
        """
    )
    uniform token ri:integrator:shaderId = "PxrOcclusion" (
        displayGroup = "Internal"
    )
}

class PxrPathTracer "PxrPathTracer" (
    customData = {
        string className = "PathTracer"
    }
    inherits = </PxrIntegratorPluginBase>
)
{
    bool inputs:ri:accumOpacity = 0 (
        connectability = "interfaceOnly"
        displayName = "Accumulate Opacity"
        doc = """
        Controls whether or not the path tracer
        will keep track of accumulated opacity
        along the path. The default is off.
        """
    )
    bool inputs:ri:allowCaustics = 0 (
        connectability = "interfaceOnly"
        displayName = "Allow Caustics"
        doc = """
        Controls whether illumination from
        caustic light paths (that is, specular
        illumination onto diffuse surfaces) is
        allowed or disallowed.
        The default is off.
        """
    )
    int inputs:ri:clampDepth = 2 (
        connectability = "interfaceOnly"
        displayGroup = "Indirect Clamping"
        displayName = "Depth"
        doc = """
            If a value for the clampLuminance parameter is specified, then
            clampDepth controls the ray depth at which to begin clamping
            based on the per-ray luminance. For example, setting this
            parameter to 2 and also specifying a value of 4 for
            clampLuminance will ensure that the luminance of each ray's
            contribution is no more than 4 for all indirect illumination,
            without affecting or clamping the direct illumination. The
            default is 2.
            """
    )
    float inputs:ri:clampLuminance = 10 (
        connectability = "interfaceOnly"
        displayGroup = "Indirect Clamping"
        displayName = "Luminance"
        doc = """
            By default the PxrPathTracer integrator clamps the luminance
            of each per-ray contribution to be at most 10.0. However, it
            is possible to change this behavior by specifying a different
            value for the clampLuminance parameter. Specifying a
            relatively low value for the clampLuminance parameter (for
            example, between 2 and 20) can greatly speed up convergence
            and, in many cases, will make PxrPathTracer converge more
            quickly than the more sophisticated PxrVCM integrator. In some
            cases, indirect illumination lights paths may be noticeably
            dimmer due to clamping; this may be an acceptable trade-off in
            certain cases. Setting this parameter to a very large number
            (such as 1e30) will effectively disable all clamping. The
            default is 10.0.
            """
    )
    bool inputs:ri:jointSampling = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Aggregate Volumes"
        displayName = "Joint Sampling"
        doc = """
                Enables joint importance sampling of visibility and light sources.
                This should be enabled for scenes with light sources near volumes and for scenes with non-thick volumes (alpha < 0.99).
                For thick volumes (alpha near 1) lit only by distant light sources, there is a performance benefit to disabling joint sampling.
            """
    )
    float inputs:ri:jointScatteringBias = 0.5 (
        displayGroup = "Aggregate Volumes"
        displayName = "Joint Scattering Bias"
        doc = """
                By default, the joint sampling method will choose to scatter light proportionally to the opacity of each ray. This probability can be increased by raising the bias value (which does not bias the render itself), at the cost of undersampling objects behind the volume. For renders containing only volumes, this can be set to 1.0 to force a scatter event on all rays, even for thin volumes.
            """
    )
    int inputs:ri:maxContinuationLength = -1 (
        connectability = "interfaceOnly"
        displayName = "Continuation Depth"
        doc = """
    Similar to maxIndirectBounces, this controls the upper bound on the
    maximum ray depth -- but including continuation rays. Any negative value
    will cause the path tracer to use an empirical heuristic to bound
    the ray depth. A positive value will override this heuristic and
    cause the path tracer to use the parameter value directly as the
    maximum ray depth. Continuation rays are normally produced by
    volumes when no density exists within subsections of them. If there
    are many such zero density subsections overlapping then it is
    possible to quickly hit the maximum continuation depth quickly,
    resulting in black regions within your render.
    The default is -1.
        """
    )
    int inputs:ri:maxIndirectBounces = 8 (
        connectability = "interfaceOnly"
        displayName = "Max Indirect Bounces"
        doc = '''
            The maximum number of bounces of indirect illumination in your scene.
            0 means direct illumination only, 1 means one bounce of indirect, etc.
            Note: this parameter is one less than the old PxrPathTracer parameter
            called "maxPathLength" -- the new name is more descriptive, and is
            consistent with other integrators.
            The default is 8.
        '''
    )
    int inputs:ri:maxNonStochasticOpacityEvents = 0 (
        connectability = "interfaceOnly"
        displayName = "Stochastic Opacity Depth"
        doc = '''
    Defines the camera ray depth for which opacity
    calculations are computed with no noise (using
    continuation rays). Once this depth is exceeded,
    the opacity computation will switch to a stochastic
    "presence" style of opacity, which may introduce
    noise.
    The default is 0.
        '''
    )
    int inputs:ri:numBxdfSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "BXDF Samples"
        doc = """
    Controls the number of Bxdf samples for direct
    illumination per camera hit point.
    The default is 1.
        """
    )
    int inputs:ri:numDiffuseSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Diffuse Samples"
        doc = """
    When sampleMode is set to manual, controls the
    number of indirect diffuse reflection rays to
    spawn per camera hit point. Ignored when
    sampleMode is set to Bxdf.
    The default is 1.
        """
    )
    int inputs:ri:numIndirectSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Indirect Samples"
        doc = """
    When sampleMode is set to Bxdf this parameter
    controls the total number of indirect rays to
    spawn per camera hit point. When sampleMode is
    set to manual the value of this parameter is
    ignored.
    The default is 1.
        """
    )
    int inputs:ri:numLightSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Light Samples"
        doc = """
    Controls the number of light samples for direct
    illumination per camera hit point.
    The default is 1.
        """
    )
    int inputs:ri:numRefractionSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Refraction Samples"
        doc = """
    When sampleMode is set to manual, controls
    the number of refraction/transmission rays
    to spawn per camera hit point. Ignored when
    sampleMode is set to Bxdf.
    The default is 1.
        """
    )
    int inputs:ri:numSpecularSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Specular Samples"
        doc = """
    When sampleMode is set to manual, controls
    the number of indirect specular/glossy
    reflection rays to spawn per camera hit
    point. Ignored when sampleMode is set to
    Bxdf.
    The default is 1.
        """
    )
    int inputs:ri:numSubsurfaceSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Subsurface Samples"
        doc = """
    When sampleMode is set to manual, controls
    the number of subsurface rays to spawn per
    camera hit point. Ignored when sampleMode
    is set to Bxdf.
    The default is 1.
        """
    )
    int inputs:ri:numVolumeAggregateSamples = 1 (
        connectability = "interfaceOnly"
        displayName = "Volume Aggregate Samples"
        doc = """
    Controls the number of volume aggregate samples for direct
    illumination taken on the first ray segment.
    The default is 1.
        """
    )
    bool inputs:ri:risPathGuiding = 0 (
        connectability = "interfaceOnly"
        displayName = "RIS path guiding"
        doc = """
        Uses learnt results to guide directions
        for indirect path sampling. Can only be
        used if light selection learning is also on
        The default is off.
        """
    )
    int inputs:ri:rouletteDepth = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Russian Roulette"
        displayName = "Depth"
        doc = """
            The path length at which the integrator will begin
            performing Russian roulette (a method of probabilistically
            terminating a ray path). Decreasing this setting will lead
            to shorter paths and faster renders, but will result in
            more noise.
            """
    )
    float inputs:ri:rouletteThreshold = 0.2 (
        connectability = "interfaceOnly"
        displayGroup = "Russian Roulette"
        displayName = "Threshold"
        doc = """
            The path throughput threshold below which Russian roulette
            is applied. It is usually preferable to apply Russian
            roulette only to paths of low importance in order to avoid
            noise. Increasing this setting will apply Russian roulette
            to more paths and thus increase the speed of the render,
            but will also increase noise.
            """
    )
    token inputs:ri:sampleMode = "bxdf" (
        allowedTokens = ["manual", "bxdf"]
        connectability = "interfaceOnly"
        displayName = "Sample Mode"
        doc = '''
    Controls the strategy for how indirect ray counts are apportioned
    between diffuse vs. glossy vs. specular Bxdf lobes. Valid values
    for this parameter are: "bxdf" or "manual". If "sampleMode" is set
    to "bxdf", then the Bxdf is responsible for balancing the number
    of indirect rays that will be spawned at each camera hit point
    between the diffuse vs. glossy vs. specular lobes, and the total
    number of indirect rays spawned at each camera hit point will be
    controlled by the numIndirectSamples parameter. If "sampleMode" is
    set to "manual" the user is responsible for explicitly specifying
    the number of indirect rays to spawn per Bxdf lobe at each camera
    hit point via the numDiffuseSamples, numSpecularSamples,
    numSubsurfaceSamples, and numRefractionSamples parameters.
    The default is "bxdf".
        '''
    )
    string inputs:ri:volumeAggregate = "globalVolumeAggregate" (
        connectability = "interfaceOnly"
        displayGroup = "Aggregate Volumes"
        displayName = "Volume Aggregate Name"
        doc = "Specifies the name of the global volume aggregate to use for rendering."
    )
    string inputs:ri:volumeAggregateCamera = "" (
        connectability = "interfaceOnly"
        displayGroup = "Aggregate Volumes"
        displayName = "Camera Aggregate Override"
        doc = "Overrides the global aggregate name for camera rays. If left empty, the global volume aggregate will be used."
    )
    string inputs:ri:volumeAggregateIndirect = "" (
        connectability = "interfaceOnly"
        displayGroup = "Aggregate Volumes"
        displayName = "Indirect Aggregate Override"
        doc = "Overrides the global aggregate name for indirect rays. If left empty, the global volume aggregate will be used."
    )
    string inputs:ri:volumeAggregateTransmission = "" (
        connectability = "interfaceOnly"
        displayGroup = "Aggregate Volumes"
        displayName = "Transmission Aggregate Override"
        doc = "Overrides the global aggregate name for transmission rays. If left empty, the global volume aggregate will be used."
    )
    uniform token ri:integrator:shaderId = "PxrPathTracer" (
        displayGroup = "Internal"
    )
}

class PxrVCM "PxrVCM" (
    customData = {
        string className = "VCM"
    }
    inherits = </PxrIntegratorPluginBase>
)
{
    int inputs:ri:clampDepth = 2 (
        connectability = "interfaceOnly"
        displayGroup = "Indirect Clamping"
        doc = """
          If a value for the clampLuminance parameter is specified, then
          clampDepth controls the ray depth at which to begin clamping
          based on the per-ray luminance. For example, setting this
          parameter to 2 and also specifying a value of 4 for
          clampLuminance will ensure that the luminance of each ray's
          contribution is no more than 4 for all indirect illumination,
          without affecting or clamping the direct illumination. The
          default is 2.
        """
    )
    float inputs:ri:clampLuminance = 10 (
        connectability = "interfaceOnly"
        displayGroup = "Indirect Clamping"
        doc = """
          By default the PxrPathTracer integrator clamps the luminance
          of each per-ray contribution to be at most 10.0. However, it
          is possible to change this behavior by specifying a different
          value for the clampLuminance parameter. Specifying a
          relatively low value for the clampLuminance parameter (for
          example, between 2 and 20) can speed up convergence. In some
          cases, indirect illumination lights paths may be noticeably
          dimmer due to clamping; this may be an acceptable trade-off in
          certain cases. Setting this parameter to a very large number
          (such as 1e30) will effectively disable all clamping. The
          default is 10.0.
          Note that changing the mergeRadius will/can change the smoothness
          of the illumination and hence the clamping.
        """
    )
    bool inputs:ri:connectPaths = 1 (
        connectability = "interfaceOnly"
        doc = """
        When on, bidirectional path tracing is enabled;
        otherwise, VCM will operate as a forward path tracer (if
        merging is also disabled). Recommended for most scenes,
        especially interior scenes with significant indirect
        illumination.  On by default.
      """
    )
    int inputs:ri:maxIndirectBounces = 8 (
        connectability = "interfaceOnly"
        displayName = "Max Indirect Bounces"
        doc = '''
            The maximum number of bounces of indirect illumination in your scene.
            0 means direct illumination only, 1 means one bounce of indirect, etc.
            Note: this parameter is one less than the old PxrVCM parameter
            called "maxPathLength" -- the new name is more descriptive, and is
            consistent with other integrators.
            The default is 8.
        '''
    )
    bool inputs:ri:mergePaths = 1 (
        connectability = "interfaceOnly"
        doc = """
        Controls vertex merging, which improves the convergence of
        specular-diffuse-specular (caustic) lighting. Enabling
        vertex merging is generally recommended but may result in
        additional time and memory overhead for photons, and in
        scenes with little specular-diffuse-specular transport,
        may be unnecessary.  On by default.
      """
    )
    float inputs:ri:mergeRadius = 5 (
        connectability = "interfaceOnly"
        displayGroup = "Vertex Merging"
        doc = """
          Initial radius used in vertex merging.  It is measured in screen
          space pixels (not world space).  Increasing this radius will lead to
          increased blurring of the photons, which is helpful in reducing
          noisy caustics. However, this will also slow down merging,
          and will also require more iterations in order to arrive at
          a bias-free result.
        """
    )
    int inputs:ri:numBxdfSamples = 1 (
        connectability = "interfaceOnly"
        doc = """
        The number of bxdf samples taken when computing direct
        illumination. The default is ``1``.
      """
    )
    int inputs:ri:numLightSamples = 1 (
        connectability = "interfaceOnly"
        doc = """
        The number of light samples taken when computing direct
        illumination. The default is ``1``.
      """
    )
    float inputs:ri:photonGuiding = 0 (
        connectability = "interfaceOnly"
        displayGroup = "Photon Guiding"
        doc = """
          Sets the probability of using photon guiding during photon emission.
          A value of 0.0 turns off photon guiding.  A value between 0.0 and
          1.0 will cause a combination of photon guiding and standard photon
          emission. Finally, a value of 1 means that only photon
          guiding will be used -- in that case photons will be emitted only
          towards the specified bounding box, which may result in rendering of
          biased images. The default value is 0.0.
        """
    )
    point3f inputs:ri:photonGuidingBBoxMax = (-1e30, -1e30, -1e30) (
        connectability = "interfaceOnly"
        displayGroup = "Photon Guiding"
        doc = """
          These two parameters can be used to explicitly specify the bounding
          box (in world space coordinates) towards which more photons should be
          emitted. If this bounding box is
          not specified, it will be computed automatically as a (slightly loose)
          bounding box of the directly visible parts of the scene.
        """
    )
    point3f inputs:ri:photonGuidingBBoxMin = (1e30, 1e30, 1e30) (
        connectability = "interfaceOnly"
        displayGroup = "Photon Guiding"
    )
    int inputs:ri:rouletteDepth = 4 (
        connectability = "interfaceOnly"
        displayGroup = "Russian Roulette"
        doc = """
          The path length at which the integrator will begin
          performing Russian roulette (a method of probabilistically
          terminating a ray path). Decreasing this setting will lead
          to shorter paths and faster renders, but will result in
          more noise.
        """
    )
    float inputs:ri:rouletteThreshold = 0.2 (
        connectability = "interfaceOnly"
        displayGroup = "Russian Roulette"
        doc = """
          The path throughput threshold below which Russian roulette
          is applied. It is usually preferable to apply Russian
          roulette only to paths of low importance in order to avoid
          noise. Increasing this setting will apply Russian roulette
          to more paths and thus increase the speed of the render,
          but will also increase noise.
        """
    )
    float inputs:ri:timeRadius = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Vertex Merging"
        doc = """
          Specifies the maximum interval in time (as a fraction of
          the shutter) over which photons are merged. The default
          value of 1.0 may cause smearing for caustics involving
          moving objects. Decreasing the timeRadius will lead to
          more accurate results/decreased smearing for motion
          blurred caustics, at the cost of static objects requiring
          more photons in order to resolve caustics.
        """
    )
    uniform token ri:integrator:shaderId = "PxrVCM" (
        displayGroup = "Internal"
    )
}

class PxrValidateBxdf "PxrValidateBxdf" (
    customData = {
        string className = "ValidateBxdf"
    }
    doc = """
       This integrator serves mainly as a debugging tool to authors of
       Bxdf plugins. The 3 channels of the output are the luminance
       results for total hemispherical reflectance, computed in three
       different ways: the red channel gives the results of using the
       Bxdf's GenerateSample method to sample the bxdf; the green
       channel gives the results of running the Bxdf's EvaluateSample
       (or EvaluateSamplesAtIndex) method using the same generated
       samples, and only accumulating them if they agree with the
       values returned by GenerateSample; and the blue channel gives
       the results of integrating a set of hemispherical samples
       generated with a cosine weighting using the EvaluateSample
       method on the bxdf. Ideally, this will converge to the other
       two results.

       If the Bxdf is given \"white\" values and is correct, the
       resulting image should converge to all white pixels. Energy
       lost (either due to explicit absorption or due to the bxdf
       model losing energy) or gained shows up as non-white
       pixels. Bxdf authors should take care to observe what happens
       at grazing angles, as that can be a good place to lose energy.
    """
    inherits = </PxrIntegratorPluginBase>
)
{
    int inputs:ri:numSamples = 4 (
        connectability = "interfaceOnly"
        doc = """
    Controls the number of Bxdf samples to generate and evaluate per ray. The default is 4.
        """
    )
    uniform token ri:integrator:shaderId = "PxrValidateBxdf" (
        displayGroup = "Internal"
    )
}

class PxrVisualizer "PxrVisualizer" (
    customData = {
        string className = "Visualizer"
    }
    doc = """
        A utility integrator to navigate and inspect large scenes interactively.
        Can also be used for modeling or animation turntables and in general to
        detect geometric problems in your scenes.
    """
    inherits = </PxrIntegratorPluginBase>
)
{
    asset inputs:ri:matCap = @@ (
        connectability = "interfaceOnly"
        displayName = "MatCap Texture"
        doc = '''
        Material capture environment map used when style is "matcap".
        The surface normal is used to look up a color in this texture.
        '''
    )
    bool inputs:ri:normalCheck = 0 (
        connectability = "interfaceOnly"
        doc = """
        Colors geometry with inverted normals bright orange.
        """
    )
    bool inputs:ri:normalMap = 0 (
        connectability = "interfaceOnly"
        doc = """
        Maps normal's coordinates from [-1;1] to [0;1] to avoid black colors.
        """
    )
    string inputs:ri:shadedPrimVar = "displayColor" (
        connectability = "interfaceOnly"
        displayName = "Shaded PrimVar"
        doc = '''
        Tint color for "shaded" style.
        '''
    )
    token inputs:ri:style = "shaded" (
        allowedTokens = ["bxdf", "shaded", "flat", "normals", "objectnormals", "st", "matcap"]
        connectability = "interfaceOnly"
        doc = """
        bxdf: renders the scene as if the scene was lit with a single light at
        the camera's position.
        shaded: Simple N dot V shading. Normals are flipped if inverted.
        flat: Uses a random flat color based on the object's id.
        normals: displays normals in camera space.
        objectnormals: displays normals in object space.
        st: normalized st coordinates. Handy to visualize UDIM tiles.
        matcap: material capture. Uses the surface normal to look up color in
        an environment map.
        """
    )
    bool inputs:ri:wireframe = 1 (
        connectability = "interfaceOnly"
        doc = """
        Overlays wireframe. The default is on.
        """
    )
    color3f inputs:ri:wireframeColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayGroup = "Wireframe Settings"
        displayName = "Wireframe Color"
        doc = "Wireframe Color"
    )
    float inputs:ri:wireframeOpacity = 0.5 (
        connectability = "interfaceOnly"
        displayGroup = "Wireframe Settings"
        displayName = "Wireframe Opacity"
        doc = "Wireframe Opacity"
    )
    float inputs:ri:wireframeWidth = 1 (
        connectability = "interfaceOnly"
        displayGroup = "Wireframe Settings"
        displayName = "Wireframe Width"
        doc = "Wireframe Width"
    )
    uniform token ri:integrator:shaderId = "PxrVisualizer" (
        displayGroup = "Internal"
    )
}

class PxrBackgroundSampleFilter "PxrBackgroundSampleFilter" (
    customData = {
        string className = "BackgroundSampleFilter"
    }
    doc = """
    Sample filter plugin to color the background.
  """
    inherits = </PxrSampleFilterPluginBase>
)
{
    color3f inputs:ri:backgroundColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Background Color"
        doc = """
        Color of the background.
    """
    )
    uniform token ri:sampleFilter:shaderId = "PxrBackgroundSampleFilter" (
        displayGroup = "Internal"
    )
}

class PxrCopyAOVSampleFilter "PxrCopyAOVSampleFilter" (
    customData = {
        string className = "CopyAOVSampleFilter"
    }
    doc = """
    Sample filter plugin to look up a named AOV and copy it
    to Ci.
  """
    inherits = </PxrSampleFilterPluginBase>
)
{
    string inputs:ri:readAov = "" (
        connectability = "interfaceOnly"
        displayName = "Read AOV"
        doc = "Name of AOV to read from."
    )
    string inputs:ri:writeAov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "Write AOV"
        doc = "Name of AOV to write to."
    )
    uniform token ri:sampleFilter:shaderId = "PxrCopyAOVSampleFilter" (
        displayGroup = "Internal"
    )
}

class PxrCryptomatte "PxrCryptomatte" (
    customData = {
        string className = "Cryptomatte"
    }
    doc = """
    Sample filter to generate Cryptomatte files for easy creation of
    keyable ID mattes.  See https://github.com/Psyop/Cryptomatte for tools
    and details.
  """
    inherits = </PxrSampleFilterPluginBase>
)
{
    int inputs:ri:accuracy = 4 (
        connectability = "interfaceOnly"
        displayName = "Accuracy"
        doc = """
      The number of extra id/coverage pairs computed but not stored.  Up to
      a point, increasing this produces a better estimate for pixels where
      there are many objects, but it does so at the expense of memory.
    """
    )
    string inputs:ri:attribute = "" (
        connectability = "interfaceOnly"
        displayName = "Attribute"
        doc = '''
      Name of the string attribute used to group objects and identify them
      in the manifest.  This will also be used to name the layer in the
      Cryptomatte file.  Only has an effect when "Layer" is set to
      "Attribute".
    '''
    )
    string inputs:ri:filename = "cryptomatte.exr" (
        connectability = "interfaceOnly"
        displayName = "Filename"
        doc = """
      Name of the EXR file to write the Cryptomatte to.
    """
    )
    token inputs:ri:layer = "identifier:name" (
        allowedTokens = ["identifier:object", "identifier:name", "user:__materialid", "Attribute"]
        connectability = "interfaceOnly"
        displayName = "Layer"
        doc = """
      What property to use to group objects and identify them in the
      manifest.  This will also be used to name the layer in the
      Cryptomatte file.
    """
    )
    int inputs:ri:levels = 6 (
        connectability = "interfaceOnly"
        displayName = "Levels"
        doc = """
      The number of id/coverage pairs to store in the Cryptomatte file.
    """
    )
    token inputs:ri:manifest = "header" (
        allowedTokens = ["none", "header", "sidecar"]
        connectability = "interfaceOnly"
        displayName = "Manifest"
        doc = """
      Where to store the object manifest.  Select 'None' if you do not wish
      to store a manifest at all.
    """
    )
    uniform token ri:sampleFilter:shaderId = "PxrCryptomatte" (
        displayGroup = "Internal"
    )
}

class PxrFilmicTonemapperSampleFilter "PxrFilmicTonemapperSampleFilter" (
    customData = {
        string className = "FilmicTonemapperSampleFilter"
    }
    doc = """
        Sample filter plugin based on Naughty Dog's Filmic Tonemapper from GDC Uncharted 2 HDR Lighting presentation.
    """
    inherits = </PxrSampleFilterPluginBase>
)
{
    float inputs:ri:A = 0.22 (
        connectability = "interfaceOnly"
        displayName = "Shoulder"
        doc = """
            Shoulder strength.
        """
    )
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    float inputs:ri:B = 0.3 (
        connectability = "interfaceOnly"
        displayName = "Linear"
        doc = """
            Linear strength.
        """
    )
    float inputs:ri:C = 0.1 (
        connectability = "interfaceOnly"
        displayName = "Linear Angle"
        doc = """
            Linear angle.
        """
    )
    float inputs:ri:D = 0.2 (
        connectability = "interfaceOnly"
        displayName = "Toe"
        doc = """
            Toe strength.
        """
    )
    float inputs:ri:E = 0.01 (
        connectability = "interfaceOnly"
        displayName = "Toe Numerator"
        doc = """
            Toe numerator.
        """
    )
    float inputs:ri:exposureAdjust = 1 (
        connectability = "interfaceOnly"
        displayName = "Exposure Adjustment"
        doc = """
            Exposure adjustment. This parameter is multiplied by the incoming
            pixel.
        """
    )
    float inputs:ri:F = 0.3 (
        connectability = "interfaceOnly"
        displayName = "Toe Denominator"
        doc = """
            Toe denominator.
        """
    )
    float inputs:ri:linearWhitePoint = 11.2 (
        connectability = "interfaceOnly"
        displayName = "White Point"
        doc = """
            Linear white point value.
        """
    )
    uniform token ri:sampleFilter:shaderId = "PxrFilmicTonemapperSampleFilter" (
        displayGroup = "Internal"
    )
}

class PxrGradeSampleFilter "PxrGradeSampleFilter" (
    customData = {
        string className = "GradeSampleFilter"
    }
    doc = """
        Nuke-like grade sample filter. Allows simple grading of the beauty pass.
    """
    inherits = </PxrSampleFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    color3f inputs:ri:blackPoint = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Black Point"
        doc = """
            Ci is remapped so that this color becomes 0.
        """
    )
    bool inputs:ri:clampBlack = 1 (
        connectability = "interfaceOnly"
        displayName = "Clamp Black"
        doc = """
            Clamp Ci so that no value is less than 0. This is useful for compositing so that adding channels will not result in unexpected results.
        """
    )
    bool inputs:ri:clampWhite = 0 (
        connectability = "interfaceOnly"
        displayName = "Clamp White"
        doc = """
            Clamp Ci so that no value exceeds 1.
        """
    )
    color3f inputs:ri:gain = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Gain"
        doc = """
            Multiply Ci by this color.
        """
    )
    color3f inputs:ri:gamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Gamma"
        doc = """
            Gamma Ci by this color.
        """
    )
    color3f inputs:ri:lift = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Lift"
        doc = """
            Add this value to Ci.
        """
    )
    color3f inputs:ri:mask = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Mask"
        doc = """
            Mask the color correction result with this color.
        """
    )
    color3f inputs:ri:multiply = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Multiply"
        doc = """
            Multiply Ci by this color.
        """
    )
    color3f inputs:ri:offset = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Offset"
        doc = """
            Offset Ci (Ci + offset) by this color.
        """
    )
    color3f inputs:ri:whitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "White Point"
        doc = """
            Ci is remapped so that this color becomes 1.
        """
    )
    uniform token ri:sampleFilter:shaderId = "PxrGradeSampleFilter" (
        displayGroup = "Internal"
    )
}

class PxrImagePlaneFilter "PxrImagePlaneFilter" (
    customData = {
        string className = "ImagePlaneFilter"
    }
    doc = "Sample filter plugin to render image planes including holdouts."
    inherits = </PxrSampleFilterPluginBase>
)
{
    color3f inputs:ri:colorGain = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "Color Gain"
        doc = "Color gain."
    )
    color3f inputs:ri:colorOffset = (0, 0, 0) (
        connectability = "interfaceOnly"
        displayName = "Color Offset"
        doc = "Color offset."
    )
    asset inputs:ri:filename = @@ (
        connectability = "interfaceOnly"
        displayName = "Filename"
        doc = "The name of the plate image to display."
    )
    float inputs:ri:filmMaxX = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Right"
        doc = "Film window max X"
    )
    float inputs:ri:filmMaxY = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Top"
        doc = "Film window max Y"
    )
    float inputs:ri:filmMinX = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Left"
        doc = "Film window min X"
    )
    float inputs:ri:filmMinY = 0 (
        connectability = "interfaceOnly"
        displayName = "Film Window Bottom"
        doc = "Film window min Y"
    )
    int inputs:ri:fit = 0 (
        connectability = "interfaceOnly"
        displayName = "Fit"
        doc = "Fit image to display."
    )
    string inputs:ri:holdoutShadowAov = "" (
        connectability = "interfaceOnly"
        displayName = "Holdout Shadow AOV"
        doc = "The name of the holdout shadow AOV to look up."
    )
    bool inputs:ri:linearize = 0 (
        connectability = "interfaceOnly"
        displayName = "Linearize"
        doc = "Linearize"
    )
    float inputs:ri:offsetX = 0 (
        connectability = "interfaceOnly"
        displayName = "Offset X"
        doc = "Offset in X."
    )
    float inputs:ri:offsetY = 0 (
        connectability = "interfaceOnly"
        displayName = "Offset Y"
        doc = "Offset in Y."
    )
    float inputs:ri:rotate = 0 (
        connectability = "interfaceOnly"
        displayName = "Rotate"
        doc = "Rotation."
    )
    float inputs:ri:scaleX = 1 (
        connectability = "interfaceOnly"
        displayName = "Scale X"
        doc = "Scale in X."
    )
    float inputs:ri:scaleY = 1 (
        connectability = "interfaceOnly"
        displayName = "Scale Y"
        doc = "Scale in Y."
    )
    bool inputs:ri:useAlpha = 0 (
        connectability = "interfaceOnly"
        displayName = "Use Alpha"
        doc = "Applies alpha from the image plane to the beauty image"
    )
    uniform token ri:sampleFilter:shaderId = "PxrImagePlaneFilter" (
        displayGroup = "Internal"
    )
}

class PxrSampleFilterCombiner "PxrSampleFilterCombiner" (
    customData = {
        string className = "SampleFilterCombiner"
    }
    doc = """
        Sample filter combiner.
    """
    inherits = </PxrSampleFilterPluginBase>
)
{
    token inputs:ri:filter (
        displayName = "Sample Filter"
        doc = """
            Sample filters.
        """
    )
    uniform token ri:sampleFilter:shaderId = "PxrSampleFilterCombiner" (
        displayGroup = "Internal"
    )
}

class PxrShadowFilter "PxrShadowFilter" (
    customData = {
        string className = "ShadowFilter"
    }
    doc = "Sample filter plugin to calculate shadow AOV output from occluded and unoccluded AOV inputs."
    inherits = </PxrSampleFilterPluginBase>
)
{
    string inputs:ri:occludedAov = "" (
        connectability = "interfaceOnly"
        displayName = "Occluded AOV"
        doc = "The name of the occluded AOV to look up."
    )
    string inputs:ri:shadowAov = "" (
        connectability = "interfaceOnly"
        displayName = "Shadow AOV"
        doc = "The name of the shadow AOV to write to."
    )
    string inputs:ri:unoccludedAov = "" (
        connectability = "interfaceOnly"
        displayName = "Unoccluded AOV"
        doc = "The name of the unoccluded AOV to look up."
    )
    uniform token ri:sampleFilter:shaderId = "PxrShadowFilter" (
        displayGroup = "Internal"
    )
}

class PxrWatermarkFilter "PxrWatermarkFilter" (
    customData = {
        string className = "WatermarkFilter"
    }
    doc = "Sample filter plugin to add watermarks to renders."
    inherits = </PxrSampleFilterPluginBase>
)
{
    asset inputs:ri:filename = @@ (
        connectability = "interfaceOnly"
        displayName = "Filename"
        doc = "The name of the plate image to display."
    )
    int inputs:ri:fit = 1 (
        connectability = "interfaceOnly"
        displayName = "Fit"
        doc = "Fit image to display."
    )
    bool inputs:ri:linearize = 0 (
        connectability = "interfaceOnly"
        displayName = "Linearize"
        doc = "Linearize"
    )
    int inputs:ri:mode = 3 (
        connectability = "interfaceOnly"
        displayName = "Mode"
        doc = "Watermark blend modes."
    )
    float inputs:ri:offsetX = 0 (
        connectability = "interfaceOnly"
        displayName = "Offset X"
        doc = "Offset in X."
    )
    float inputs:ri:offsetY = 0 (
        connectability = "interfaceOnly"
        displayName = "Offset Y"
        doc = "Offset in Y."
    )
    float inputs:ri:rotate = 0 (
        connectability = "interfaceOnly"
        displayName = "Rotate"
        doc = "Rotation."
    )
    float inputs:ri:scaleX = 1 (
        connectability = "interfaceOnly"
        displayName = "Scale X"
        doc = "Scale in X."
    )
    float inputs:ri:scaleY = 1 (
        connectability = "interfaceOnly"
        displayName = "Scale Y"
        doc = "Scale in Y."
    )
    float inputs:ri:transparency = 0 (
        connectability = "interfaceOnly"
        displayName = "Transparency"
        doc = "Transparency"
    )
    uniform token ri:sampleFilter:shaderId = "PxrWatermarkFilter" (
        displayGroup = "Internal"
    )
}

class PxrWhitePointSampleFilter "PxrWhitePointSampleFilter" (
    customData = {
        string className = "WhitePointSampleFilter"
    }
    doc = """
        This sample filter allows you to adjust the output colors so that the given color temperature is considered white.
    """
    inherits = </PxrSampleFilterPluginBase>
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        displayName = "AOV"
        doc = "Name of AOV to apply filter to."
    )
    color3f inputs:ri:manualWhitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        displayName = "White Point"
        doc = """
            Adjust the image so that this color becomes the white value.
        """
    )
    float inputs:ri:temperature = 6500 (
        connectability = "interfaceOnly"
        displayName = "Temperature"
        doc = """
            Allow the user to choose the color temperature of the light.
            Unlike the basic light color this allows the user to easily
            pick plausible light colors based on standard temperature
            measurements.
        """
    )
    bool inputs:ri:useManualWhitePoint = 0 (
        connectability = "interfaceOnly"
        displayName = "Manual White Point?"
        doc = """
           This switch enables using the White Point below rather than rely on
           color temperature for white balance.
        """
    )
    uniform token ri:sampleFilter:shaderId = "PxrWhitePointSampleFilter" (
        displayGroup = "Internal"
    )
}

class "PxrDspyDeepExrAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyDeepExrAPI"
    }
    doc = """
        Saves the image to a deep OpenEXR file.
    """
    inherits = </APISchemaBase>
)
{
    int ri:displayDriver:asrgba = 1 (
        displayName = "As RGBA"
        doc = "As RGBA"
    )
    token ri:displayDriver:compression = "zips" (
        allowedTokens = ["none", "rle", "zips"]
        displayName = "Compression"
        doc = "Compression"
    )
    float ri:displayDriver:forcepar = 0 (
        displayName = "Force PAR"
        doc = "Force PAR"
    )
    int ri:displayDriver:metadatacount = 0
    token ri:displayDriver:storage = "scanline" (
        allowedTokens = ["tiled", "scanline"]
        displayName = "Storage"
        doc = "Storage"
    )
    token ri:displayDriver:type = "half" (
        allowedTokens = ["half", "float"]
        displayName = "Type"
        doc = "Type"
    )
}

class "PxrDspyItAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyItAPI"
    }
    doc = '''
        Render to the "it" framebuffer.
    '''
    inherits = </APISchemaBase>
)
{
}

class "PxrDspyNullAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyNullAPI"
    }
    doc = """
        Null display driver. No image will be written. 
    """
    inherits = </APISchemaBase>
)
{
}

class "PxrDspyOpenExrAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyOpenExrAPI"
    }
    doc = """
        Saves the image to an OpenEXR file.
    """
    inherits = </APISchemaBase>
)
{
    int ri:displayDriver:asrgba = 1 (
        displayName = "As RGBA"
        doc = "As RGBA"
    )
    token ri:displayDriver:autocrop = "false" (
        allowedTokens = ["false", "true"]
        displayName = "Autocrop"
        doc = "Autocrop"
    )
    token ri:displayDriver:compression = "zips" (
        allowedTokens = ["none", "rle", "zip", "zips", "piz", "pixar", "b44", "b44a", "dwaa", "dwab"]
        displayName = "Compression"
        doc = "Compression"
    )
    float ri:displayDriver:compressionlevel = 45 (
        displayName = "Compression Level"
        doc = "Compression Level"
    )
    token ri:displayDriver:exrpixeltype = "half" (
        allowedTokens = ["half", "float"]
        displayName = "Type"
        doc = "Type"
    )
    float ri:displayDriver:forcepar = 0 (
        displayName = "Force PAR"
        doc = "Force PAR"
    )
    int ri:displayDriver:metadatacount = 0
    token ri:displayDriver:storage = "scanline" (
        allowedTokens = ["scanline", "tiled"]
        displayName = "Storage"
        doc = "Storage"
    )
}

class "PxrDspyPngAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyPngAPI"
    }
    doc = """
        Saves the image to a PNG file.
    """
    inherits = </APISchemaBase>
)
{
    int ri:displayDriver:quantize = 1 (
        displayName = "Quantize"
        doc = "Quantize"
    )
}

class "PxrDspyPointCloudAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyPointCloudAPI"
    }
    doc = """
        Render to a RenderMan pointcloud file.
    """
    inherits = </APISchemaBase>
)
{
}

class "PxrDspyTargaAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyTargaAPI"
    }
    doc = """
        Saves the image to a TARGA file.
    """
    inherits = </APISchemaBase>
)
{
    int ri:displayDriver:quantize = 1 (
        displayName = "Quantize"
        doc = "Quantize"
    )
}

class "PxrDspyTextureAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyTextureAPI"
    }
    doc = """
        Saves the image to a texture file.
        - Images rendered using this display driver must have power of two
          dimensions - no attempt will be made to resize the image when using
          this driver.
    """
    inherits = </APISchemaBase>
)
{
    token ri:displayDriver:compression = "lossless" (
        allowedTokens = ["none", "lossless", "lossy"]
        displayName = "Compression"
        doc = "Compression"
    )
    token ri:displayDriver:exrcompression = "DWAa" (
        allowedTokens = ["none", "rle", "zip", "zips", "piz", "pixar", "B44", "B44A", "DWAa", "DWAb"]
        displayName = "EXR Compression"
        doc = "EXR Compression"
    )
    float ri:displayDriver:exrcompressionlevel = 45 (
        displayName = "EXR Compression Level"
        doc = "EXR Compression Level"
    )
    token ri:displayDriver:exrpixeltype = "half" (
        allowedTokens = ["half", "float"]
        displayName = "EXR Bit Depth"
        doc = "EXR Bit Depth"
    )
    token ri:displayDriver:format = "pixar" (
        allowedTokens = ["pixar", "openexr", "tiff"]
        displayName = "Texture Format"
        doc = "Texture Format"
    )
    token ri:displayDriver:smode = "black" (
        allowedTokens = ["black", "clamp", "periodic"]
        displayName = "S Wrap Mode"
        doc = "S Wrap Mode"
    )
    token ri:displayDriver:tmode = "black" (
        allowedTokens = ["black", "clamp", "periodic"]
        displayName = "T Wrap Mode"
        doc = "T Wrap Mode"
    )
    token ri:displayDriver:type = "byte" (
        allowedTokens = ["byte", "short", "float"]
        displayName = "Bit Depth"
        doc = "Bit Depth"
    )
}

class "PxrDspyTiffAPI" (
    customData = {
        token[] apiSchemaCanOnlyApplyTo = ["RenderProduct"]
        string apiSchemaType = "singleApply"
        string className = "DspyTiffAPI"
    }
    doc = '''
        Saves the image to a Tagged Image File Format (TIFF).
        It can be used to store "r", "rgb", "rgba", "rgbz", and "rgbaz" images
        in 8, 16, or floating point 32-bit-per-component resolutions.
    '''
    inherits = </APISchemaBase>
)
{
    token ri:displayDriver:compression = "lzw" (
        allowedTokens = ["none", "lzw", "packbits", "deflate", "pixarlog"]
        displayName = "Compression"
        doc = "Compression"
    )
    token ri:displayDriver:format = "float32" (
        allowedTokens = ["uint8", "uint16", "float32"]
        displayName = "Format"
        doc = "Format"
    )
    int ri:displayDriver:quantize = 1 (
        displayName = "Quantize"
        doc = "Quantize"
    )
    token ri:displayDriver:resolution (
        displayGroup = "Advanced"
        displayName = "Resolution"
        doc = "Resolution"
    )
    token ri:displayDriver:resolutionunit = "none" (
        allowedTokens = ["none", "centimeters", "inches"]
        displayGroup = "Advanced"
    )
}

