#usda 1.0
(
    "This file describes the USD Shader schemata for code generation."
    subLayers = [
        @usd/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName      = "usdUI"
        string libraryPath      = "pxr/usd/usdUI"
        dictionary libraryTokens = {
            dictionary default_ = {
                        string value = "default"
                        string doc = """Name of the anonymous instance name for the schema"""
                    }
         }
    }
)
{
}

class "NodeGraphNodeAPI"(
    inherits = </APISchemaBase>
    doc = """
    This api helps storing information about nodes in node graphs.
    """
) {
    uniform float2 ui:nodegraph:node:pos (
        doc = """
        Declared relative position to the parent in a node graph.
        X is the horizontal position.
        Y is the vertical position. Higher numbers correspond to lower positions 
        (coordinates are Qt style, not cartesian).

        These positions are not explicitly meant in pixel space, but rather
        assume that the size of a node is approximately 1.0x1.0. Where size-x is
        the node width and size-y height of the node. Depending on 
        graph UI implementation, the size of a node may vary in each direction.

        Example: If a node's width is 300 and it is position is at 1000, we
        store for x-position: 1000 * (1.0/300)
        """
        customData = {
            string apiName = "pos"
        }
    )

    uniform int ui:nodegraph:node:stackingOrder (
        doc = """
        This optional value is a useful hint when an application cares about 
        the visibility of a node and whether each node overlaps another.
        
        Nodes with lower stacking order values are meant to be drawn below 
        higher ones. Negative values are meant as background. Positive values
        are meant as foreground.
        Undefined values should be treated as 0. 

        There are no set limits in these values.
        """
        customData = {
            string apiName = "stackingOrder"
        }
    )

    uniform color3f ui:nodegraph:node:displayColor (
        doc = """
        This hint defines what tint the node should have in the node graph.
        """
        customData = {
            string apiName = "displayColor"
        }
    )

    uniform asset ui:nodegraph:node:icon (
        doc = """
        This points to an image that should be displayed on the node.  It is 
        intended to be useful for summary visual classification of nodes, rather
        than a thumbnail preview of the computed result of the node in some
        computational system.
        """
        customData = {
            string apiName = "icon"
        }
    )

    uniform token ui:nodegraph:node:expansionState (
        allowedTokens = ["open", "closed", "minimized"]
        doc = """ 
        The current expansionState of the node in the ui. 
        'open' = fully expanded
        'closed' = fully collapsed
        'minimized' = should take the least space possible
        """
        customData = {
            string apiName = "expansionState"
        }
    )

    uniform float2 ui:nodegraph:node:size (
        doc = """
        Optional size hint for a node in a node graph.
        X is the width.
        Y is the height.

        This value is optional, because node size is often determined 
        based on the number of in- and outputs of a node.
        """
        customData = {
            string apiName = "size"
        }
    )

    uniform string ui:nodegraph:node:docURI (
        doc = """ 
        A URI pointing to additional detailed documentation for this 
        node or node type.
        """
        displayName = "Doc Link"

        displayGroup = "Help"

        customData = {
            string apiName = "docURI"
        }
    )
}


class "SceneGraphPrimAPI"(
    inherits = </APISchemaBase>
    doc = """
    Utility schema for display properties of a prim
    """
) {
    uniform token ui:displayName (
        doc = """When publishing a nodegraph or a material, it can be useful to
        provide an optional display name, for readability.
        """
        customData = {
            string apiName = "displayName"
        }
    )
    uniform token ui:displayGroup (
        doc = """When publishing a nodegraph or a material, it can be useful to
        provide an optional display group, for organizational purposes and 
        readability. This is because often the usd shading hierarchy is rather
        flat while we want to display it in organized groups.
        """
        customData = {
            string apiName = "displayGroup"
        }
    )
}

class Backdrop "Backdrop" (
    inherits = </Typed>
    doc = """Provides a 'group-box' for the purpose of node graph organization.

    Unlike containers, backdrops do not store the Shader nodes inside of them.
    Backdrops are an organizational tool that allows Shader nodes to be visually 
    grouped together in a node-graph UI, but there is no direct relationship 
    between a Shader node and a Backdrop. 

    The guideline for a node-graph UI is that a Shader node is considered part 
    of a Backdrop when the Backdrop is the smallest Backdrop a Shader node's 
    bounding-box fits inside.

    Backdrop objects are contained inside a NodeGraph, similar to how Shader 
    objects are contained inside a NodeGraph.

    Backdrops have no shading inputs or outputs that influence the rendered
    results of a NodeGraph. Therefore they can be safely ignored during import.

    Like Shaders and NodeGraphs, Backdrops subscribe to the NodeGraphNodeAPI to 
    specify position and size.
    """ 
)
{
    uniform token ui:description (
        doc = """The text label that is displayed on the backdrop in the node
        graph. This help-description explains what the nodes in a backdrop do.
        """
        customData = {
            string apiName = "description"
        }
    )
}

class "AccessibilityAPI" (
    inherits = </APISchemaBase>
    doc = """
    This API describes \\em Accessibility information on a Prim that may be surfaced to a given runtimes
    accessibility frameworks.
    This information may be used by assistive tooling such as voice controls or screen readers.
    Accessibility information is provided as a standard triplet of label, description and priority.

    OpenUSD does not provide a accessibility runtime itself, but endeavours to provide the information needed for
    compatible runtimes to extract and present this information.

    This is a multiple apply schema, and so may have multiple namespaced accessibility triplets, where a instance
    name may reflect a given purpose for that triplet. For example, you may desire to express different
    information for different aspects of the prim, such as size or color.

    \\note The API will use \\em default as an instance name if no namespace is specified.
    When using "default" as the name, the instance name is elided from the attribute name.
    
    There are several best practices for using this schema.:

    \\li Most accessibility runtimes support a single accessibility description. Therefore we recommend placing
    any critical information in the default instance.

    \\li A default value should be authored if using time sampled accessibility information. 
    This helps accessibility runtimes that do not currently support time sampled information.

    \\li Provide accessibility information of your scene on the default prim of the layer, and any top level prims.
    This allows accessibility systems to provide concise scene descriptions to a user, but also allows supporting
    accessibility systems that either do not support hierarchy information or when a user has turned off that level
    of granularity. Accessibility information may still be provided on other prims in the hierarchy.

    \\note The use of the default prim and top level prims for scene accessibility descriptions is a
    recommended convention. Outside of that, accessibility information is not implicitly inherited through
    a prim hierarchy. The inheritance should be left to the accessibility runtime to decide how best to
    surface information to users.
    """

    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "accessibility"
        dictionary schemaTokens = {
            dictionary label = {
                string value = "label"
                string doc = """Name of the label attribute"""
            }
            dictionary description = {
                string value = "description"
                string doc = """Name of the description attribute"""
            }
            dictionary priority = {
                string value = "priority"
                string doc = """Name of the priority attribute"""
            }
        }
    }
) {
    string label (
        doc = """A short label to concisely describe the prim.
        It is not recommended to time vary the label unless the concise description changes substantially."""
    )

    string description (
        doc = """An extended description of the prim to provide more details.
        If a label attribute is not authored in a given instance name, the description attribute should not be used
        in it its place. A description is an optional attribute, and some accessibility systems may only use the label.

        Descriptions may be time varying for runtimes that support it. For example, you may describe what a character
        is doing at a given time.
        """
    )

    uniform token priority = "standard" (
        doc = """A hint to the accessibility runtime of how to prioritize this instances label and description,
        relative to others. This attribute is optional. Accessibility runtimes may choose to apply their own
        priority systems that override this.

        Priority may not be time varying.
        """
        allowedTokens = ["low", "standard", "high"]
    )
}

class "LocalizationAPI" (
    inherits = </APISchemaBase>
    doc = """This API describes \em Language localization information for attributes.
    
    It may be used to provide alternate language definitions for content like strings and asset paths that are
    displayed to a user.
    Runtimes may present the best language for a given users preference with this information.

    OpenUSD leaves it up to the runtime that is consuming it to handle localized presentations.
    As such, support for localization may vary across runtimes.

    \\important Lookup of localized attributes may be expensive, so are recommended to be used sparingly
    It is recommended, but not enforced, to only use them for strings and asset paths.
    Support for localization of different attributes may vary depending on the application runtime that 
    the data is brought into.
    

    \\note Language identifiers must use the BCP-47 list of languages. However, since USD cannot currently use
    hyphens in identifiers, any hyphens are replaced with underscores. This is similar in strategy to other
    systems that adhere closely to the Unicode Identifier specification. e.g en-ca is en_CA .
    Take care when converting language identifiers to a systems own formatting.

    A default language is specifiable on a prim. This is the language that is assumed when attributes do
    not include their own identifier for language. The default language is explicitly inherited by 
    all prims under the current prims hierarchy.

    \\note Provide default localization information on the default prim of the layer, and any top level prims.
    It is not recommended to keep declarations of the default localization to a minimum throughout the rest of
    the hierarchy within a single layer.

    Attributes are suffixed with \\em :lang:<identifier> when expressing languages other than the default.
    
    For example, "string text" would implicitly be in the default localization language, but you may have
    "string text:lang:fr" for French.

    Runtimes may provide their own logic for choosing which langauge to display, but following BCP-47,
    a recommended logic set is:

    \\li If a preferred language is available within the set of declared languages, pick that language exactly.
    e.g "en_CA" should not pick simply "en" if "en_CA" is available

    \\li If a preferred language isn't available, check for a more specific version of that language.
    e.g "de_DE" may match to "de_DE_u_co_phonebk"

    \\li If a more specific language is not available, pick a less specific language.
    e.g "en_US" may match to "en"

    \\li If a less specific language choice is not available, pick the attribute without language specification.
    """

    customData = {
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "localization"
        dictionary schemaTokens = {
            dictionary lang = {
                string value = "lang"
                string doc = """The token that delineates language specifications on an attribute"""
            }
            dictionary languageAttribute = {
                string value = "localization:lang"
                string doc = """The non-namespaced version of the language localization attribute"""
            }
        }
    }
) {
    uniform token language (
        doc = """The default language for this prim hierarchy. This may only be created with the default instance name.
        
        \\note If no default localization language is provided, the runtime may optionally try and infer the
        language of the text.
        If the runtime does not infer the langauge, it should assume the language is in the users preferred language,
        which may be derived from the system or current user context.
        """
    )
}