#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class PhysicsScene "PhysicsScene" (
    doc = "General physics simulation properties, required for simulation."
)
{
    vector3f physics:gravityDirection = (0, 0, 0) (
        displayName = "Gravity Direction"
        doc = """Gravity direction vector in simulation world space. Will be
        normalized before use. A zero vector is a request to use the negative 
        upAxis. Unitless."""
    )
    float physics:gravityMagnitude = -inf (
        displayName = "Gravity Magnitude"
        doc = """Gravity acceleration magnitude in simulation world space. 
        A negative value is a request to use a value equivalent to earth 
        gravity regardless of the metersPerUnit scaling used by this scene. 
        Units: distance/second/second."""
    )
}

class "PhysicsRigidBodyAPI" (
    doc = """Applies physics body attributes to any UsdGeomXformable prim and
    marks that prim to be driven by a simulation. If a simulation is running
    it will update this prim's pose. All prims in the hierarchy below this 
    prim should move accordingly."""
)
{
    vector3f physics:angularVelocity = (0, 0, 0) (
        displayName = "Angular Velocity"
        doc = """Angular velocity in the same space as the node's xform. 
        Units: degrees/second."""
    )
    bool physics:kinematicEnabled = 0 (
        displayName = "Kinematic Enabled"
        doc = """Determines whether the body is kinematic or not. A kinematic 
        body is a body that is moved through animated poses or through 
        user defined poses. The simulation derives velocities for the
        kinematic body based on the external motion. When a continuous motion
        is not desired, this kinematic flag should be set to false."""
    )
    bool physics:rigidBodyEnabled = 1 (
        displayName = "Rigid Body Enabled"
        doc = "Determines if this PhysicsRigidBodyAPI is enabled."
    )
    rel physics:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that will simulate this body. By 
        default this is the first PhysicsScene found in the stage using 
        UsdStage::Traverse()."""
    )
    uniform bool physics:startsAsleep = 0 (
        displayName = "Starts as Asleep"
        doc = "Determines if the body is asleep when the simulation starts."
    )
    vector3f physics:velocity = (0, 0, 0) (
        displayName = "Linear Velocity"
        doc = """Linear velocity in the same space as the node's xform. 
        Units: distance/second."""
    )
}

class "PhysicsMassAPI" (
    doc = """Defines explicit mass properties (mass, density, inertia etc.).        
    MassAPI can be applied to any object that has a PhysicsCollisionAPI or
    a PhysicsRigidBodyAPI."""
)
{
    point3f physics:centerOfMass = (-inf, -inf, -inf) (
        displayName = "Center of Mass"
        doc = "Center of mass in the prim's local space. Units: distance."
    )
    float physics:density = 0 (
        displayName = "Density"
        doc = """If non-zero, specifies the density of the object.
        In the context of rigid body physics, density indirectly results in 
        setting mass via (mass = density x volume of the object). How the 
        volume is computed is up to implementation of the physics system.
        It is generally computed from the collision approximation rather than
        the graphical mesh. In the case where both density and mass are 
        specified for the same object, mass has precedence over density. 
        Unlike mass, child's prim's density overrides parent prim's density 
        as it is accumulative. Note that density of a collisionAPI can be also
        alternatively set through a PhysicsMaterialAPI. The material density
        has the weakest precedence in density definition. Note if density is
        0.0 it is ignored. Units: mass/distance/distance/distance."""
    )
    float3 physics:diagonalInertia = (0, 0, 0) (
        displayName = "Diagonal Inertia"
        doc = """If non-zero, specifies diagonalized inertia tensor along the 
        principal axes. Note if diagonalInertial is (0.0, 0.0, 0.0) it is 
        ignored. Units: mass*distance*distance."""
    )
    float physics:mass = 0 (
        displayName = "Mass"
        doc = """If non-zero, directly specifies the mass of the object.
        Note that any child prim can also have a mass when they apply massAPI.
        In this case, the precedence rule is 'parent mass overrides the
        child's'. This may come as counter-intuitive, but mass is a computed 
        quantity and in general not accumulative. For example, if a parent 
        has mass of 10, and one of two children has mass of 20, allowing 
        child's mass to override its parent results in a mass of -10 for the 
        other child. Note if mass is 0.0 it is ignored. Units: mass.
        """
    )
    quatf physics:principalAxes = (0, 0, 0, 0) (
        displayName = "Principal Axes"
        doc = """Orientation of the inertia tensor's principal axes in the 
        prim's local space."""
    )
}

class "PhysicsCollisionAPI" (
    doc = """Applies collision attributes to a UsdGeomXformable prim. If a 
    simulation is running, this geometry will collide with other geometries that 
    have PhysicsCollisionAPI applied. If a prim in the parent hierarchy has the
    RigidBodyAPI applied, this collider is a part of that body. If there is 
    no body in the parent hierarchy, this collider is considered to be static."""
)
{
    bool physics:collisionEnabled = 1 (
        displayName = "Collision Enabled"
        doc = "Determines if the PhysicsCollisionAPI is enabled."
    )
    rel physics:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that will simulate this collider. 
        By default this object belongs to the first PhysicsScene.
        Note that if a RigidBodyAPI in the hierarchy above has a different
        simulationOwner then it has a precedence over this relationship."""
    )
}

class "PhysicsMeshCollisionAPI" (
    doc = """Attributes to control how a Mesh is made into a collider.
       Can be applied to only a USDGeomMesh in addition to its
       PhysicsCollisionAPI."""
)
{
    uniform token physics:approximation = "none" (
        allowedTokens = ["none", "convexDecomposition", "convexHull", "boundingSphere", "boundingCube", "meshSimplification"]
        displayName = "Approximation"
        doc = """Determines the mesh's collision approximation:
\t\"none\" - The mesh geometry is used directly as a collider without any 
    approximation.
\t\"convexDecomposition\" - A convex mesh decomposition is performed. This 
    results in a set of convex mesh colliders.
\t\"convexHull\" - A convex hull of the mesh is generated and used as the 
    collider.
\t\"boundingSphere\" - A bounding sphere is computed around the mesh and used 
    as a collider.
\t\"boundingCube\" - An optimally fitting box collider is computed around the 
    mesh.
\t\"meshSimplification\" - A mesh simplification step is performed, resulting 
    in a simplified triangle mesh collider."""
    )
}

class "PhysicsMaterialAPI" (
    doc = """ Adds simulation material properties to a Material. All collisions 
    that have a relationship to this material will have their collision response 
    defined through this material."""
)
{
    float physics:density = 0 (
        displayName = "Density"
        doc = """If non-zero, defines the density of the material. This can be
        used for body mass computation, see PhysicsMassAPI.
        Note that if the density is 0.0 it is ignored. 
        Units: mass/distance/distance/distance."""
    )
    float physics:dynamicFriction = 0 (
        displayName = "Dynamic Friction"
        doc = "Dynamic friction coefficient. Unitless."
    )
    float physics:restitution = 0 (
        displayName = "Restitution"
        doc = "Restitution coefficient. Unitless."
    )
    float physics:staticFriction = 0 (
        displayName = "Static Friction"
        doc = "Static friction coefficient. Unitless."
    )
}

class PhysicsCollisionGroup "PhysicsCollisionGroup" (
    apiSchemas = ["CollectionAPI:colliders"]
    doc = """Defines a collision group for coarse filtering. When a collision 
    occurs between two objects that have a PhysicsCollisionGroup assigned,
    they will collide with each other unless this PhysicsCollisionGroup pair 
    is filtered. See filteredGroups attribute.
    
    A CollectionAPI:colliders maintains a list of PhysicsCollisionAPI rel-s that 
    defines the members of this Collisiongroup.
    """
)
{
    rel physics:filteredGroups (
        displayName = "Filtered Groups"
        doc = """References a list of PhysicsCollisionGroups with which 
        collisions should be ignored."""
    )
}

class "PhysicsFilteredPairsAPI" (
    doc = '''API to describe fine-grained filtering. If a collision between
    two objects occurs, this pair might be filtered if the pair is defined
    through this API. This API can be applied either to a body or collision
    or even articulation. The "filteredPairs" defines what objects it should 
    not collide against. Note that FilteredPairsAPI filtering has precedence 
    over CollisionGroup filtering.'''
)
{
    rel physics:filteredPairs (
        displayName = "Filtered Pairs"
        doc = "Relationship to objects that should be filtered."
    )
}

class PhysicsJoint "PhysicsJoint" (
    doc = """A joint constrains the movement of rigid bodies. Joint can be 
    created between two rigid bodies or between one rigid body and world.
    By default joint primitive defines a D6 joint where all degrees of 
    freedom are free. Three linear and three angular degrees of freedom.
    Note that default behavior is to disable collision between jointed bodies.
    """
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysicsRevoluteJoint "PhysicsRevoluteJoint" (
    doc = """Predefined revolute joint type (rotation along revolute joint
    axis is permitted.)"""
)
{
    uniform token physics:axis = "X" (
        allowedTokens = ["X", "Y", "Z"]
        displayName = "Axis"
        doc = "Joint axis."
    )
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    float physics:lowerLimit = -inf (
        displayName = "Lower Limit"
        doc = """Lower limit. Units: degrees. -inf means not limited in 
        negative direction."""
    )
    float physics:upperLimit = inf (
        displayName = "Upper Limit"
        doc = """Upper limit. Units: degrees. inf means not limited in 
        positive direction."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysicsPrismaticJoint "PhysicsPrismaticJoint" (
    doc = """Predefined prismatic joint type (translation along prismatic 
    joint axis is permitted.)"""
)
{
    uniform token physics:axis = "X" (
        allowedTokens = ["X", "Y", "Z"]
        displayName = "Axis"
        doc = "Joint axis."
    )
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    float physics:lowerLimit = -inf (
        displayName = "Lower Limit"
        doc = """Lower limit. Units: distance. -inf means not limited in 
        negative direction."""
    )
    float physics:upperLimit = inf (
        displayName = "Upper Limit"
        doc = """Upper limit. Units: distance. inf means not limited in 
        positive direction."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysicsSphericalJoint "PhysicsSphericalJoint" (
    doc = """Predefined spherical joint type (Removes linear degrees of 
    freedom, cone limit may restrict the motion in a given range.) It allows
    two limit values, which when equal create a circular, else an elliptic 
    cone limit around the limit axis."""
)
{
    uniform token physics:axis = "X" (
        allowedTokens = ["X", "Y", "Z"]
        displayName = "Axis"
        doc = "Cone limit axis."
    )
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    float physics:coneAngle0Limit = -1 (
        displayName = "Cone Angle0 Limit"
        doc = """Cone limit from the primary joint axis in the local0 frame 
        toward the next axis. (Next axis of X is Y, and of Z is X.) A 
        negative value means not limited. Units: degrees."""
    )
    float physics:coneAngle1Limit = -1 (
        displayName = "Cone Angle1 Limit"
        doc = """Cone limit from the primary joint axis in the local0 frame 
        toward the second to next axis. A negative value means not limited. 
        Units: degrees."""
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysicsDistanceJoint "PhysicsDistanceJoint" (
    doc = """Predefined distance joint type (Distance between rigid bodies
    may be limited to given minimum or maximum distance.)"""
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    float physics:maxDistance = -1 (
        displayName = "Maximum Distance"
        doc = """Maximum distance. If attribute is negative, the joint is not 
        limited. Units: distance."""
    )
    float physics:minDistance = -1 (
        displayName = "Minimum Distance"
        doc = """Minimum distance. If attribute is negative, the joint is not 
        limited. Units: distance."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysicsFixedJoint "PhysicsFixedJoint" (
    doc = """Predefined fixed joint type (All degrees of freedom are 
    removed.)"""
)
{
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "PhysicsLimitAPI" (
    doc = '''The PhysicsLimitAPI can be applied to a PhysicsJoint and will
    restrict the movement along an axis. PhysicsLimitAPI is a multipleApply 
    schema: The PhysicsJoint can be restricted along "transX", "transY", 
    "transZ", "rotX", "rotY", "rotZ", "distance". Setting these as a 
    multipleApply schema TfToken name will define the degree of freedom the
    PhysicsLimitAPI is applied to. Note that if the low limit is higher than 
    the high limit, motion along this axis is considered locked.'''
)
{
    float limit:__INSTANCE_NAME__:physics:high = inf (
        displayName = "High Limit"
        doc = """Upper limit. Units: degrees or distance depending on trans or 
        rot axis applied to. inf means not limited in positive direction."""
    )
    float limit:__INSTANCE_NAME__:physics:low = -inf (
        displayName = "Low Limit"
        doc = """Lower limit. Units: degrees or distance depending on trans or
        rot axis applied to. -inf means not limited in negative direction."""
    )
}

class "PhysicsDriveAPI" (
    doc = '''The PhysicsDriveAPI when applied to any joint primitive will drive
    the joint towards a given target. The PhysicsDriveAPI is a multipleApply 
    schema: drive can be set per axis "transX", "transY", "transZ", "rotX", 
    "rotY", "rotZ" or its "linear" for prismatic joint or "angular" for revolute 
    joints. Setting these as a multipleApply schema TfToken name will 
    define the degree of freedom the DriveAPI is applied to. Each drive is an 
    implicit force-limited damped spring: 
    Force or acceleration = stiffness * (targetPosition - position) 
    + damping * (targetVelocity - velocity)'''
)
{
    float drive:__INSTANCE_NAME__:physics:damping = 0 (
        doc = """Damping of the drive. Units: 
\t\tif linear drive: mass/second
\t\tIf angular drive: mass*DIST_UNITS*DIST_UNITS/second/second/degrees."""
    )
    float drive:__INSTANCE_NAME__:physics:maxForce = inf (
        displayName = "Max Force"
        doc = """Maximum force that can be applied to drive. Units: 
                if linear drive: mass*DIST_UNITS/second/second
                if angular drive: mass*DIST_UNITS*DIST_UNITS/second/second
                inf means not limited. Must be non-negative.
        """
    )
    float drive:__INSTANCE_NAME__:physics:stiffness = 0 (
        doc = """Stiffness of the drive. Units:
\t\tif linear drive: mass/second/second
\t\tif angular drive: mass*DIST_UNITS*DIST_UNITS/degree/second/second."""
    )
    float drive:__INSTANCE_NAME__:physics:targetPosition = 0 (
        displayName = "Target Position"
        doc = """Target value for position. Units: 
        if linear drive: distance
        if angular drive: degrees."""
    )
    float drive:__INSTANCE_NAME__:physics:targetVelocity = 0 (
        displayName = "Target Velocity"
        doc = """Target value for velocity. Units: 
        if linear drive: distance/second
        if angular drive: degrees/second."""
    )
    uniform token drive:__INSTANCE_NAME__:physics:type = "force" (
        allowedTokens = ["force", "acceleration"]
        displayName = "Type"
        doc = """Drive spring is for the acceleration at the joint (rather 
        than the force)."""
    )
}

class "PhysicsArticulationRootAPI" (
    doc = """PhysicsArticulationRootAPI can be applied to a scene graph node, 
    and marks the subtree rooted here for inclusion in one or more reduced 
    coordinate articulations. For floating articulations, this should be on
    the root body. For fixed articulations (robotics jargon for e.g. a robot 
    arm for welding that is bolted to the floor), this API can be on a direct 
    or indirect parent of the root joint which is connected to the world, or 
    on the joint itself.."""
)
{
}

