#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class ExecGraph "ExecGraph" (
    doc = '''A exec-graph is a container for exec-nodes, as well as other 
    exec-graphs. It has a public input interface and provides a list of public 
    outputs.

    <b>Exec Graph Interfaces</b>
    
    One of the most important functions of a exec-graph is to host the "interface"
    with which clients of already-built execution networks will interact.  Please
    see "Interface Inputs" for a detailed
    explanation of what the interface provides, and how to construct and
    use it, to effectively share/instance execution networks.

    <b>Exec Graph Outputs</b>

    These behave like outputs on a exec-node and are typically connected to an 
    output on a exec-node inside the exec-graph.
    '''
)
{
}

class ExecNode "ExecNode" (
    doc = '''Base class for all USD execution nodes. Exec-nodes are the building blocks
    of procedural networks.

    The purpose of representing them in Usd is two-fold:
    - To represent, via "connections" the topology of the procedural network
    that must be reconstructed in the engine. Facilities for authoring and 
    manipulating connections are encapsulated in the API schema 
    ExecConnectableAPI.
    - To present a (partial or full) interface of typed input parameters 
    whose values can be set and overridden in Usd, to be provided later at 
    run-time as parameter values to the actual procedural objects. Node 
    input parameters are encapsulated in the property schema ExecInput.
    '''
)
{
}

class "ExecConnectableAPI" (
    doc = """ExecConnectableAPI is an API schema that provides a common
    interface for creating outputs and making connections between 
    parameters and outputs. The interface is common to all UsdExec schemas
    that support Inputs and Outputs, which currently includes UsdExecNode,
    UsdExecGraph, and UsdExecBundle .

    One can construct a ExecConnectableAPI directly from a UsdPrim, or
    from objects of any of the schema classes listed above.  If it seems
    onerous to need to construct a secondary schema object to interact with
    Inputs and Outputs, keep in mind that any function whose purpose is either
    to walk material/shader networks via their connections, or to create such
    networks, can typically be written entirely in terms of 
    ExecConnectableAPI objects, without needing to care what the underlying
    prim type is.

    Additionally, the most common ExecConnectableAPI behaviors
    (creating Inputs and Outputs, and making connections) are wrapped as
    convenience methods on the prim schema classes (creation) and 
    UsdExecInput and UsdExecOutput.
    """
)
{
}

