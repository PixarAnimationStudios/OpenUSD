#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "TextLayoutAPI" (
    doc = """UsdTextTextLayoutAPI is an API schema that provides an interface for setting the layout of a text 
    primitive."""
)
{
    uniform token layout:baselineDirection = "upToImpl" (
        allowedTokens = ["upToImpl", "leftToRight", "rightToLeft", "topToBottom", "bottomToTop"]
        doc = "The direction of the baseline."
    )
    uniform token layout:linesStackDirection = "upToImpl" (
        allowedTokens = ["upToImpl", "leftToRight", "rightToLeft", "topToBottom", "bottomToTop"]
        doc = """The direction of the line stacking.
        If layout:baselineDirection is 'leftToRight' or 'rightToLeft', the layout:linesStackDirection can not be
        'leftToRight' or 'rightToLeft'. If layout:baselineDirection is 'topToBottom' or 'bottomToTop', the 
        layout:linesStackDirection can not be 'topToBottom' or 'bottomToTop'."""
    )
}

class ColumnStyle "ColumnStyle" (
    apiSchemas = ["TextLayoutAPI"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["layout:baselineDirection", "layout:linesStackDirection"]
    }
    doc = "Class for style of a column."
)
{
    uniform token columnAlignment = "top" (
        allowedTokens = ["top", "center", "bottom"]
        doc = """The position of the whole text primitive in the block. 
        A text primitive is commonly horizontally expanded. It will fill the horizontal space of the block 
        except the left margin and the right margin. So there is no horizontal alignment for a column. If the 
        height of the primitive is smaller than the height of the column, the column alignment will decide
        the position of the text primitive is at the top, at the center or at the bottom of the column.
        """
    )
    uniform float columnHeight = 0 (
        doc = "The height of the column."
    )
    uniform float2 columnOffset = (0, 0) (
        doc = "The 2D offset from the position of the text primitive to the top-left corner of this column."
    )
    uniform float columnWidth = 0 (
        doc = "The width of the column."
    )
    uniform token layout:baselineDirection = "upToImpl"
    uniform token layout:linesStackDirection = "upToImpl"
    uniform float4 margins = (0, 0, 0, 0) (
        doc = """The margins at the four direction. The order is left margin, right margin, top margin and 
        bottom margin."""
    )
}

class "ColumnStyleAPI" (
    doc = '''"UsdTextColumnStyleAPI is an API schema that provides an interface for binding column style to a text 
    primitive.'''
)
{
}

class ParagraphStyle "ParagraphStyle" (
    doc = "Class for style of a paragraph."
)
{
    uniform float firstLineIndent = 0 (
        doc = """The left indent in the first line.
        A text primitive is commonly horizontally expanded. By default, it will fill the horizontal space of a block.
        If the line is the first line of a paragraph, there will be a space before the left start of the line. The space
        is the first line indent. Even if the direction of the text is from right to left, the firstLineIndent is added
        to the left of the line.
        If the block has margins, the firstLineIndent will be on the right of the left margin."""
    )
    uniform float leftIndent = 0 (
        doc = """The left indent in a normal line.
        A text primitive is commonly horizontally expanded. By default, it will fill the horizontal space of a block.
        If the line is not the first line of a paragraph, we can define there is space before the left start of the line.
        And the space is the left indent. Even if the direction of the text is from right to left, the leftIndent is
        added to the left of the line.
        If the block has margins, the leftIndent will be on the right of the left margin."""
    )
    uniform float lineSpace = 0 (
        doc = "The space between lines."
    )
    uniform token lineSpaceType = "atLeast" (
        allowedTokens = ["exactly", "atLeast", "multiple"]
        doc = "The type of the lineSpace value."
    )
    uniform token paragraphAlignment = "left" (
        allowedTokens = ["left", "right", "center", "justify", "distributed"]
        doc = """The text alignment in the paragraph.
        A text primitive is commonly horizontally expanded. By default, it will fill the horizontal space of a block.
        If the width of a text line is smaller than the horizontal space, this alignment will decide how the characters
        are positioned. You can see the examples below:
        
        Alignment   |                                    text                                         |
        ----------- | ------------------------------------------------------------------------------- |
        left        | The quick brown fox jumps over the lazy dog.                                    |
        right       |                                    The quick brown fox jumps over the lazy dog. |
        center      |                  The quick brown fox jumps over the lazy dog.                   |
        justify     | The     quick      brown     fox     jumps     over      the     lazy      dog. |
        distributed | T h e  q u i c k  b r o w n  f o x  j u m p s  o v e r  t h e  l a z y  d o g . |
        """
    )
    uniform float paragraphSpace = 0 (
        doc = "The space after the paragraph."
    )
    uniform float rightIndent = 0 (
        doc = """The right indent in each line.
        A text primitive is commonly horizontally expanded. By default, it will fill the horizontal space of a block.
        But we can define there is space after the right end of the line. And the space is the right indent. Even if 
        the direction of the text is from right to left, the rightIndent is added to the right of the line.
        If the block has margins, the rightIndent will be on the left of the left margin."""
    )
    uniform float[] tabStopPositions (
        doc = "The positions for each tabstop."
    )
    uniform token[] tabStopTypes (
        allowedTokens = ["leftTab", "rightTab", "centerTab", "decimalTab"]
        doc = """The tabstop types.  You can see the examples below:
        
        tabStop type | position ->    ^            ^           |
        ------------ | --------------------------------------- |
        leftTab      |            apple        34.52           |
        rightTab     |                apple        34.52       |
        centerTab    |              apple        34.52         |
        decimalTab   |            apple          34.52         |
        """
    )
}

class "ParagraphStyleAPI" (
    doc = """UsdTextParagraphStyleAPI is an API schema that provides an interface for binding paragraph style to
    a text primitive."""
)
{
}

class MarkupText "MarkupText" (
    doc = """This primitive represents a text object which can have one line or multiple lines, and it can 
    have varied styles."""
)
{
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform string markup (
        doc = """The markup string data. It can contain markups. The markup language is specified
        in the markupLanguage attribute."""
    )
    uniform string markup:plain = "" (
        doc = """The string data for the primitive when the implementation can not support the 
        markupLanguage."""
    )
    uniform token markupLanguage = "plain" (
        allowedTokens = ["plain", "mtext"]
        doc = "The markup language."
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    uniform color3f primvars:backgroundColor (
        doc = "Background color for the text."
    )
    uniform float primvars:backgroundOpacity = 0 (
        doc = "Background opacity for the text."
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    uniform token textMetricsUnit = "worldUnit" (
        allowedTokens = ["worldUnit", "publishingPoint", "pixel"]
        doc = """The unit for the text related metrics, such as the unit of charHeight.
        If the value is 'pixel', the unit of text metrics will be the same as a pixel in the framebuffer. 
        If the value is 'publishingPoint', the unit will be the same as desktop publishing point, or 1/72
        of an inch on a screen's physical display. If textMetricsUnit is 'worldUnit'\", the unit will be 
        the same as the unit of the world space. 
        If the text primitive has billboard, the textMetricsUnit can only be 'pixel' or 'publishingPoint'.
        Otherwise, the textMetricsUnit can only be 'worldUnit'.
        """
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

