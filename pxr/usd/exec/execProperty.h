//
// Unlicensed 2022 benmalartre
//

#ifndef EXEC_PROPERTY_H
#define EXEC_PROPERTY_H

/// \file exec/execProperty.h

#include "pxr/pxr.h"
#include "pxr/usd/exec/api.h"
#include "pxr/base/tf/staticTokens.h"
#include "pxr/base/tf/token.h"
#include "pxr/base/tf/weakBase.h"
#include "pxr/base/vt/value.h"
#include "pxr/usd/ndr/property.h"
#include "pxr/usd/exec/execNode.h"

PXR_NAMESPACE_OPEN_SCOPE

// If additional types are added here, it's also worth trying to add a mapping
// to the equivalent Sdf type in the implementation file.
#define EXEC_PROPERTY_TYPE_TOKENS  \
    ((Bool,       "bool"))         \
    ((Int,        "int"))          \
    ((String,     "string"))       \
    ((Float,      "float"))        \
    ((Color,      "color"))        \
    ((Vector2,    "vector2"))      \
    ((Vector3,    "vector3"))      \
    ((Vector4,    "vector4"))      \
    ((Quaternion, "quaternion"))   \
    ((Rotation,   "rotation"))     \
    ((Matrix3,    "matrix3"))      \
    ((Matrix4,    "matrix4"))      \
    ((Token,      "token"))     

// Note: Metadata keys that are generated by parsers should start with
// "__SDR__" to reduce the risk of collision with metadata actually in the
// node.
#define EXEC_PROPERTY_METADATA_TOKENS                  \
    ((Label, "label"))                                 \
    ((Help, "help"))                                   \
    ((Page, "page"))                                   \
    ((RenderType, "renderType"))                       \
    ((Role, "role"))                                   \
    ((Widget, "widget"))                               \
    ((Hints, "hints"))                                 \
    ((Options, "options"))                             \
    ((IsDynamicArray, "isDynamicArray"))               \
    ((Connectable, "connectable"))                     \
    ((ValidConnectionTypes, "validConnectionTypes"))   \
    ((IsAssetIdentifier, "__SDR__isAssetIdentifier"))  \
    ((ImplementationName, "__SDR__implementationName"))\
    ((ExecUsdDefinitionType, "execUsdDefinitionType")) \
    ((DefaultInput, "__SDR__defaultinput"))            \
    ((Target, "__SDR__target"))                        \
    ((Colorspace, "__SDR__colorspace"))


// The following tokens are valid values for the metadata "role"
#define EXEC_PROPERTY_ROLE_TOKENS \
    ((None, "none"))

TF_DECLARE_PUBLIC_TOKENS(ExecPropertyTypes, EXEC_API, EXEC_PROPERTY_TYPE_TOKENS);
TF_DECLARE_PUBLIC_TOKENS(ExecPropertyMetadata, EXEC_API, EXEC_PROPERTY_METADATA_TOKENS);
TF_DECLARE_PUBLIC_TOKENS(ExecPropertyRole, EXEC_API, EXEC_PROPERTY_ROLE_TOKENS);

/// \class ExecProperty
///
/// A specialized version of `NdrProperty` which holds shading information.
///
class ExecProperty : public NdrProperty
{
public:
    // Constructor.
    EXEC_API
    ExecProperty(
        const TfToken& name,
        const TfToken& type,
        const VtValue& defaultValue,
        bool isOutput,
        size_t arraySize,
        const NdrTokenMap& metadata,
        const NdrTokenMap& hints,
        const NdrOptionVec& options
    );

    /// \name Metadata
    /// The metadata returned here is a direct result of what the parser plugin
    /// is able to determine about the property. See the documentation for a
    /// specific parser plugin to get help on what the parser is looking for to
    /// populate these values.
    /// @{

    /// The label assigned to this property, if any. Distinct from the name
    /// returned from `GetName()`. In the context of a UI, the label value
    /// might be used as the display name for the property instead of the name.
    EXEC_API
    const TfToken& GetLabel() const { return _label; }

    /// The help message assigned to this property, if any.
    EXEC_API
    std::string GetHelp() const;

    /// The page (group), eg "Advanced", this property appears on, if any.
    EXEC_API
    const TfToken& GetPage() const { return _page; }

    /// The widget "hint" that indicates the widget that can best display the
    /// type of data contained in this property, if any. Examples of this value
    /// could include "number", "slider", etc.
    EXEC_API
    const TfToken& GetWidget() const { return _widget; }

    /// Any UI "hints" that are associated with this property. "Hints" are
    /// simple key/value pairs.
    EXEC_API
    const NdrTokenMap& GetHints() const { return _hints; }

    /// If the property has a set of valid values that are pre-determined, this
    /// will return the valid option names and corresponding string values (if
    /// the option was specified with a value).
    EXEC_API
    const NdrOptionVec& GetOptions() const { return _options; }

    /// Returns the implementation name of this property.  The name of the
    /// property is how to refer to the property in node networks.  The
    /// label is how to present this property to users.  The implementation
    /// name is the name of the parameter this property represents in the
    /// implementation.  Any client using the implementation \b must call
    /// this method to get the correct name;  using \c getName() is not
    /// correct.
    EXEC_API
    std::string GetImplementationName() const;

    /// @}

    /// \name Connection Information
    /// @{

    /// Whether this property can be connected to other properties. If this
    /// returns `true`, connectability to a specific property can be tested via
    /// `CanConnectTo()`.
    EXEC_API
    bool IsConnectable() const override { return _isConnectable; }

    /// Gets the list of valid connection types for this property. This value
    /// comes from node metadata, and may not be specified. The value from
    /// `NdrProperty::GetType()` can be used as a fallback, or you can use the
    /// connectability test in `CanConnectTo()`.
    EXEC_API
    const NdrTokenVec& GetValidConnectionTypes() const {
        return _validConnectionTypes;
    }

    /// Determines if this property can be connected to the specified property.
    EXEC_API
    bool CanConnectTo(const NdrProperty& other) const override;

    /// @}


    /// \name Utilities
    /// @{

    /// Converts the property's type from `GetType()` into a `SdfValueTypeName`.
    ///
    /// Two scenarios can result: an exact mapping from property type to Sdf
    /// type, and an inexact mapping. In the first scenario, the first element
    /// in the pair will be the cleanly-mapped Sdf type, and the second element,
    /// a TfToken, will be empty. In the second scenario, the Sdf type will be
    /// set to `Token` to indicate an unclean mapping, and the second element
    /// will be set to the original type returned by `GetType()`.
    ///
    /// \sa GetDefaultValueAsSdfType
    EXEC_API
    const NdrSdfTypeIndicator GetTypeAsSdfType() const override;

    /// Accessor for default value corresponding to the SdfValueTypeName
    /// returned by GetTypeAsSdfType. Note that this could be different than
    /// value returned by GetDefaultValue.
    ///
    /// \sa GetTypeAsSdfType
    EXEC_API
    const VtValue& GetDefaultValueAsSdfType() const override {
        return _sdfTypeDefaultValue;
    }

    /// Determines if the value held by this property is an asset identifier
    /// (eg, a file path); the logic for this is left up to the parser.
    ///
    /// Note: The type returned from `GetTypeAsSdfType()` will be `Asset` if
    /// this method returns `true` (even though its true underlying data type
    /// is string).
    EXEC_API
    bool IsAssetIdentifier() const;

    /// Determines if the value held by this property is the default input 
    /// for this node.
    EXEC_API
    bool IsDefaultInput() const;

    /// @}

protected:
    ExecProperty& operator=(const ExecProperty&) = delete;

    // Allow the node's post process function to access the property's
    // internals. Some property information can only be determined after parse
    // time.
    friend void ExecNode::_PostProcessProperties();

    // This function is called by ExecNode::_PostProcessProperties once all
    // information is locked in and won't be changed anymore. This allows each
    // property to take some extra steps once all information is available.
    void _FinalizeProperty();

    // Some metadata values cannot be returned by reference from the main
    // metadata dictionary because they need additional parsing.
    const NdrTokenMap _hints;
    const NdrOptionVec _options;

    // Tokenized metadata
    NdrTokenVec _validConnectionTypes;
    TfToken _label;
    TfToken _page;
    TfToken _widget;

    VtValue _sdfTypeDefaultValue;
};

PXR_NAMESPACE_CLOSE_SCOPE

#endif // PXR_USD_SDR_SHADER_PROPERTY_H
