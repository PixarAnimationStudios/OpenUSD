-- glslfx version 0.1

//
// Copyright 2020 benmalartre
//
// Unlicensed
//

#import $TOOLS/LoFi/shaders/camera.glslfx

--- --------------------------------------------------------------------------
-- glsl Mesh.Vertex

void main()
{
  mat4 viewModel = GetViewMatrix() * GetModelMatrix();
  vec4 p = viewModel * vec4(LOFI_GET_position(), 1.0);
  vec4 n = viewModel * vec4(LOFI_GET_normal(), 0.0);
  gl_Position = GetProjectionMatrix() * p;
  LOFI_SET_color(LOFI_GET_color());
  LOFI_SET_position(p.xyz);
  LOFI_SET_normal(n.xyz);
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment
void main()
{
 bool isFlipped = IsFlipped();

  if (ShouldCullFaceAccordingToShading(gl_FrontFacing, isFlipped)) {
    discard;
  }

  DiscardBasedOnTopologicalVisibility();

  vec4 color = vec4(0.5, 0.5, 0.5, 1);
#ifdef HD_HAS_color
  color.rgb = LOFI_GET_color().rgb;
#endif
#ifdef HD_HAS_opacity
  color.a = HdGet_opacity().r;
#endif

  vec3 Peye = inData.Peye.xyz / inData.Peye.w;

  vec3 Neye = inData.Neye;
  // Normalize Neye after rasterizer interpolation.
  if (length(Neye) > 0.0) {
      Neye = normalize(Neye);
  }

  /*
  // Give the shader key a chance to override the normal.
  Neye = GetNormal(Neye, 0);
  // Orient the normal for shading.
  Neye = GetShadingNormal(Neye, isFlipped);

  vec4 patchCoord = GetPatchCoord();
  color = ShadingTerminal(vec4(Peye, 1), Neye, color, patchCoord);

  color = ApplyEdgeColor(color, patchCoord);

  if (ShouldDiscardByAlpha(color)) {
      discard;
  }
  */

  RenderOutput(vec4(Peye, 1), Neye, color, patchCoord);
}