-- glslfx version 0.1

//
// Copyright 2020 benmalartre
//
// Unlicensed 
//

#import $TOOLS/LoFi/shaders/common.glslfx

--- --------------------------------------------------------------------------
-- configuration
{
    "techniques": {
        "default": {
            "vertex": {
                "source": [ "Common.Camera",
                            "Contour.Vertex" ]
            },
            "geometry": {
              "source": [ "Common.Camera",
                            "Contour.Geometry" ]
            },
            "fragment": {
                "source": [ "Common.Camera",
                            "Contour.Fragment" ]
            }
        }
    }
}

--- --------------------------------------------------------------------------
-- glsl Contour.Vertex

void main()
{
  mat4 projViewModel = GetProjectionMatrix() * GetViewMatrix() * GetModelMatrix();
  vec4 p = projViewModel * vec4(LOFI_GET_position(), 1.0);
  vec4 n = projViewModel * vec4(LOFI_GET_normal(), 0.0);
  gl_Position = p;

  LOFI_SET_color(LOFI_GET_color());
  LOFI_SET_position(p.xyz/p.w);
  LOFI_SET_normal(n.xyz/p.w);
}


--- --------------------------------------------------------------------------
-- glsl Contour.Geometry

layout(triangles_adjacency) in;
layout(triangle_strip, max_vertices = 12) out;
//layout(points, max_vertices=6) out;
//layout(line_strip, max_vertices=6) out;


bool IsFront(vec4 A, vec4 B, vec4 C)
{
    float area = (A.x * B.y - B.x * A.y) + (B.x * C.y - C.x * B.y) + (C.x * A.y - A.x * C.y);
    return area > 0;
}

void EmitEdge(vec4 P0, vec4 P1, vec3 N0, vec3 N1)
{
    float halfWidth = 0.1;
    vec2 V = normalize(P1.xy - P0.xy);
    vec3 N = vec3(vec2(-V.y, V.x) * halfWidth, 0);

    gl_Position = vec4(P0.xyz / P0.w - N / P0.w, 1); EmitVertex();
    gl_Position = vec4(P0.xyz / P0.w + N / P0.w, 1); EmitVertex();
    gl_Position = vec4(P1.xyz / P1.w - N / P1.w, 1); EmitVertex();
    gl_Position = vec4(P1.xyz / P1.w + N / P1.w, 1); EmitVertex();
    
    EndPrimitive();
}

void main()
{
    /*
    vec3 v0 = LOFI_GET_position(0);
    vec3 v1 = LOFI_GET_position(1);
    vec3 v2 = LOFI_GET_position(2);
    vec3 v3 = LOFI_GET_position(3);
    vec3 v4 = LOFI_GET_position(4);
    vec3 v5 = LOFI_GET_position(5);
    */
    vec4 v0 = gl_in[0].gl_Position;
    vec4 v1 = gl_in[1].gl_Position;
    vec4 v2 = gl_in[2].gl_Position;
    vec4 v3 = gl_in[3].gl_Position;
    vec4 v4 = gl_in[4].gl_Position;
    vec4 v5 = gl_in[5].gl_Position;

    vec3 n0 = LOFI_GET_normal(0);
    vec3 n1 = LOFI_GET_normal(1);
    vec3 n2 = LOFI_GET_normal(2);
    vec3 n3 = LOFI_GET_normal(3);
    vec3 n4 = LOFI_GET_normal(4);
    vec3 n5 = LOFI_GET_normal(5);

    if (IsFront(v0, v2, v4)) {
        if (!IsFront(v0, v1, v2)) EmitEdge(v0, v2, n0, n2);
        if (!IsFront(v2, v3, v4)) EmitEdge(v2, v4, n2, n4);
        if (!IsFront(v0, v4, v5)) EmitEdge(v4, v0, n4, n0);
    } 

}

/*
bool IsFront(vec2 A, vec2 B, vec2 C)
{
    return 0 < (A.x * B.y - B.x * A.y) + (B.x * C.y - C.x * B.y) + (C.x * A.y - A.x * C.y);
}

void EmitEdge(vec2 P0, vec2 P1)
{
    float halfWidth = 0.002;
    vec2 V = normalize(P1 - P0);
    vec2 N = vec2(-V.y, V.x) * halfWidth;

    gl_Position = vec4(P0 - N, 0, 1); EmitVertex();
    gl_Position = vec4(P0 + N, 0, 1); EmitVertex();
    gl_Position = vec4(P1 - N, 0, 1); EmitVertex();
    gl_Position = vec4(P1 + N, 0, 1); EmitVertex();
    EndPrimitive();
}

void main()
{
    vec2 v0 = LOFI_GET_position(0).xy;
    vec2 v1 = LOFI_GET_position(1).xy;
    vec2 v2 = LOFI_GET_position(2).xy;
    vec2 v3 = LOFI_GET_position(3).xy;
    vec2 v4 = LOFI_GET_position(4).xy;
    vec2 v5 = LOFI_GET_position(5).xy;
     
    if (IsFront(v0, v2, v4)) {
        if (!IsFront(v0, v1, v2)) EmitEdge(v0, v2);
        if (!IsFront(v2, v3, v4)) EmitEdge(v2, v4);
        if (!IsFront(v0, v4, v5)) EmitEdge(v4, v0);
    }
}
*/


--- --------------------------------------------------------------------------
-- glsl Contour.Fragment
void main()
{
  LOFI_SET_result(vec4(0.0,0.0,0.0,1.0));
}
