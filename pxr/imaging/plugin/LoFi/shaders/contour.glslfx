-- glslfx version 0.1

//
// Copyright 2020 benmalartre
//
// Unlicensed 
//

#import $TOOLS/LoFi/shaders/common.glslfx

--- --------------------------------------------------------------------------
-- configuration
{
    "techniques": {
        "default": {
            "vertex": {
                "source": [ "Common.Camera",
                            "Contour.Vertex" ]
            },
            "geometry": {
              "source": [ "Common.Camera",
                            "Contour.Geometry" ]
            },
            "fragment": {
                "source": [ "Common.Camera",
                            "Contour.Fragment" ]
            }
        }
    }
}

--- --------------------------------------------------------------------------
-- glsl Contour.Vertex

void main()
{
  mat4 projViewModel = GetProjectionMatrix() * GetViewMatrix() * GetModelMatrix();
  vec4 p = projViewModel * vec4(LOFI_GET_position(), 1.0);
  vec4 n = projViewModel * vec4(LOFI_GET_normal(), 0.0);
  gl_Position = p;

  LOFI_SET_color(LOFI_GET_color());
  LOFI_SET_position(p.xyz/p.w);
  LOFI_SET_normal(n.xyz/p.w);
}


--- --------------------------------------------------------------------------
-- glsl Contour.Geometry

layout(triangles_adjacency) in;
//layout(triangle_strip, max_vertices = 12) out;
//layout(points, max_vertices=6) out;
layout(line_strip, max_vertices=6) out;


bool IsFront(vec3 A, vec3 B, vec3 C)
{
    float area = (A.x * B.y - B.x * A.y) + (B.x * C.y - C.x * B.y) + (C.x * A.y - A.x * C.y);
    return area > 0;
}

void EmitEdge(vec3 P0, vec3 P1, vec3 N0, vec3 N1)
{
    float width = 1;
    gl_Position = vec4(P0 + N0 * width, 1); EmitVertex();
    gl_Position = vec4(P1 + N1 * width, 1); EmitVertex();
    EndPrimitive();

    /*
    float halfWidth = GetViewportSize().y * (GetProjectionMatrix()[1][1] * width / (P0.z+P1.z)*0.5);
    vec3 sN0 = N0 * halfWidth;
    vec3 sN1 = N1 * halfWidth;

    gl_Position = vec4(P0 - sN0, 1); EmitVertex();
    gl_Position = vec4(P0 + sN0, 1); EmitVertex();
    gl_Position = vec4(P1 - sN1, 1); EmitVertex();
    gl_Position = vec4(P1 + sN1, 1); EmitVertex();
    */
    EndPrimitive();
}

void EmitNormal(vec3 P, vec3 N)
{
    gl_Position = vec4(P,1); EmitVertex();
    gl_Position = vec4(P+N,1); EmitVertex();
    EndPrimitive();
}

void EmitCorner(vec3 P)
{
    gl_Position = vec4(P,1); EmitVertex();
    EndPrimitive();
}

void EmitMitter(vec3 P1, vec3 P2, vec3 P3, vec3 P4)
{

    vec3 N1 = cross(P2-P1, P3-P1);
    vec3 N2 = cross(P2-P1, P4-P1);

    gl_Position = vec4(P1 + N1, 1); EmitVertex();
    EndPrimitive();
    gl_Position = vec4(P1 + N2, 1); EmitVertex();
    EndPrimitive();

    gl_Position = vec4(P2 + N1, 1); EmitVertex();
    EndPrimitive();
    gl_Position = vec4(P2 + N2, 1); EmitVertex();
    EndPrimitive();

}

void main()
{
    vec3 v0 = LOFI_GET_position(0);
    vec3 v1 = LOFI_GET_position(1);
    vec3 v2 = LOFI_GET_position(2);
    vec3 v3 = LOFI_GET_position(3);
    vec3 v4 = LOFI_GET_position(4);
    vec3 v5 = LOFI_GET_position(5);

    vec3 n0 = LOFI_GET_normal(0);
    vec3 n1 = LOFI_GET_normal(1);
    vec3 n2 = LOFI_GET_normal(2);
    vec3 n3 = LOFI_GET_normal(3);
    vec3 n4 = LOFI_GET_normal(4);
    vec3 n5 = LOFI_GET_normal(5);

    EmitEdge(v0, v2, n0, n2);
    EmitEdge(v2, v4, n2, n4);
    EmitEdge(v4, v0, n4, n0);

    /*
    //EmitNormal((v0+v2+v4)*0.333, (n0+n2+n4)*0.333);

    EmitCorner(v0);
    EmitCorner(v1);
    EmitCorner(v2);
    
    EmitMitter(v0,v2,v4,v1);
    EmitMitter(v2,v4,v0,v3);
    EmitMitter(v4,v0,v2,v5);
    
    if (IsFront(v0, v2, v4)) {
        if (!IsFront(v0, v1, v2)) EmitEdge(v0, v2, n0, n2);
        if (!IsFront(v2, v3, v4)) EmitEdge(v2, v4, n2, n4);
        if (!IsFront(v0, v4, v5)) EmitEdge(v4, v0, n4, n0);
    } 
    */
}

/*
bool IsFront(vec2 A, vec2 B, vec2 C)
{
    return 0 < (A.x * B.y - B.x * A.y) + (B.x * C.y - C.x * B.y) + (C.x * A.y - A.x * C.y);
}

void EmitEdge(vec2 P0, vec2 P1)
{
    float halfWidth = 0.01;
    vec2 V = normalize(P1 - P0);
    vec2 N = vec2(-V.y, V.x) * halfWidth;

    gl_Position = vec4(P0 - N, 0, 1); EmitVertex();
    gl_Position = vec4(P0 + N, 0, 1); EmitVertex();
    gl_Position = vec4(P1 - N, 0, 1); EmitVertex();
    gl_Position = vec4(P1 + N, 0, 1); EmitVertex();
    EndPrimitive();
}

void main()
{
    vec2 v0 = LOFI_GET_position(0).xy;
    vec2 v1 = LOFI_GET_position(1).xy;
    vec2 v2 = LOFI_GET_position(2).xy;
    vec2 v3 = LOFI_GET_position(3).xy;
    vec2 v4 = LOFI_GET_position(4).xy;
    vec2 v5 = LOFI_GET_position(5).xy;
     
    if (IsFront(v0, v2, v4)) {
        if (!IsFront(v0, v1, v2)) EmitEdge(v0, v2);
        if (!IsFront(v2, v3, v4)) EmitEdge(v2, v4);
        if (!IsFront(v0, v4, v5)) EmitEdge(v4, v0);
    }
}
*/


--- --------------------------------------------------------------------------
-- glsl Contour.Fragment
void main()
{
  LOFI_SET_result(vec4(1.0,0.0,0.0,1.0));
}
