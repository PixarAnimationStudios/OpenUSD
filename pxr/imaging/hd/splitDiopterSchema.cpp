//
// Copyright 2023 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
////////////////////////////////////////////////////////////////////////

/* ************************************************************************** */
/* ** This file is generated by a script.  Do not edit directly.  Edit     ** */
/* ** defs.py or the (*)Schema.template.cpp files to make changes.         ** */
/* ************************************************************************** */

#include "pxr/imaging/hd/splitDiopterSchema.h"
#include "pxr/imaging/hd/retainedDataSource.h"
#include "pxr/imaging/hd/cameraSchema.h"

#include "pxr/base/trace/trace.h"


PXR_NAMESPACE_OPEN_SCOPE

TF_DEFINE_PUBLIC_TOKENS(HdSplitDiopterSchemaTokens,
    HDSPLITDIOPTER_SCHEMA_TOKENS);



HdIntDataSourceHandle
HdSplitDiopterSchema::GetCount()
{
    return _GetTypedDataSource<HdIntDataSource>(
        HdSplitDiopterSchemaTokens->count);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetAngle()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->angle);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetOffset1()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->offset1);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetWidth1()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->width1);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetFocusDistance1()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->focusDistance1);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetOffset2()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->offset2);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetWidth2()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->width2);
}

HdFloatDataSourceHandle
HdSplitDiopterSchema::GetFocusDistance2()
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdSplitDiopterSchemaTokens->focusDistance2);
}

/*static*/
HdContainerDataSourceHandle
HdSplitDiopterSchema::BuildRetained(
        const HdIntDataSourceHandle &count,
        const HdFloatDataSourceHandle &angle,
        const HdFloatDataSourceHandle &offset1,
        const HdFloatDataSourceHandle &width1,
        const HdFloatDataSourceHandle &focusDistance1,
        const HdFloatDataSourceHandle &offset2,
        const HdFloatDataSourceHandle &width2,
        const HdFloatDataSourceHandle &focusDistance2
)
{
    TfToken _names[8];
    HdDataSourceBaseHandle _values[8];

    size_t _count = 0;
    if (count) {
        _names[_count] = HdSplitDiopterSchemaTokens->count;
        _values[_count++] = count;
    }

    if (angle) {
        _names[_count] = HdSplitDiopterSchemaTokens->angle;
        _values[_count++] = angle;
    }

    if (offset1) {
        _names[_count] = HdSplitDiopterSchemaTokens->offset1;
        _values[_count++] = offset1;
    }

    if (width1) {
        _names[_count] = HdSplitDiopterSchemaTokens->width1;
        _values[_count++] = width1;
    }

    if (focusDistance1) {
        _names[_count] = HdSplitDiopterSchemaTokens->focusDistance1;
        _values[_count++] = focusDistance1;
    }

    if (offset2) {
        _names[_count] = HdSplitDiopterSchemaTokens->offset2;
        _values[_count++] = offset2;
    }

    if (width2) {
        _names[_count] = HdSplitDiopterSchemaTokens->width2;
        _values[_count++] = width2;
    }

    if (focusDistance2) {
        _names[_count] = HdSplitDiopterSchemaTokens->focusDistance2;
        _values[_count++] = focusDistance2;
    }

    return HdRetainedContainerDataSource::New(_count, _names, _values);
}

/*static*/
HdSplitDiopterSchema
HdSplitDiopterSchema::GetFromParent(
        const HdContainerDataSourceHandle &fromParentContainer)
{
    return HdSplitDiopterSchema(
        fromParentContainer
        ? HdContainerDataSource::Cast(fromParentContainer->Get(
                HdSplitDiopterSchemaTokens->splitDiopter))
        : nullptr);
}

/*static*/
const TfToken &
HdSplitDiopterSchema::GetSchemaToken()
{
    return HdSplitDiopterSchemaTokens->splitDiopter;
}

/*static*/
const HdDataSourceLocator &
HdSplitDiopterSchema::GetDefaultLocator()
{
    static const HdDataSourceLocator locator(
        HdCameraSchemaTokens->camera,
        HdSplitDiopterSchemaTokens->splitDiopter
    );
    return locator;
} 
HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetCount(
    const HdIntDataSourceHandle &count)
{
    _count = count;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetAngle(
    const HdFloatDataSourceHandle &angle)
{
    _angle = angle;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetOffset1(
    const HdFloatDataSourceHandle &offset1)
{
    _offset1 = offset1;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetWidth1(
    const HdFloatDataSourceHandle &width1)
{
    _width1 = width1;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetFocusDistance1(
    const HdFloatDataSourceHandle &focusDistance1)
{
    _focusDistance1 = focusDistance1;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetOffset2(
    const HdFloatDataSourceHandle &offset2)
{
    _offset2 = offset2;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetWidth2(
    const HdFloatDataSourceHandle &width2)
{
    _width2 = width2;
    return *this;
}

HdSplitDiopterSchema::Builder &
HdSplitDiopterSchema::Builder::SetFocusDistance2(
    const HdFloatDataSourceHandle &focusDistance2)
{
    _focusDistance2 = focusDistance2;
    return *this;
}

HdContainerDataSourceHandle
HdSplitDiopterSchema::Builder::Build()
{
    return HdSplitDiopterSchema::BuildRetained(
        _count,
        _angle,
        _offset1,
        _width1,
        _focusDistance1,
        _offset2,
        _width2,
        _focusDistance2
    );
}


PXR_NAMESPACE_CLOSE_SCOPE