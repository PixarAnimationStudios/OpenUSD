-- glslfx version 0.1

// File Generated with HdStMaterialXShaderGen.

#import $TOOLS/hdSt/shaders/surfaceHelpers.glslfx

-- configuration
{
    "metadata": {
        "materialTag": "defaultMaterialTag"
    }, 
    "textures": {
        "roughness": {
        },
        "diffuseColor": {
        }
    }, 
    "techniques": {
        "default": {
            "surfaceShader": { 
                "source": [ "SurfaceHelpers.TangentSpace",
                            "MaterialX.Surface" ]
            }
        }
    }
}

-- glsl MaterialX.Surface


#define M_FLOAT_EPS 1e-8

float mx_square(float x)
{
    return x*x;
}

vec2 mx_square(vec2 x)
{
    return x*x;
}

vec3 mx_square(vec3 x)
{
    return x*x;
}
#if NUM_LIGHTS > 0
#define MAX_LIGHT_SOURCES NUM_LIGHTS
#else
#define MAX_LIGHT_SOURCES 1
#endif
#define DIRECTIONAL_ALBEDO_METHOD 0

struct BSDF { vec3 response; vec3 throughput; float thickness; float ior; };
#define EDF vec3
struct surfaceshader { vec3 color; vec3 transparency; };
struct volumeshader { vec3 color; vec3 transparency; };
struct displacementshader { vec3 offset; float scale; };
struct lightshader { vec3 intensity; vec3 direction; };
#define material surfaceshader

// Uniform block: PublicUniforms
vec3 emissiveColor;
int useSpecularWorkflow;
vec3 specularColor;
float metallic;
float clearcoat;
float clearcoatRoughness;
float opacity;
float opacityThreshold;
float ior;
vec3 normal;
float displacement;
float occlusion;
vec3 image_color_default;
vec2 image_color_uvtiling;
vec2 image_color_uvoffset;
vec2 image_color_realworldimagesize;
vec2 image_color_realworldtilesize;
int image_color_filtertype;
int image_color_framerange = 0;
int image_color_frameoffset;
int image_color_frameendaction;
float image_roughness_default;
vec2 image_roughness_uvtiling;
vec2 image_roughness_uvoffset;
vec2 image_roughness_realworldimagesize;
vec2 image_roughness_realworldtilesize;
int image_roughness_filtertype;
int image_roughness_framerange = 0;
int image_roughness_frameoffset;
int image_roughness_frameendaction;

// Uniform block: PrivateUniforms
float u_alphaThreshold = 0.001000;
mat4 u_envMatrix = mat4(-1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);
int u_envRadianceMips;
int u_envRadianceSamples;
bool u_refractionTwoSided = false;
vec3 u_viewPosition;
int u_numActiveLightSources = 0;

#ifdef HD_HAS_domeLightIrradiance
#define u_envRadiance HdGetSampler_domeLightPrefilter() 
#define u_envIrradiance HdGetSampler_domeLightIrradiance() 
#else
#define u_envRadiance HdGetSampler_domeLightFallback()
#define u_envIrradiance HdGetSampler_domeLightFallback()
#endif

// Define MaterialX to Hydra Sampler mappings
#define image_roughness_file HdGetSampler_roughness()
#define image_color_file HdGetSampler_diffuseColor()

struct LightData
{
    int type;
    vec3 position;
    vec3 color;
    float intensity;
    float decay_rate;
    vec3 direction;
    float shadowOcclusion;
};

LightData u_lightData[MAX_LIGHT_SOURCES];


// MaterialX's VertexData
struct mxVertexData
{
    vec2 texcoord_0;
    vec3 tangentWorld;
    vec3 normalWorld;
    vec3 positionWorld;
};
mxVertexData vd;


void mxInit(vec4 Peye, vec3 Neye)
{
    // Convert HdData to MxData
    u_viewPosition = vec3(HdGet_worldToViewInverseMatrix() * vec4(0.0, 0.0, 0.0, 1.0));

    // Calculate the worldspace position and normal vectors
    vec3 positionWorld = vec3(HdGet_worldToViewInverseMatrix() * Peye);
    vec3 normalWorld = vec3(HdGet_worldToViewInverseMatrix() * vec4(Neye, 0.0));

    // Calculate the worldspace tangent vector 
#ifdef HD_HAS_st
    vec3 tangentWorld = ComputeTangentVector(positionWorld, normalWorld, HdGet_st());
#else 
    vec3 tangentWorld = cross(normalWorld, vec3(0, 1, 0));
    if (length(tangentWorld) < M_FLOAT_EPS) {
        tangentWorld = cross(normalWorld, vec3(1, 0, 0));
    }
#endif

    vd = mxVertexData(
    #ifdef HD_HAS_st
        HdGet_st(),
    #else
        vec2(0.0),
    #endif
        tangentWorld,normalWorld,positionWorld);

    // Initialize Material Parameters
    emissiveColor = HdGet_emissiveColor();
    useSpecularWorkflow = HdGet_useSpecularWorkflow();
    specularColor = HdGet_specularColor();
    metallic = HdGet_metallic();
    clearcoat = HdGet_clearcoat();
    clearcoatRoughness = HdGet_clearcoatRoughness();
    opacity = HdGet_opacity();
    opacityThreshold = HdGet_opacityThreshold();
    ior = HdGet_ior();
    normal = HdGet_normal();
    displacement = HdGet_displacement();
    occlusion = HdGet_occlusion();
    image_color_default = HdGet_image_color_default();
    image_color_uvtiling = HdGet_image_color_uvtiling();
    image_color_uvoffset = HdGet_image_color_uvoffset();
    image_color_realworldimagesize = HdGet_image_color_realworldimagesize();
    image_color_realworldtilesize = HdGet_image_color_realworldtilesize();
    image_color_filtertype = HdGet_image_color_filtertype();
    image_color_frameoffset = HdGet_image_color_frameoffset();
    image_color_frameendaction = HdGet_image_color_frameendaction();
    image_roughness_default = HdGet_image_roughness_default();
    image_roughness_uvtiling = HdGet_image_roughness_uvtiling();
    image_roughness_uvoffset = HdGet_image_roughness_uvoffset();
    image_roughness_realworldimagesize = HdGet_image_roughness_realworldimagesize();
    image_roughness_realworldtilesize = HdGet_image_roughness_realworldtilesize();
    image_roughness_filtertype = HdGet_image_roughness_filtertype();
    image_roughness_frameoffset = HdGet_image_roughness_frameoffset();
    image_roughness_frameendaction = HdGet_image_roughness_frameendaction();

    // Initialize Indirect Light Textures and values
    u_envRadianceMips = textureQueryLevels(u_envRadiance);

    mat4 hdTransformationMatrix = mat4(1.0);
#if NUM_LIGHTS > 0
    for (int i = 0; i < NUM_LIGHTS; ++i) {
        LightSource light = GetLightSource(i);

        // Save the indirect light transformation
        if (light.isIndirectLight) {
            hdTransformationMatrix = light.worldToLightTransform;
        }
        // Save the direct light data
        else {
            // Light Type and Position/Direction
            // Distant lights have Hydra attenuation = vec3(0.0, 0.0, 0.0)
            if (light.attenuation.x == 0.0 && light.attenuation.y == 0.0 && 
                light.attenuation.z == 0.0) {
                u_lightData[u_numActiveLightSources].type = 2; // directional

                // Direction (Hydra position in ViewSpace)
                u_lightData[u_numActiveLightSources].direction = 
                    (HdGet_worldToViewInverseMatrix() * -light.position).xyz;
            }
            // Treat all other lights as Point lights
            else {
                u_lightData[u_numActiveLightSources].type = 1; // point

                // Position (Hydra position in ViewSpace)
                u_lightData[u_numActiveLightSources].position = 
                    (HdGet_worldToViewInverseMatrix() * light.position).xyz;
            }

            // Color and Intensity 
            // Note: in Storm, diffuse = lightColor * intensity;
            float intensity = max( max(light.diffuse.r, light.diffuse.g), 
                                   light.diffuse.b);
            u_lightData[u_numActiveLightSources].color = light.diffuse.rgb/intensity;
            u_lightData[u_numActiveLightSources].intensity = intensity;
            
            // Attenuation 
            // Hydra: vec3(const, linear, quadratic)
            // MaterialX: const = 0.0, linear = 1.0, quadratic = 2.0
            if (light.attenuation.z > 0) {
                u_lightData[u_numActiveLightSources].decay_rate = 2.0;
            }
            else if (light.attenuation.y > 0) {
                u_lightData[u_numActiveLightSources].decay_rate = 1.0;
            }
            else {
                u_lightData[u_numActiveLightSources].decay_rate = 0.0;
            }

            // ShadowOcclusion value
            #if USE_SHADOWS
                u_lightData[u_numActiveLightSources].shadowOcclusion = 
                    light.hasShadow ? shadowing(i, Peye) : 1.0;
            #else 
                u_lightData[u_numActiveLightSources].shadowOcclusion = 1.0;
            #endif

            u_numActiveLightSources++;
        }
    }
#endif
    u_envMatrix = u_envMatrix * hdTransformationMatrix;
}

#define M_PI 3.1415926535897932
#define M_PI_INV (1.0 / M_PI)

float mx_pow5(float x)
{
    return mx_square(mx_square(x)) * x;
}

// Standard Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}
vec3 mx_fresnel_schlick(float cosTheta, vec3 F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}

// Generalized Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0, float F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}
vec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}

// Generalized Schlick Fresnel with a variable exponent
float mx_fresnel_schlick(float cosTheta, float F0, float F90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(F0, F90, pow(x, exponent));
}
vec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(F0, F90, pow(x, exponent));
}

// Enforce that the given normal is forward-facing from the specified view direction.
vec3 mx_forward_facing_normal(vec3 N, vec3 V)
{
    return (dot(N, V) < 0.0) ? -N : N;
}

// https://www.graphics.rwth-aachen.de/publication/2/jgt.pdf
float mx_golden_ratio_sequence(int i)
{
    const float GOLDEN_RATIO = 1.6180339887498948;
    return fract((float(i) + 1.0) * GOLDEN_RATIO);
}

// https://people.irisa.fr/Ricardo.Marques/articles/2013/SF_CGF.pdf
vec2 mx_spherical_fibonacci(int i, int numSamples)
{
    return vec2((float(i) + 0.5) / float(numSamples), mx_golden_ratio_sequence(i));
}

// Generate a uniform-weighted sample in the unit hemisphere.
vec3 mx_uniform_sample_hemisphere(vec2 Xi)
{
    float phi = 2.0 * M_PI * Xi.x;
    float cosTheta = 1.0 - Xi.y;
    float sinTheta = sqrt(1.0 - mx_square(cosTheta));
    return vec3(cos(phi) * sinTheta,
                sin(phi) * sinTheta,
                cosTheta);
}

// Fresnel model options.
const int FRESNEL_MODEL_DIELECTRIC = 0;
const int FRESNEL_MODEL_CONDUCTOR = 1;
const int FRESNEL_MODEL_SCHLICK = 2;
const int FRESNEL_MODEL_AIRY = 3;
const int FRESNEL_MODEL_SCHLICK_AIRY = 4;

// XYZ to CIE 1931 RGB color space (using neutral E illuminant)
const mat3 XYZ_TO_RGB = mat3(2.3706743, -0.5138850, 0.0052982, -0.9000405, 1.4253036, -0.0146949, -0.4706338, 0.0885814, 1.0093968);

// Parameters for Fresnel calculations.
struct FresnelData
{
    int model;

    // Physical Fresnel
    vec3 ior;
    vec3 extinction;

    // Generalized Schlick Fresnel
    vec3 F0;
    vec3 F90;
    float exponent;

    // Thin film
    float tf_thickness;
    float tf_ior;

    // Refraction
    bool refraction;

#ifdef __METAL__ 
FresnelData(int   _model        = 0, 
            vec3  _ior          = vec3(0.0f),
            vec3  _extinction   = vec3(0.0f),
            vec3  _F0           = vec3(0.0f),
            vec3  _F90          = vec3(0.0f),
            float _exponent     = 0.0f,
            float _tf_thickness = 0.0f,
            float _tf_ior       = 0.0f,
            bool  _refraction   = false) : 
                model(_model),
                ior(_ior),
                extinction(_extinction),
                F0(_F0), F90(_F90), exponent(_exponent),
                tf_thickness(_tf_thickness),
                tf_ior(_tf_ior),
                refraction(_refraction) {}
#endif

};

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Appendix B.2 Equation 13
float mx_ggx_NDF(vec3 H, vec2 alpha)
{
    vec2 He = H.xy / alpha;
    float denom = dot(He, He) + mx_square(H.z);
    return 1.0 / (M_PI * alpha.x * alpha.y * mx_square(denom));
}

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Appendix B.1 Equation 3
float mx_ggx_PDF(vec3 H, float LdotH, vec2 alpha)
{
    float NdotH = H.z;
    return mx_ggx_NDF(H, alpha) * NdotH / (4.0 * LdotH);
}

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Appendix B.2 Equation 15
vec3 mx_ggx_importance_sample_NDF(vec2 Xi, vec2 alpha)
{
    float phi = 2.0 * M_PI * Xi.x;
    float tanTheta = sqrt(Xi.y / (1.0 - Xi.y));
    vec3 H = vec3(tanTheta * alpha.x * cos(phi),
                  tanTheta * alpha.y * sin(phi),
                  1.0);
    return normalize(H);
}

// http://jcgt.org/published/0007/04/01/paper.pdf
// Appendix A Listing 1
vec3 mx_ggx_importance_sample_VNDF(vec2 Xi, vec3 V, vec2 alpha)
{
    // Transform the view direction to the hemisphere configuration.
    V = normalize(vec3(V.xy * alpha, V.z));

    // Construct an orthonormal basis from the view direction.
    float len = length(V.xy);
    vec3 T1 = (len > 0.0) ? vec3(-V.y, V.x, 0.0) / len : vec3(1.0, 0.0, 0.0);
    vec3 T2 = cross(V, T1);

    // Parameterization of the projected area.
    float r = sqrt(Xi.y);
    float phi = 2.0 * M_PI * Xi.x;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + V.z);
    t2 = (1.0 - s) * sqrt(1.0 - mx_square(t1)) + s * t2;

    // Reprojection onto hemisphere.
    vec3 H = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - mx_square(t1) - mx_square(t2))) * V;

    // Transform the microfacet normal back to the ellipsoid configuration.
    H = normalize(vec3(H.xy * alpha, max(H.z, 0.0)));

    return H;
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf
// Equation 34
float mx_ggx_smith_G1(float cosTheta, float alpha)
{
    float cosTheta2 = mx_square(cosTheta);
    float tanTheta2 = (1.0 - cosTheta2) / cosTheta2;
    return 2.0 / (1.0 + sqrt(1.0 + mx_square(alpha) * tanTheta2));
}

// Height-correlated Smith masking-shadowing
// http://jcgt.org/published/0003/02/03/paper.pdf
// Equations 72 and 99
float mx_ggx_smith_G2(float NdotL, float NdotV, float alpha)
{
    float alpha2 = mx_square(alpha);
    float lambdaL = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotL));
    float lambdaV = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotV));
    return 2.0 / (lambdaL / NdotL + lambdaV / NdotV);
}

// Rational quadratic fit to Monte Carlo data for GGX directional albedo.
vec3 mx_ggx_dir_albedo_analytic(float NdotV, float alpha, vec3 F0, vec3 F90)
{
    float x = NdotV;
    float y = alpha;
    float x2 = mx_square(x);
    float y2 = mx_square(y);
    vec4 r = vec4(0.1003, 0.9345, 1.0, 1.0) +
             vec4(-0.6303, -2.323, -1.765, 0.2281) * x +
             vec4(9.748, 2.229, 8.263, 15.94) * y +
             vec4(-2.038, -3.748, 11.53, -55.83) * x * y +
             vec4(29.34, 1.424, 28.96, 13.08) * x2 +
             vec4(-8.245, -0.7684, -7.507, 41.26) * y2 +
             vec4(-26.44, 1.436, -36.11, 54.9) * x2 * y +
             vec4(19.99, 0.2913, 15.86, 300.2) * x * y2 +
             vec4(-5.448, 0.6286, 33.37, -285.1) * x2 * y2;
    vec2 AB = clamp(r.xy / r.zw, 0.0, 1.0);
    return F0 * AB.x + F90 * AB.y;
}

vec3 mx_ggx_dir_albedo_table_lookup(float NdotV, float alpha, vec3 F0, vec3 F90)
{
#if DIRECTIONAL_ALBEDO_METHOD == 1
    if (textureSize(u_albedoTable, 0).x > 1)
    {
        vec2 AB = texture(u_albedoTable, vec2(NdotV, alpha)).rg;
        return F0 * AB.x + F90 * AB.y;
    }
#endif
    return vec3(0.0);
}

// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
vec3 mx_ggx_dir_albedo_monte_carlo(float NdotV, float alpha, vec3 F0, vec3 F90)
{
    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);
    vec3 V = vec3(sqrt(1.0 - mx_square(NdotV)), 0, NdotV);

    vec2 AB = vec2(0.0);
    const int SAMPLE_COUNT = 64;
    for (int i = 0; i < SAMPLE_COUNT; i++)
    {
        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);

        // Compute the half vector and incoming light direction.
        vec3 H = mx_ggx_importance_sample_VNDF(Xi, V, vec2(alpha));
        vec3 L = -reflect(V, H);
        
        // Compute dot products for this sample.
        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);
        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

        // Compute the Fresnel term.
        float Fc = mx_fresnel_schlick(VdotH, 0.0, 1.0);

        // Compute the per-sample geometric term.
        // https://hal.inria.fr/hal-00996995v2/document, Algorithm 2
        float G2 = mx_ggx_smith_G2(NdotL, NdotV, alpha);
        
        // Add the contribution of this sample.
        AB += vec2(G2 * (1.0 - Fc), G2 * Fc);
    }

    // Apply the global component of the geometric term and normalize.
    AB /= mx_ggx_smith_G1(NdotV, alpha) * float(SAMPLE_COUNT);

    // Return the final directional albedo.
    return F0 * AB.x + F90 * AB.y;
}

vec3 mx_ggx_dir_albedo(float NdotV, float alpha, vec3 F0, vec3 F90)
{
#if DIRECTIONAL_ALBEDO_METHOD == 0
    return mx_ggx_dir_albedo_analytic(NdotV, alpha, F0, F90);
#elif DIRECTIONAL_ALBEDO_METHOD == 1
    return mx_ggx_dir_albedo_table_lookup(NdotV, alpha, F0, F90);
#else
    return mx_ggx_dir_albedo_monte_carlo(NdotV, alpha, F0, F90);
#endif
}

float mx_ggx_dir_albedo(float NdotV, float alpha, float F0, float F90)
{
    return mx_ggx_dir_albedo(NdotV, alpha, vec3(F0), vec3(F90)).x;
}

// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf
// Equations 14 and 16
vec3 mx_ggx_energy_compensation(float NdotV, float alpha, vec3 Fss)
{
    float Ess = mx_ggx_dir_albedo(NdotV, alpha, 1.0, 1.0);
    return 1.0 + Fss * (1.0 - Ess) / Ess;
}

float mx_ggx_energy_compensation(float NdotV, float alpha, float Fss)
{
    return mx_ggx_energy_compensation(NdotV, alpha, vec3(Fss)).x;
}

// Compute the average of an anisotropic alpha pair.
float mx_average_alpha(vec2 alpha)
{
    return sqrt(alpha.x * alpha.y);
}

// Convert a real-valued index of refraction to normal-incidence reflectivity.
float mx_ior_to_f0(float ior)
{
    return mx_square((ior - 1.0) / (ior + 1.0));
}

// Convert normal-incidence reflectivity to real-valued index of refraction.
float mx_f0_to_ior(float F0)
{
    float sqrtF0 = sqrt(clamp(F0, 0.01, 0.99));
    return (1.0 + sqrtF0) / (1.0 - sqrtF0);
}

vec3 mx_f0_to_ior_colored(vec3 F0)
{
    vec3 sqrtF0 = sqrt(clamp(F0, 0.01, 0.99));
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/
float mx_fresnel_dielectric(float cosTheta, float ior)
{
    if (cosTheta < 0.0)
        return 1.0;

    float g =  ior*ior + cosTheta*cosTheta - 1.0;
    // Check for total internal reflection
    if (g < 0.0)
        return 1.0;

    g = sqrt(g);
    float gmc = g - cosTheta;
    float gpc = g + cosTheta;
    float x = gmc / gpc;
    float y = (gpc * cosTheta - 1.0) / (gmc * cosTheta + 1.0);
    return 0.5 * x * x * (1.0 + y * y);
}

void mx_fresnel_dielectric_polarized(float cosTheta, float n, out float Rp, out float Rs)
{
    if (cosTheta < 0.0) {
        Rp = 1.0;
        Rs = 1.0;
        return;
    }

    float cosTheta2 = cosTheta * cosTheta;
    float sinTheta2 = 1.0 - cosTheta2;
    float n2 = n * n;

    float t0 = n2 - sinTheta2;
    float a2plusb2 = sqrt(t0 * t0);
    float t1 = a2plusb2 + cosTheta2;
    float a = sqrt(max(0.5 * (a2plusb2 + t0), 0.0));
    float t2 = 2.0 * a * cosTheta;
    Rs = (t1 - t2) / (t1 + t2);

    float t3 = cosTheta2 * a2plusb2 + sinTheta2 * sinTheta2;
    float t4 = t2 * sinTheta2;
    Rp = Rs * (t3 - t4) / (t3 + t4);
}

void mx_fresnel_dielectric_polarized(float cosTheta, float eta1, float eta2, out float Rp, out float Rs)
{
    float n = eta2 / eta1;
    mx_fresnel_dielectric_polarized(cosTheta, n, Rp, Rs);
}

void mx_fresnel_conductor_polarized(float cosTheta, vec3 n, vec3 k, out vec3 Rp, out vec3 Rs)
{
    cosTheta = clamp(cosTheta, 0.0, 1.0);
    float cosTheta2 = cosTheta * cosTheta;
    float sinTheta2 = 1.0 - cosTheta2;
    vec3 n2 = n * n;
    vec3 k2 = k * k;

    vec3 t0 = n2 - k2 - vec3(sinTheta2);
    vec3 a2plusb2 = sqrt(t0 * t0 + 4.0 * n2 * k2);
    vec3 t1 = a2plusb2 + vec3(cosTheta2);
    vec3 a = sqrt(max(0.5 * (a2plusb2 + t0), 0.0));
    vec3 t2 = 2.0 * a * cosTheta;
    Rs = (t1 - t2) / (t1 + t2);

    vec3 t3 = cosTheta2 * a2plusb2 + vec3(sinTheta2 * sinTheta2);
    vec3 t4 = t2 * sinTheta2;
    Rp = Rs * (t3 - t4) / (t3 + t4);
}

void mx_fresnel_conductor_polarized(float cosTheta, float eta1, vec3 eta2, vec3 kappa2, out vec3 Rp, out vec3 Rs)
{
    vec3 n = eta2 / eta1;
    vec3 k = kappa2 / eta1;
    mx_fresnel_conductor_polarized(cosTheta, n, k, Rp, Rs);
}

vec3 mx_fresnel_conductor(float cosTheta, vec3 n, vec3 k)
{
    vec3 Rp, Rs;
    mx_fresnel_conductor_polarized(cosTheta, n, k, Rp, Rs);
    return 0.5 * (Rp  + Rs);
}

// Phase shift due to a dielectric material
void mx_fresnel_dielectric_phase_polarized(float cosTheta, float eta1, float eta2, out float phiP, out float phiS)
{
    float cosB = cos(atan(eta2 / eta1));    // Brewster's angle
    if (eta2 > eta1) {
        phiP = cosTheta < cosB ? M_PI : 0.0f;
        phiS = 0.0f;
    } else {
        phiP = cosTheta < cosB ? 0.0f : M_PI;
        phiS = M_PI;
    }
}

// Phase shift due to a conducting material
void mx_fresnel_conductor_phase_polarized(float cosTheta, float eta1, vec3 eta2, vec3 kappa2, out vec3 phiP, out vec3 phiS)
{
    if (dot(kappa2, kappa2) == 0.0 && eta2.x == eta2.y && eta2.y == eta2.z) {
        // Use dielectric formula to increase performance
        float phiPx, phiSx;
        mx_fresnel_dielectric_phase_polarized(cosTheta, eta1, eta2.x, phiPx, phiSx);
        phiP = vec3(phiPx, phiPx, phiPx);
        phiS = vec3(phiSx, phiSx, phiSx);
        return;
    }
    vec3 k2 = kappa2 / eta2;
    vec3 sinThetaSqr = vec3(1.0) - cosTheta * cosTheta;
    vec3 A = eta2*eta2*(vec3(1.0)-k2*k2) - eta1*eta1*sinThetaSqr;
    vec3 B = sqrt(A*A + mx_square(2.0*eta2*eta2*k2));
    vec3 U = sqrt((A+B)/2.0);
    vec3 V = max(vec3(0.0), sqrt((B-A)/2.0));

    phiS = atan(2.0*eta1*V*cosTheta, U*U + V*V - mx_square(eta1*cosTheta));
    phiP = atan(2.0*eta1*eta2*eta2*cosTheta * (2.0*k2*U - (vec3(1.0)-k2*k2) * V),
                mx_square(eta2*eta2*(vec3(1.0)+k2*k2)*cosTheta) - eta1*eta1*(U*U+V*V));
}

// Evaluation XYZ sensitivity curves in Fourier space
vec3 mx_eval_sensitivity(float opd, vec3 shift)
{
    // Use Gaussian fits, given by 3 parameters: val, pos and var
    float phase = 2.0*M_PI * opd;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
    vec3 xyz = val * sqrt(2.0*M_PI * var) * cos(pos * phase + shift) * exp(- var * phase*phase);
    xyz.x   += 9.7470e-14 * sqrt(2.0*M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(- 4.5282e+09 * phase*phase);
    return xyz / 1.0685e-7;
}

// A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence
// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html
vec3 mx_fresnel_airy(float cosTheta, vec3 ior, vec3 extinction, float tf_thickness, float tf_ior,
                                     vec3 f0, vec3 f90, float exponent, bool use_schlick)
{
    // Convert nm -> m
    float d = tf_thickness * 1.0e-9;

    // Assume vacuum on the outside
    float eta1 = 1.0;
    float eta2 = max(tf_ior, eta1);
    vec3 eta3   = use_schlick ? mx_f0_to_ior_colored(f0) : ior;
    vec3 kappa3 = use_schlick ? vec3(0.0)                : extinction;

    // Compute the Spectral versions of the Fresnel reflectance and
    // transmitance for each interface.
    float R12p, T121p, R12s, T121s;
    vec3 R23p, R23s;
    
    // Reflected and transmitted parts in the thin film
    mx_fresnel_dielectric_polarized(cosTheta, eta1, eta2, R12p, R12s);

    // Reflected part by the base
    float scale = eta1 / eta2;
    float cosThetaTSqr = 1.0 - (1.0-cosTheta*cosTheta) * scale*scale;
    float cosTheta2 = sqrt(cosThetaTSqr);
    if (use_schlick)
    {
        vec3 f = mx_fresnel_schlick(cosTheta2, f0, f90, exponent);
        R23p = 0.5 * f;
        R23s = 0.5 * f;
    }
    else
    {
        mx_fresnel_conductor_polarized(cosTheta2, eta2, eta3, kappa3, R23p, R23s);
    }

    // Check for total internal reflection
    if (cosThetaTSqr <= 0.0f)
    {
        R12s = 1.0;
        R12p = 1.0;
    }

    // Compute the transmission coefficients
    T121p = 1.0 - R12p;
    T121s = 1.0 - R12s;

    // Optical path difference
    float D = 2.0 * eta2 * d * cosTheta2;

    float phi21p, phi21s;
    vec3 phi23p, phi23s, r123s, r123p;

    // Evaluate the phase shift
    mx_fresnel_dielectric_phase_polarized(cosTheta, eta1, eta2, phi21p, phi21s);
    if (use_schlick)
    {
        phi23p = vec3(
            (eta3[0] < eta2) ? M_PI : 0.0,
            (eta3[1] < eta2) ? M_PI : 0.0,
            (eta3[2] < eta2) ? M_PI : 0.0);
        phi23s = phi23p;
    }
    else
    {
        mx_fresnel_conductor_phase_polarized(cosTheta2, eta2, eta3, kappa3, phi23p, phi23s);
    }

    phi21p = M_PI - phi21p;
    phi21s = M_PI - phi21s;

    r123p = max(vec3(0.0), sqrt(R12p*R23p));
    r123s = max(vec3(0.0), sqrt(R12s*R23s));

    // Evaluate iridescence term
    vec3 I = vec3(0.0);
    vec3 C0, Cm, Sm;

    // Iridescence term using spectral antialiasing for Parallel polarization

    vec3 S0 = vec3(1.0);

    // Reflectance term for m=0 (DC term amplitude)
    vec3 Rs = (T121p*T121p*R23p) / (vec3(1.0) - R12p*R23p);
    C0 = R12p + Rs;
    I += C0 * S0;

    // Reflectance term for m>0 (pairs of diracs)
    Cm = Rs - T121p;
    for (int m=1; m<=2; ++m)
    {
        Cm *= r123p;
        Sm  = 2.0 * mx_eval_sensitivity(float(m)*D, float(m)*(phi23p+vec3(phi21p)));
        I  += Cm*Sm;
    }

    // Iridescence term using spectral antialiasing for Perpendicular polarization

    // Reflectance term for m=0 (DC term amplitude)
    vec3 Rp = (T121s*T121s*R23s) / (vec3(1.0) - R12s*R23s);
    C0 = R12s + Rp;
    I += C0 * S0;

    // Reflectance term for m>0 (pairs of diracs)
    Cm = Rp - T121s ;
    for (int m=1; m<=2; ++m)
    {
        Cm *= r123s;
        Sm  = 2.0 * mx_eval_sensitivity(float(m)*D, float(m)*(phi23s+vec3(phi21s)));
        I  += Cm*Sm;
    }

    // Average parallel and perpendicular polarization
    I *= 0.5;

    // Convert back to RGB reflectance
    I = clamp(XYZ_TO_RGB * I, vec3(0.0), vec3(1.0));

    return I;
}

FresnelData mx_init_fresnel_data(int model)
{
    return FresnelData(model, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, false);
}

FresnelData mx_init_fresnel_dielectric(float ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_DIELECTRIC);
    fd.ior = vec3(ior);
    return fd;
}

FresnelData mx_init_fresnel_conductor(vec3 ior, vec3 extinction)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_CONDUCTOR);
    fd.ior = ior;
    fd.extinction = extinction;
    return fd;
}

FresnelData mx_init_fresnel_schlick(vec3 F0)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_SCHLICK);
    fd.F0 = F0;
    fd.F90 = vec3(1.0);
    fd.exponent = 5.0f;
    return fd;
}

FresnelData mx_init_fresnel_schlick(vec3 F0, vec3 F90, float exponent)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_SCHLICK);
    fd.F0 = F0;
    fd.F90 = F90;
    fd.exponent = exponent;
    return fd;
}

FresnelData mx_init_fresnel_schlick_airy(vec3 F0, vec3 F90, float exponent, float tf_thickness, float tf_ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_SCHLICK_AIRY);
    fd.F0 = F0;
    fd.F90 = F90;
    fd.exponent = exponent;
    fd.tf_thickness = tf_thickness;
    fd.tf_ior = tf_ior;
    return fd;
}

FresnelData mx_init_fresnel_dielectric_airy(float ior, float tf_thickness, float tf_ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_AIRY);
    fd.ior = vec3(ior);
    fd.tf_thickness = tf_thickness;
    fd.tf_ior = tf_ior;
    return fd;
}

FresnelData mx_init_fresnel_conductor_airy(vec3 ior, vec3 extinction, float tf_thickness, float tf_ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_AIRY);
    fd.ior = ior;
    fd.extinction = extinction;
    fd.tf_thickness = tf_thickness;
    fd.tf_ior = tf_ior;
    return fd;
}

vec3 mx_compute_fresnel(float cosTheta, FresnelData fd)
{
    if (fd.model == FRESNEL_MODEL_DIELECTRIC)
    {
        return vec3(mx_fresnel_dielectric(cosTheta, fd.ior.x));
    }
    else if (fd.model == FRESNEL_MODEL_CONDUCTOR)
    {
        return mx_fresnel_conductor(cosTheta, fd.ior, fd.extinction);
    }
    else if (fd.model == FRESNEL_MODEL_SCHLICK)
    {
        return mx_fresnel_schlick(cosTheta, fd.F0, fd.F90, fd.exponent);
    }
    else
    {
        return mx_fresnel_airy(cosTheta, fd.ior, fd.extinction, fd.tf_thickness, fd.tf_ior,
                                         fd.F0, fd.F90, fd.exponent,
                                         fd.model == FRESNEL_MODEL_SCHLICK_AIRY);
    }
}

// Compute the refraction of a ray through a solid sphere.
vec3 mx_refraction_solid_sphere(vec3 R, vec3 N, float ior)
{
    R = refract(R, N, 1.0 / ior);
    vec3 N1 = normalize(R * dot(R, N) - N * 0.5);
    return refract(R, N1, ior);
}

vec2 mx_latlong_projection(vec3 dir)
{
    float latitude = -asin(dir.y) * M_PI_INV + 0.5;
    float longitude = atan(dir.x, -dir.z) * M_PI_INV * 0.5 + 0.5;
    return vec2(longitude, latitude);
}

vec3 mx_latlong_map_lookup(vec3 dir, mat4 transform, float lod, sampler2D envSampler)
{
    vec3 envDir = normalize((transform * vec4(dir,0.0)).xyz);
    vec2 uv = mx_latlong_projection(envDir);
    return textureLod(envSampler, uv, lod).rgb;
}

float mx_latlong_compute_lod(float alpha)
{
    // Select a mip level based on input alpha.
    float lodBias = alpha < 0.25 ? sqrt(alpha) : 0.5*alpha + 0.375;
    return lodBias * float(u_envRadianceMips);
}

vec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd)
{
    N = mx_forward_facing_normal(N, V);
    vec3 L = fd.refraction ? mx_refraction_solid_sphere(-V, N, fd.ior.x) : -reflect(V, N);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    float avgAlpha = mx_average_alpha(alpha);
    vec3 F = mx_compute_fresnel(NdotV, fd);
    float G = mx_ggx_smith_G2(NdotV, NdotV, avgAlpha);
    vec3 FG = fd.refraction ? vec3(1.0) - (F * G) : F * G;

    vec3 Li = mx_latlong_map_lookup(L, u_envMatrix, mx_latlong_compute_lod(avgAlpha), u_envRadiance);
    return Li * FG;
}

vec3 mx_environment_irradiance(vec3 N)
{
    return mx_latlong_map_lookup(N, u_envMatrix, 0.0, u_envIrradiance);
}


vec3 mx_surface_transmission(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd, vec3 tint)
{
    return tint;
}

void mx_point_light(LightData light, vec3 position, out lightshader result)
{
    result.direction = light.position - position;
    float distance = length(result.direction) + M_FLOAT_EPS;
    float attenuation = pow(distance + 1.0, light.decay_rate + M_FLOAT_EPS);
    result.intensity = light.color * light.intensity / attenuation;
    result.direction /= distance;
}

void mx_directional_light(LightData light, vec3 position, out lightshader result)
{
    result.direction = -light.direction;
    result.intensity = light.color * light.intensity;
}

int numActiveLightSources()
{
    return min(u_numActiveLightSources, MAX_LIGHT_SOURCES) ;
}

void sampleLightSource(LightData light, vec3 position, out lightshader result)
{
    result.intensity = vec3(0.0);
    result.direction = vec3(0.0);
    if (light.type == 1)
    {
        mx_point_light(light, position, result);
    }
    else if (light.type == 2)
    {
        mx_directional_light(light, position, result);
    }
}

vec2 mx_transform_uv(vec2 uv, vec2 uv_scale, vec2 uv_offset)
{
    uv = uv * uv_scale + uv_offset;
    return uv;
}

void mx_image_color3(sampler2D tex_sampler, int layer, vec3 defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out vec3 result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv).rgb;
    }
    else
    {
        result = defaultval;
    }
}

void NG_tiledimage_color3(sampler2D file, vec3 default1, vec2 texcoord1, vec2 uvtiling, vec2 uvoffset, vec2 realworldimagesize, vec2 realworldtilesize, int filtertype, int framerange, int frameoffset, int frameendaction, out vec3 out1)
{
    vec2 N_mult_color3_out = texcoord1 * uvtiling;
    vec2 N_sub_color3_out = N_mult_color3_out - uvoffset;
    vec2 N_divtilesize_color3_out = N_sub_color3_out / realworldimagesize;
    vec2 N_multtilesize_color3_out = N_divtilesize_color3_out * realworldtilesize;
    vec3 N_img_color3_out = vec3(0.0);
    mx_image_color3(file, 0, default1, N_multtilesize_color3_out, 2, 2, filtertype, framerange, frameoffset, frameendaction, vec2(1.000000, 1.000000), vec2(0.000000, 0.000000), N_img_color3_out);
    out1 = N_img_color3_out;
}


void mx_image_float(sampler2D tex_sampler, int layer, float defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out float result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv).r;
    }
    else
    {
        result = defaultval;
    }
}

void NG_tiledimage_float(sampler2D file, float default1, vec2 texcoord1, vec2 uvtiling, vec2 uvoffset, vec2 realworldimagesize, vec2 realworldtilesize, int filtertype, int framerange, int frameoffset, int frameendaction, out float out1)
{
    vec2 N_mult_float_out = texcoord1 * uvtiling;
    vec2 N_sub_float_out = N_mult_float_out - uvoffset;
    vec2 N_divtilesize_float_out = N_sub_float_out / realworldimagesize;
    vec2 N_multtilesize_float_out = N_divtilesize_float_out * realworldtilesize;
    float N_img_float_out = 0.0;
    mx_image_float(file, 0, default1, N_multtilesize_float_out, 2, 2, filtertype, framerange, frameoffset, frameendaction, vec2(1.000000, 1.000000), vec2(0.000000, 0.000000), N_img_float_out);
    out1 = N_img_float_out;
}

void mx_roughness_anisotropy(float roughness, float anisotropy, out vec2 result)
{
    float roughness_sqr = clamp(roughness*roughness, M_FLOAT_EPS, 1.0);
    if (anisotropy > 0.0)
    {
        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));
        result.x = min(roughness_sqr / aspect, 1.0);
        result.y = roughness_sqr * aspect;
    }
    else
    {
        result.x = roughness_sqr;
        result.y = roughness_sqr;
    }
}

void mx_artistic_ior(vec3 reflectivity, vec3 edge_color, out vec3 ior, out vec3 extinction)
{
    // "Artist Friendly Metallic Fresnel", Ole Gulbrandsen, 2014
    // http://jcgt.org/published/0003/04/03/paper.pdf

    vec3 r = clamp(reflectivity, 0.0, 0.99);
    vec3 r_sqrt = sqrt(r);
    vec3 n_min = (1.0 - r) / (1.0 + r);
    vec3 n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);
    ior = mix(n_max, n_min, edge_color);

    vec3 np1 = ior + 1.0;
    vec3 nm1 = ior - 1.0;
    vec3 k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);
    k2 = max(k2, 0.0);
    extinction = sqrt(k2);
}

void mx_uniform_edf(vec3 N, vec3 L, vec3 color, out EDF result)
{
    result = color;
}

void mx_normalmap(vec3 value, int map_space, float normal_scale, vec3 N, vec3 T,  out vec3 result)
{
    // Decode the normal map.
    value = (value == vec3(0.0f)) ? vec3(0.0, 0.0, 1.0) : value * 2.0 - 1.0;

    // Transform from tangent space if needed.
    if (map_space == 0)
    {
        vec3 B = normalize(cross(N, T));
        value.xy *= normal_scale;
        value = T * value.x + B * value.y + N * value.z;
    }

    // Normalize the result.
    result = normalize(value);
}


void mx_generalized_schlick_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color0, vec3 color90, float exponent, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    X = normalize(X - dot(X, N) * N);
    vec3 Y = cross(N, X);
    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_schlick_airy(color0, color90, exponent, bsdf.thickness, bsdf.ior);
    }
    else
    {
        fd = mx_init_fresnel_schlick(color0, color90, exponent);
    }
    vec3  F = mx_compute_fresnel(VdotH, fd);
    float D = mx_ggx_NDF(Ht, safeAlpha);
    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, vec3(1.0 / 3.0));
    bsdf.throughput = vec3(1.0 - avgDirAlbedo * weight);

    // Note: NdotL is cancelled out
    bsdf.response = D * F * G * comp * occlusion * weight / (4.0 * NdotV);
}

void mx_generalized_schlick_bsdf_transmission(vec3 V, float weight, vec3 color0, vec3 color90, float exponent, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_schlick_airy(color0, color90, exponent, bsdf.thickness, bsdf.ior);
    }
    else
    {
        fd = mx_init_fresnel_schlick(color0, color90, exponent);
    }
    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);

    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, vec3(1.0 / 3.0));
    bsdf.throughput = vec3(1.0 - avgDirAlbedo * weight);

    if (scatter_mode != 0)
    {
        float avgF0 = dot(color0, vec3(1.0 / 3.0));
        fd.ior = vec3(mx_f0_to_ior(avgF0));
        bsdf.response = mx_surface_transmission(N, V, X, safeAlpha, distribution, fd, color0) * weight;
    }
}

void mx_generalized_schlick_bsdf_indirect(vec3 V, float weight, vec3 color0, vec3 color90, float exponent, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_schlick_airy(color0, color90, exponent, bsdf.thickness, bsdf.ior);
    }
    else
    {
        fd = mx_init_fresnel_schlick(color0, color90, exponent);
    }
    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, vec3(1.0 / 3.0));
    bsdf.throughput = vec3(1.0 - avgDirAlbedo * weight);

    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);
    bsdf.response = Li * comp * weight;
}


// Based on the OSL implementation of Oren-Nayar diffuse, which is in turn
// based on https://mimosa-pudica.net/improved-oren-nayar.html.
float mx_oren_nayar_diffuse(vec3 L, vec3 V, vec3 N, float NdotL, float roughness)
{
    float LdotV = clamp(dot(L, V), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float s = LdotV - NdotL * NdotV;
    float stinv = (s > 0.0f) ? s / max(NdotL, NdotV) : 0.0;

    float sigma2 = mx_square(roughness * M_PI);
    float A = 1.0 - 0.5 * (sigma2 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);

    return A + B * stinv;
}

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Section 5.3
float mx_burley_diffuse(vec3 L, vec3 V, vec3 N, float NdotL, float roughness)
{
    vec3 H = normalize(L + V);
    float LdotH = clamp(dot(L, H), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    float F90 = 0.5 + (2.0 * roughness * mx_square(LdotH));
    float refL = mx_fresnel_schlick(NdotL, 1.0, F90);
    float refV = mx_fresnel_schlick(NdotV, 1.0, F90);
    return refL * refV;
}

// Compute the directional albedo component of Burley diffuse for the given
// view angle and roughness.  Curve fit provided by Stephen Hill.
float mx_burley_diffuse_dir_albedo(float NdotV, float roughness)
{
    float x = NdotV;
    float fit0 = 0.97619 - 0.488095 * mx_pow5(1.0 - x);
    float fit1 = 1.55754 + (-2.02221 + (2.56283 - 1.06244 * x) * x) * x;
    return mix(fit0, fit1, roughness);
}

// Evaluate the Burley diffusion profile for the given distance and diffusion shape.
// Based on https://graphics.pixar.com/library/ApproxBSSRDF/
vec3 mx_burley_diffusion_profile(float dist, vec3 shape)
{
    vec3 num1 = exp(-shape * dist);
    vec3 num2 = exp(-shape * dist / 3.0);
    float denom = max(dist, M_FLOAT_EPS);
    return (num1 + num2) / denom;
}

// Integrate the Burley diffusion profile over a sphere of the given radius.
// Inspired by Eric Penner's presentation in http://advances.realtimerendering.com/s2011/
vec3 mx_integrate_burley_diffusion(vec3 N, vec3 L, float radius, vec3 mfp)
{
    float theta = acos(dot(N, L));

    // Estimate the Burley diffusion shape from mean free path.
    vec3 shape = vec3(1.0) / max(mfp, 0.1);

    // Integrate the profile over the sphere.
    vec3 sumD = vec3(0.0);
    vec3 sumR = vec3(0.0);
    const int SAMPLE_COUNT = 32;
    const float SAMPLE_WIDTH = (2.0 * M_PI) / float(SAMPLE_COUNT);
    for (int i = 0; i < SAMPLE_COUNT; i++)
    {
        float x = -M_PI + (float(i) + 0.5) * SAMPLE_WIDTH;
        float dist = radius * abs(2.0 * sin(x * 0.5));
        vec3 R = mx_burley_diffusion_profile(dist, shape);
        sumD += R * max(cos(theta + x), 0.0);
        sumR += R;
    }

    return sumD / sumR;
}

vec3 mx_subsurface_scattering_approx(vec3 N, vec3 L, vec3 P, vec3 albedo, vec3 mfp)
{
    float curvature = length(fwidth(N)) / length(fwidth(P));
    float radius = 1.0 / max(curvature, 0.01);
    return albedo * mx_integrate_burley_diffusion(N, L, radius, mfp) / vec3(M_PI);
}

void mx_oren_nayar_diffuse_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, float roughness, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    float NdotL = clamp(dot(normal, L), M_FLOAT_EPS, 1.0);

    bsdf.response = color * occlusion * weight * NdotL * M_PI_INV;
    if (roughness > 0.0)
    {
        bsdf.response *= mx_oren_nayar_diffuse(L, V, normal, NdotL, roughness);
    }
}

void mx_oren_nayar_diffuse_bsdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    vec3 Li = mx_environment_irradiance(normal);
    bsdf.response = Li * color * weight;
}


void mx_dielectric_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    X = normalize(X - dot(X, N) * N);
    vec3 Y = cross(N, X);
    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_dielectric_airy(ior, bsdf.thickness, bsdf.ior);
    }
    else
    {
        fd = mx_init_fresnel_dielectric(ior);
    }
    vec3  F = mx_compute_fresnel(VdotH, fd);
    float D = mx_ggx_NDF(Ht, safeAlpha);
    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

    float F0 = mx_ior_to_f0(ior);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;
    bsdf.throughput = 1.0 - dirAlbedo * weight;

    // Note: NdotL is cancelled out
    bsdf.response = D * F * G * comp * tint * occlusion * weight / (4.0 * NdotV);
}

void mx_dielectric_bsdf_transmission(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_dielectric_airy(ior, bsdf.thickness, bsdf.ior);
    }
    else
    {
        fd = mx_init_fresnel_dielectric(ior);
    }
    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);

    float F0 = mx_ior_to_f0(ior);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;
    bsdf.throughput = 1.0 - dirAlbedo * weight;

    if (scatter_mode != 0)
    {
        bsdf.response = mx_surface_transmission(N, V, X, safeAlpha, distribution, fd, tint) * weight;
    }
}

void mx_dielectric_bsdf_indirect(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_dielectric_airy(ior, bsdf.thickness, bsdf.ior);
    }
    else
    {
        fd = mx_init_fresnel_dielectric(ior);
    }
    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);

    float F0 = mx_ior_to_f0(ior);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;
    bsdf.throughput = 1.0 - dirAlbedo * weight;

    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);
    bsdf.response = Li * tint * comp * weight;
}


void mx_conductor_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness, vec3 N, vec3 X, int distribution, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    X = normalize(X - dot(X, N) * N);
    vec3 Y = cross(N, X);
    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));

    FresnelData fd;
    if (bsdf.thickness > 0.0)
        fd = mx_init_fresnel_conductor_airy(ior_n, ior_k, bsdf.thickness, bsdf.ior);
    else
        fd = mx_init_fresnel_conductor(ior_n, ior_k);

    vec3 F = mx_compute_fresnel(VdotH, fd);
    float D = mx_ggx_NDF(Ht, safeAlpha);
    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    // Note: NdotL is cancelled out
    bsdf.response = D * F * G * comp * occlusion * weight / (4.0 * NdotV);
}

void mx_conductor_bsdf_indirect(vec3 V, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness, vec3 N, vec3 X, int distribution, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
        fd = mx_init_fresnel_conductor_airy(ior_n, ior_k, bsdf.thickness, bsdf.ior);
    else
        fd = mx_init_fresnel_conductor(ior_n, ior_k);

    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);

    bsdf.response = Li * comp * weight;
}

void IMP_UsdPreviewSurface_surfaceshader(vec3 diffuseColor, vec3 emissiveColor, int useSpecularWorkflow, vec3 specularColor, float metallic, float roughness, float clearcoat, float clearcoatRoughness, float opacity, float opacityThreshold, float ior, vec3 normal, float displacement, float occlusion, out surfaceshader out1)
{
    vec3 geomprop_Tworld_out1 = normalize(vd.tangentWorld);
    const float one_minus_ior_in1_tmp = 1.000000;
    float one_minus_ior_out = one_minus_ior_in1_tmp - ior;
    const float one_plus_ior_in1_tmp = 1.000000;
    float one_plus_ior_out = one_plus_ior_in1_tmp + ior;
    vec2 coat_roughness_out = vec2(0.0);
    mx_roughness_anisotropy(clearcoatRoughness, 0.000000, coat_roughness_out);
    vec3 geomprop_Nworld_out1 = normalize(vd.normalWorld);
    const float scale_normal_in2_tmp = 0.500000;
    vec3 scale_normal_out = normal * scale_normal_in2_tmp;
    vec2 specular_roughness_out = vec2(0.0);
    mx_roughness_anisotropy(roughness, 0.000000, specular_roughness_out);
    const float inverse_metalness_in1_tmp = 1.000000;
    float inverse_metalness_out = inverse_metalness_in1_tmp - metallic;
    float use_specular_workflow_float_out = float(useSpecularWorkflow);
    vec3 artistic_ior_ior = vec3(0.0);
    vec3 artistic_ior_extinction = vec3(0.0);
    mx_artistic_ior(diffuseColor, diffuseColor, artistic_ior_ior, artistic_ior_extinction);
    const vec3 specular_color_metallic_bg_tmp = vec3(1.000000, 1.000000, 1.000000);
    vec3 specular_color_metallic_out = mix(specular_color_metallic_bg_tmp, diffuseColor, metallic);
    const float opacity_clamped_low_tmp = 0.000010;
    const float opacity_clamped_high_tmp = 1.000000;
    float opacity_clamped_out = clamp(opacity, opacity_clamped_low_tmp, opacity_clamped_high_tmp);
    float R_out = one_minus_ior_out / one_plus_ior_out;
    const float bias_normal_in2_tmp = 0.500000;
    vec3 bias_normal_out = scale_normal_out + bias_normal_in2_tmp;
    const float diffuse_bsdf_weight_fg_tmp = 1.000000;
    float diffuse_bsdf_weight_out = mix(inverse_metalness_out, diffuse_bsdf_weight_fg_tmp, use_specular_workflow_float_out);
    const float cutout_opacity_in1_tmp = 1.000000;
    const float cutout_opacity_in2_tmp = 0.000000;
    float cutout_opacity_out = (opacity_clamped_out >= opacityThreshold) ? cutout_opacity_in1_tmp : cutout_opacity_in2_tmp;
    float R_sq_out = R_out * R_out;
    vec3 surface_normal_out = vec3(0.0);
    mx_normalmap(bias_normal_out, 0, 1.000000, geomprop_Nworld_out1, geomprop_Tworld_out1, surface_normal_out);
    vec3 coat_F0_out = vec3(R_sq_out, R_sq_out, R_sq_out);
    vec3 specular_color_metallic_R_sq_out = specular_color_metallic_out * R_sq_out;
    vec3 F0_out = mix(specular_color_metallic_R_sq_out, specular_color_metallic_out, metallic);
    surfaceshader surface_constructor_out = surfaceshader(vec3(0.0),vec3(0.0));
    {
        vec3 N = normalize(vd.normalWorld);
        vec3 V = normalize(u_viewPosition - vd.positionWorld);
        vec3 P = vd.positionWorld;

        float surfaceOpacity = cutout_opacity_out;

        // Shadow occlusion
        float occlusion = 1.0;

        // Light loop
        int numLights = numActiveLightSources();
        lightshader lightShader;
        for (int activeLightIndex = 0; activeLightIndex < numLights; ++activeLightIndex)
        {
            sampleLightSource(u_lightData[activeLightIndex], vd.positionWorld, lightShader);
            vec3 L = lightShader.direction;
            occlusion = u_lightData[activeLightIndex].shadowOcclusion;

            // Calculate the BSDF response for this light source
            BSDF coat_dielectric_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_reflection(L, V, P, occlusion, clearcoat, coat_F0_out, vec3(1.000000, 1.000000, 1.000000), 5.000000, coat_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, coat_dielectric_bsdf_out);
            BSDF specular_bsdf1_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_reflection(L, V, P, occlusion, 1.000000, specularColor, vec3(1.000000, 1.000000, 1.000000), 5.000000, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, specular_bsdf1_out);
            BSDF diffuse_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_oren_nayar_diffuse_bsdf_reflection(L, V, P, occlusion, diffuse_bsdf_weight_out, diffuseColor, 0.000000, surface_normal_out, diffuse_bsdf_out);
            BSDF transmission_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            BSDF transmission_mix_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            transmission_mix_out.response = mix(transmission_bsdf_out.response, diffuse_bsdf_out.response, opacity);
            transmission_mix_out.throughput = mix(transmission_bsdf_out.throughput, diffuse_bsdf_out.throughput, opacity);
            BSDF specular_workflow_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            specular_workflow_bsdf_out.response = specular_bsdf1_out.response + transmission_mix_out.response * specular_bsdf1_out.throughput;
            specular_workflow_bsdf_out.throughput = specular_bsdf1_out.throughput * transmission_mix_out.throughput;
            BSDF metalness_metal_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_conductor_bsdf_reflection(L, V, P, occlusion, 1.000000, artistic_ior_ior, artistic_ior_extinction, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, metalness_metal_bsdf_out);
            BSDF specular_bsdf2_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_reflection(L, V, P, occlusion, 1.000000, F0_out, specular_color_metallic_out, 5.000000, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, specular_bsdf2_out);
            // Omitted node 'transmission_mix'. Function already called in this scope.
            BSDF metalness_specular_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            metalness_specular_bsdf_out.response = specular_bsdf2_out.response + transmission_mix_out.response * specular_bsdf2_out.throughput;
            metalness_specular_bsdf_out.throughput = specular_bsdf2_out.throughput * transmission_mix_out.throughput;
            BSDF metalness_workflow_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            metalness_workflow_bsdf_out.response = mix(metalness_specular_bsdf_out.response, metalness_metal_bsdf_out.response, metallic);
            metalness_workflow_bsdf_out.throughput = mix(metalness_specular_bsdf_out.throughput, metalness_metal_bsdf_out.throughput, metallic);
            BSDF workflow_selector_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            workflow_selector_bsdf_out.response = mix(metalness_workflow_bsdf_out.response, specular_workflow_bsdf_out.response, use_specular_workflow_float_out);
            workflow_selector_bsdf_out.throughput = mix(metalness_workflow_bsdf_out.throughput, specular_workflow_bsdf_out.throughput, use_specular_workflow_float_out);
            BSDF coat_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            coat_bsdf_out.response = coat_dielectric_bsdf_out.response + workflow_selector_bsdf_out.response * coat_dielectric_bsdf_out.throughput;
            coat_bsdf_out.throughput = coat_dielectric_bsdf_out.throughput * workflow_selector_bsdf_out.throughput;

            // Accumulate the light's contribution
            surface_constructor_out.color += lightShader.intensity * coat_bsdf_out.response;
        }

        // Ambient occlusion
        occlusion = 1.0;

        // Add environment contribution
        {
            BSDF coat_dielectric_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_indirect(V, clearcoat, coat_F0_out, vec3(1.000000, 1.000000, 1.000000), 5.000000, coat_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, coat_dielectric_bsdf_out);
            BSDF specular_bsdf1_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_indirect(V, 1.000000, specularColor, vec3(1.000000, 1.000000, 1.000000), 5.000000, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, specular_bsdf1_out);
            BSDF diffuse_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_oren_nayar_diffuse_bsdf_indirect(V, diffuse_bsdf_weight_out, diffuseColor, 0.000000, surface_normal_out, diffuse_bsdf_out);
            BSDF transmission_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            BSDF transmission_mix_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            transmission_mix_out.response = mix(transmission_bsdf_out.response, diffuse_bsdf_out.response, opacity);
            transmission_mix_out.throughput = mix(transmission_bsdf_out.throughput, diffuse_bsdf_out.throughput, opacity);
            BSDF specular_workflow_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            specular_workflow_bsdf_out.response = specular_bsdf1_out.response + transmission_mix_out.response * specular_bsdf1_out.throughput;
            specular_workflow_bsdf_out.throughput = specular_bsdf1_out.throughput * transmission_mix_out.throughput;
            BSDF metalness_metal_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_conductor_bsdf_indirect(V, 1.000000, artistic_ior_ior, artistic_ior_extinction, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, metalness_metal_bsdf_out);
            BSDF specular_bsdf2_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_indirect(V, 1.000000, F0_out, specular_color_metallic_out, 5.000000, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, specular_bsdf2_out);
            // Omitted node 'transmission_mix'. Function already called in this scope.
            BSDF metalness_specular_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            metalness_specular_bsdf_out.response = specular_bsdf2_out.response + transmission_mix_out.response * specular_bsdf2_out.throughput;
            metalness_specular_bsdf_out.throughput = specular_bsdf2_out.throughput * transmission_mix_out.throughput;
            BSDF metalness_workflow_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            metalness_workflow_bsdf_out.response = mix(metalness_specular_bsdf_out.response, metalness_metal_bsdf_out.response, metallic);
            metalness_workflow_bsdf_out.throughput = mix(metalness_specular_bsdf_out.throughput, metalness_metal_bsdf_out.throughput, metallic);
            BSDF workflow_selector_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            workflow_selector_bsdf_out.response = mix(metalness_workflow_bsdf_out.response, specular_workflow_bsdf_out.response, use_specular_workflow_float_out);
            workflow_selector_bsdf_out.throughput = mix(metalness_workflow_bsdf_out.throughput, specular_workflow_bsdf_out.throughput, use_specular_workflow_float_out);
            BSDF coat_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            coat_bsdf_out.response = coat_dielectric_bsdf_out.response + workflow_selector_bsdf_out.response * coat_dielectric_bsdf_out.throughput;
            coat_bsdf_out.throughput = coat_dielectric_bsdf_out.throughput * workflow_selector_bsdf_out.throughput;

            surface_constructor_out.color += occlusion * coat_bsdf_out.response;
        }

        // Add surface emission
        {
            EDF emission_edf_out = EDF(0.0);
            mx_uniform_edf(N, V, emissiveColor, emission_edf_out);
            surface_constructor_out.color += emission_edf_out;
        }

        // Calculate the BSDF transmission for viewing direction
        {
            BSDF coat_dielectric_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_transmission(V, clearcoat, coat_F0_out, vec3(1.000000, 1.000000, 1.000000), 5.000000, coat_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, coat_dielectric_bsdf_out);
            BSDF specular_bsdf1_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_transmission(V, 1.000000, specularColor, vec3(1.000000, 1.000000, 1.000000), 5.000000, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, specular_bsdf1_out);
            BSDF diffuse_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            BSDF transmission_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_dielectric_bsdf_transmission(V, 1.000000, vec3(1.000000, 1.000000, 1.000000), ior, vec2(0.000000, 0.000000), surface_normal_out, geomprop_Tworld_out1, 0, 1, transmission_bsdf_out);
            BSDF transmission_mix_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            transmission_mix_out.response = mix(transmission_bsdf_out.response, diffuse_bsdf_out.response, opacity);
            transmission_mix_out.throughput = mix(transmission_bsdf_out.throughput, diffuse_bsdf_out.throughput, opacity);
            BSDF specular_workflow_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            specular_workflow_bsdf_out.response = specular_bsdf1_out.response + transmission_mix_out.response * specular_bsdf1_out.throughput;
            specular_workflow_bsdf_out.throughput = specular_bsdf1_out.throughput * transmission_mix_out.throughput;
            BSDF metalness_metal_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            BSDF specular_bsdf2_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            mx_generalized_schlick_bsdf_transmission(V, 1.000000, F0_out, specular_color_metallic_out, 5.000000, specular_roughness_out, surface_normal_out, geomprop_Tworld_out1, 0, 0, specular_bsdf2_out);
            // Omitted node 'transmission_mix'. Function already called in this scope.
            BSDF metalness_specular_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            metalness_specular_bsdf_out.response = specular_bsdf2_out.response + transmission_mix_out.response * specular_bsdf2_out.throughput;
            metalness_specular_bsdf_out.throughput = specular_bsdf2_out.throughput * transmission_mix_out.throughput;
            BSDF metalness_workflow_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            metalness_workflow_bsdf_out.response = mix(metalness_specular_bsdf_out.response, metalness_metal_bsdf_out.response, metallic);
            metalness_workflow_bsdf_out.throughput = mix(metalness_specular_bsdf_out.throughput, metalness_metal_bsdf_out.throughput, metallic);
            BSDF workflow_selector_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            workflow_selector_bsdf_out.response = mix(metalness_workflow_bsdf_out.response, specular_workflow_bsdf_out.response, use_specular_workflow_float_out);
            workflow_selector_bsdf_out.throughput = mix(metalness_workflow_bsdf_out.throughput, specular_workflow_bsdf_out.throughput, use_specular_workflow_float_out);
            BSDF coat_bsdf_out = BSDF(vec3(0.0),vec3(1.0), 0.0, 0.0);
            coat_bsdf_out.response = coat_dielectric_bsdf_out.response + workflow_selector_bsdf_out.response * coat_dielectric_bsdf_out.throughput;
            coat_bsdf_out.throughput = coat_dielectric_bsdf_out.throughput * workflow_selector_bsdf_out.throughput;
            surface_constructor_out.transparency += coat_bsdf_out.response;
        }

        // Compute and apply surface opacity
        {
            surface_constructor_out.color *= surfaceOpacity;
            surface_constructor_out.transparency = mix(vec3(1.0), surface_constructor_out.transparency, surfaceOpacity);
        }
    }

    out1 = surface_constructor_out;
}

vec4 surfaceShader(vec4 Peye, vec3 Neye, vec4 color, vec4 patchCoord)
{
    // Initialize MaterialX Variables
    mxInit(Peye, Neye);
    vec2 geomprop_UV0_out1 = vd.texcoord_0;
    vec3 image_color_out = vec3(0.0);
    NG_tiledimage_color3(image_color_file, image_color_default, geomprop_UV0_out1, image_color_uvtiling, image_color_uvoffset, image_color_realworldimagesize, image_color_realworldtilesize, image_color_filtertype, image_color_framerange, image_color_frameoffset, image_color_frameendaction, image_color_out);
    float image_roughness_out = 0.0;
    NG_tiledimage_float(image_roughness_file, image_roughness_default, geomprop_UV0_out1, image_roughness_uvtiling, image_roughness_uvoffset, image_roughness_realworldimagesize, image_roughness_realworldtilesize, image_roughness_filtertype, image_roughness_framerange, image_roughness_frameoffset, image_roughness_frameendaction, image_roughness_out);
    surfaceshader SR_brass1_out = surfaceshader(vec3(0.0),vec3(0.0));
    IMP_UsdPreviewSurface_surfaceshader(image_color_out, emissiveColor, useSpecularWorkflow, specularColor, metallic, image_roughness_out, clearcoat, clearcoatRoughness, opacity, opacityThreshold, ior, normal, displacement, occlusion, SR_brass1_out);
    float outAlpha = clamp(1.0 - dot(SR_brass1_out.transparency, vec3(0.3333)), 0.0, 1.0);
    vec4 mxOut = vec4(SR_brass1_out.color, outAlpha);
    if (outAlpha < u_alphaThreshold)
    {
        discard;
    }
    mxOut = ApplyColorOverrides(mxOut);
    return mxOut;
}

