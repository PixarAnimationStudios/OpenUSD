-- glslfx version 0.1

//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

--- This is what an import might look like.
--- #import $TOOLS/hdSt/shaders/mesh.glslfx

#import $TOOLS/hdSt/shaders/instancing.glslfx
#import $TOOLS/hdSt/shaders/meshFaceCull.glslfx
#import $TOOLS/hdSt/shaders/meshNormal.glslfx
#import $TOOLS/hdSt/shaders/meshWire.glslfx
#import $TOOLS/hdSt/shaders/terminals.glslfx
#import $TOOLS/hdSt/shaders/edgeId.glslfx
#import $TOOLS/hdSt/shaders/pointId.glslfx
#import $TOOLS/hdSt/shaders/visibility.glslfx

--- --------------------------------------------------------------------------
-- layout Mesh.Vertex

[
    ["out block", "VertexData", "outData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.Vertex

// Fwd declare methods defined in pointId.glslfx, that are used below.
FORWARD_DECL(int GetPointId());
FORWARD_DECL(float GetPointRasterSize(int));
FORWARD_DECL(void ProcessPointId(int));

void main(void)
{
    ProcessPrimvarsIn();

    MAT4 transform    = ApplyInstanceTransform(HdGet_transform());
    vec4 point        = vec4(HdGet_points().xyz, 1);
    outData.Peye = vec4(GetWorldToViewMatrix() * transform * point);

    outData.Neye = GetNormal(vec3(0), 0); // normalized

    int pointId = GetPointId();
    gl_PointSize = GetPointRasterSize(pointId);
    ProcessPointId(pointId);

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ApplyClipPlanes(outData.Peye);
}

--- --------------------------------------------------------------------------
-- layout Mesh.PostTessVertex.Triangle

[
    ["out block", "VertexData", "outData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ],
    ["out", "vec3", "ptvsBarycentricCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessVertex.Triangle

vec4 GetPatchCoord(int index)
{
    vec2 uv[3];
    uv[0] = vec2(0, 0); // (0, 0, 1);
    uv[1] = vec2(1, 0); // (1, 0, 0);
    uv[2] = vec2(0, 1); // (0, 1, 0);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoordTriangle(uv[index], patchParam);
}

// Fwd declare methods defined in pointId.glslfx, that are used below.
FORWARD_DECL(int GetPointId());
FORWARD_DECL(float GetPointRasterSize(int));
FORWARD_DECL(void ProcessPointId(int));

void main(void)
{
    ProcessPrimvarsIn();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    int pointId = GetPointId();
    gl_PointSize = GetPointRasterSize(pointId);
    ProcessPointId(pointId);

    vec4 point0 = GetWorldToViewMatrix() * transform * vec4(points[0],1.0);
    vec4 point1 = GetWorldToViewMatrix() * transform * vec4(points[1],1.0);
    vec4 point2 = GetWorldToViewMatrix() * transform * vec4(points[2],1.0);

    // Get the indata Neye if provided.
    bool isFlipped = IsFlipped();
    vec3 Neye0 = isFlipped ? -GetNormal(vec3(0),0) : GetNormal(vec3(0),0);
    vec3 Neye1 = isFlipped ? -GetNormal(vec3(0),1) : GetNormal(vec3(0),1);
    vec3 Neye2 = isFlipped ? -GetNormal(vec3(0),2) : GetNormal(vec3(0),2);

    Neye0 = GetTriGeometryNormal(Neye0, point0, point1, point2, isFlipped);
    Neye1 = GetTriGeometryNormal(Neye1, point0, point1, point2, isFlipped);
    Neye2 = GetTriGeometryNormal(Neye2, point0, point1, point2, isFlipped);

    point0 = DisplacementTerminal(0, point0, Neye0, GetPatchCoord(0));
    point1 = DisplacementTerminal(1, point1, Neye1, GetPatchCoord(1));
    point2 = DisplacementTerminal(2, point2, Neye2, GetPatchCoord(2));

    vec2 coord = gl_TessCoord.xy;
    vec4 basis = vec4(coord.x, coord.y, 1.0f-coord.x-coord.y, 0.0f);

    outData.Peye = InterpolatePrimvar(point0, point1, point2, point0, basis);
    outData.Neye = InterpolatePrimvar(Neye0, Neye1, Neye2, Neye0, basis);

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ptvsBarycentricCoord = gl_TessCoord;
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(basis, 0, 1, 2, 0);
}

--- --------------------------------------------------------------------------
-- layout Mesh.PostTessVertex.Quad
[
    ["out block", "VertexData", "outData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ],
    ["out", "vec2", "ptvsBarycentricCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessVertex.Quad

vec4 GetPatchCoord(int index)
{
    vec2 uv[4];
    uv[0] = vec2(0, 0);
    uv[1] = vec2(1, 0);
    uv[2] = vec2(1, 1);
    uv[3] = vec2(0, 1);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoord(uv[index], patchParam);
}

// Fwd declare methods defined in pointId.glslfx, that are used below.
FORWARD_DECL(int GetPointId());
FORWARD_DECL(float GetPointRasterSize(int));
FORWARD_DECL(void ProcessPointId(int));

void main(void)
{
    ProcessPrimvarsIn();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    int pointId = GetPointId();
    gl_PointSize = GetPointRasterSize(pointId);
    ProcessPointId(pointId);

    vec4 point0 = GetWorldToViewMatrix() * transform * vec4(points[0],1.0);
    vec4 point1 = GetWorldToViewMatrix() * transform * vec4(points[1],1.0);
    vec4 point2 = GetWorldToViewMatrix() * transform * vec4(points[2],1.0);
    vec4 point3 = GetWorldToViewMatrix() * transform * vec4(points[3],1.0);

    // Get the indata Neye if provided.
    bool isFlipped = IsFlipped();
    vec3 Neye0 = isFlipped ? -GetNormal(vec3(0),0) : GetNormal(vec3(0),0);
    vec3 Neye1 = isFlipped ? -GetNormal(vec3(0),1) : GetNormal(vec3(0),1);
    vec3 Neye2 = isFlipped ? -GetNormal(vec3(0),2) : GetNormal(vec3(0),2);
    vec3 Neye3 = isFlipped ? -GetNormal(vec3(0),3) : GetNormal(vec3(0),3);

    Neye0 = GetQuadGeometryNormal(
                Neye0, point0, point1, point2, point3, isFlipped);
    Neye1 = GetQuadGeometryNormal(
                Neye1, point0, point1, point2, point3, isFlipped);
    Neye2 = GetQuadGeometryNormal(
                Neye2, point0, point1, point2, point3, isFlipped);
    Neye3 = GetQuadGeometryNormal(
                Neye3, point0, point1, point2, point3, isFlipped);

    point0 = DisplacementTerminal(0, point0, Neye0, GetPatchCoord(0));
    point1 = DisplacementTerminal(1, point1, Neye1, GetPatchCoord(1));
    point2 = DisplacementTerminal(2, point2, Neye2, GetPatchCoord(2));
    point3 = DisplacementTerminal(3, point3, Neye3, GetPatchCoord(3));

    vec3 coord = gl_TessCoord.xy;
    vec4 basis = vec4((1.0-coord.x) * (1.0-coord.y), coord.x * (1.0-coord.y),
                      (1.0-coord.x) * coord.y, coord.x * coord.y);

    outData.Peye = InterpolatePrimvar(point0, point1, point2, point3, basis);
    outData.Neye = InterpolatePrimvar(Neye0, Neye1, Neye2, Neye3, basis);

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ptvsBarycentricCoord = gl_TessCoord;
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(basis, 0, 1, 2, 3);
}

--- --------------------------------------------------------------------------
-- layout Mesh.PostTessVertex.TriQuad

[
    ["out block", "VertexData", "outData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ],
    ["out", "vec2", "ptvsBarycentricCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessVertex.TriQuad

vec4 GetPatchCoord(int index)
{
    vec2 uv[4];
    uv[0] = vec2(0, 0);
    uv[1] = vec2(1, 0);
    uv[2] = vec2(1, 1);
    uv[3] = vec2(0, 1);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoord(uv[index], patchParam);
}

// Fwd declare methods defined in pointId.glslfx, that are used below.
FORWARD_DECL(int GetPointId());
FORWARD_DECL(float GetPointRasterSize(int));
FORWARD_DECL(void ProcessPointId(int));

void main(void)
{
    ProcessPrimvarsIn();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    int pointId = GetPointId();
    gl_PointSize = GetPointRasterSize(pointId);
    ProcessPointId(pointId);

    vec4 point0 = GetWorldToViewMatrix() * transform * vec4(points[0],1.0);
    vec4 point1 = GetWorldToViewMatrix() * transform * vec4(points[1],1.0);
    vec4 point2 = GetWorldToViewMatrix() * transform * vec4(points[2],1.0);
    vec4 point3 = GetWorldToViewMatrix() * transform * vec4(points[4],1.0);

    //Get the indata Neye if provided.
    bool isFlipped = IsFlipped();
    vec3 Neye0 = isFlipped ? -GetNormal(vec3(0),0) : GetNormal(vec3(0),0);
    vec3 Neye1 = isFlipped ? -GetNormal(vec3(0),1) : GetNormal(vec3(0),1);
    vec3 Neye2 = isFlipped ? -GetNormal(vec3(0),2) : GetNormal(vec3(0),2);
    vec3 Neye3 = isFlipped ? -GetNormal(vec3(0),4) : GetNormal(vec3(0),4);

    Neye0 = GetQuadGeometryNormal(Neye0,
                point0, point1, point2, point3, isFlipped);
    Neye1 = GetQuadGeometryNormal(Neye1,
                point0, point1, point2, point3, isFlipped);
    Neye2 = GetQuadGeometryNormal(Neye2,
                point0, point1, point2, point3, isFlipped);
    Neye3 = GetQuadGeometryNormal(Neye3,
                point0, point1, point2, point3, isFlipped);

    point0 = DisplacementTerminal(0, point0, Neye0, GetPatchCoord(0));
    point1 = DisplacementTerminal(1, point1, Neye1, GetPatchCoord(1));
    point2 = DisplacementTerminal(2, point2, Neye2, GetPatchCoord(2));
    point3 = DisplacementTerminal(3, point3, Neye3, GetPatchCoord(3));

    vec2 coord = gl_TessCoord.xy;
    vec4 basis = vec4((1.0-coord.x) * (1.0-coord.y), coord.x * (1.0-coord.y),
                      (1.0-coord.x) * coord.y, coord.x * coord.y);

    outData.Peye = InterpolatePrimvar(point0, point1, point3, point2, basis);
    outData.Neye = InterpolatePrimvar(Neye0, Neye1, Neye3, Neye2, basis);

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ptvsBarycentricCoord = gl_TessCoord;
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(basis, 0, 1, 2, 4);
}

--- --------------------------------------------------------------------------
-- glsl Mesh.TessControl.BSplineQuad

layout(vertices = HD_NUM_PATCH_EVAL_VERTS) out;

patch out vec4 tessOuterLo, tessOuterHi;

in VertexData
{
    vec4 Peye;
    vec3 Neye;
} inpt[gl_MaxPatchVertices];

out VertexDataTess
{
    OsdPerPatchVertexBezier v;
} outpt[HD_NUM_PATCH_EVAL_VERTS];

void main(void)
{
    vec3 cv[HD_NUM_PATCH_VERTS];
    for (int i = 0; i < HD_NUM_PATCH_VERTS; ++i) {
        cv[i] = inpt[i].Peye.xyz;
    }

    ivec3 patchParam = GetPatchParam();

    OsdComputePerPatchVertexBSpline(patchParam, gl_InvocationID, cv,
                                    outpt[gl_InvocationID].v);

    // Wait for all basis conversion to be finished
    barrier();

    if (gl_InvocationID == 0) {
        vec4 tessLevelOuter = vec4(0);
        vec2 tessLevelInner = vec2(0);

        // Gather bezier control points to compute limit surface tess levels
        OsdPerPatchVertexBezier cpBezier[HD_NUM_PATCH_EVAL_VERTS];
        for (int i = 0; i < HD_NUM_PATCH_EVAL_VERTS; ++i) {
            cpBezier[i] = outpt[i].v;
        }
        HdStEvalPatchBezierTessLevels(cpBezier, patchParam,
                                     tessLevelOuter, tessLevelInner,
                                     tessOuterLo, tessOuterHi);

        gl_TessLevelOuter[0] = tessLevelOuter[0];
        gl_TessLevelOuter[1] = tessLevelOuter[1];
        gl_TessLevelOuter[2] = tessLevelOuter[2];
        gl_TessLevelOuter[3] = tessLevelOuter[3];

        gl_TessLevelInner[0] = tessLevelInner[0];
        gl_TessLevelInner[1] = tessLevelInner[1];
    }

    ProcessPrimvarsOut();
}

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessControl.BSplineQuad
 // OsdPerPatchVertexBezier - used to trigger codegen
struct VertexData
{
    vec4 Peye;
    vec3 Neye;
};

// convert BSpline cv to Bezier cv
template<typename VertexType>
vec3
HdStComputePerPatchVertexBSpline(
        int3 patchParam, unsigned ID,
        thread VertexType* cv)
{
    vec3 result;
    int i = ID%4;
    int j = ID/4;

    //OsdComputeBSplineBoundaryPoints(cv, patchParam);

    float3 H[4];
    for (int l=0; l<4; ++l) {
        H[l] = float3(0,0,0);
        for(int k=0; k<4; ++k) {
            H[l] += Q[i][k] * (cv + l*4 + k)->GetPosition();
        }
    }
    {
        result = float3(0,0,0);
        for (int k=0; k<4; ++k){
            result += Q[j][k]*H[k];
        }
    }
    return result;
}

void
HdStEvalPatchBezierTessLevels(
        const float OsdTessLevel,
        const float4x4 OsdProjectionMatrix,
        const float4x4 OsdModelViewMatrix,
        thread vec3* cpBezier,
        int3 patchParam,
        thread float4& tessOuterLo, thread float4& tessOuterHi)
{

    tessOuterLo = float4(0);
    tessOuterHi = float4(0);

    float3 corners[4];
    float3 midpoints[4];

    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    //These are compressed for PTCS as we only want to evaluate the mid and corners
    /*
    7 -> 5
    8 -> 6
    11 -> 7
    12 -> 8
    13 -> 9
    14 -> 10
    15 -> 11
     */
    /*
    corners[0] = cpBezier[ 0];
    corners[1] = cpBezier[ 3];
    corners[2] = cpBezier[11];
    corners[3] = cpBezier[12];
*/
    /*
    midpoints[0] = ((transitionMask & 8) == 0) ? float3(0) :
        Osd_EvalBezierCurveMidPoint(
            cpBezier[0], cpBezier[4], cpBezier[5], cpBezier[8]);
    midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :
        Osd_EvalBezierCurveMidPoint(
            cpBezier[0], cpBezier[1], cpBezier[2], cpBezier[3]);
    midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :
        Osd_EvalBezierCurveMidPoint(
            cpBezier[3], cpBezier[5], cpBezier[7], cpBezier[11]);
    midpoints[3] = ((transitionMask & 4) == 0) ? float3(0) :
        Osd_EvalBezierCurveMidPoint(
            cpBezier[8], cpBezier[9], cpBezier[10], cpBezier[11]);
           */

    corners[0] = cpBezier[ 0];
corners[1] = cpBezier[ 3];
corners[2] = cpBezier[15];
corners[3] = cpBezier[12];

midpoints[0] = ((transitionMask & 8) == 0) ? float3(0) :
Osd_EvalBezierCurveMidPoint(
        cpBezier[0], cpBezier[4], cpBezier[8], cpBezier[12]);
midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :
Osd_EvalBezierCurveMidPoint(
        cpBezier[0], cpBezier[1], cpBezier[2], cpBezier[3]);
midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :
Osd_EvalBezierCurveMidPoint(
        cpBezier[3], cpBezier[7], cpBezier[11], cpBezier[15]);
midpoints[3] = ((transitionMask & 4) == 0) ? float3(0) :
Osd_EvalBezierCurveMidPoint(
        cpBezier[12], cpBezier[13], cpBezier[14], cpBezier[15]);

    Osd_GetTessLevelsFromPatchBoundaries4(
        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
        corners, midpoints, patchParam, tessOuterLo, tessOuterHi);
}

void
HdSt_GetTessLevelsFromPatchBoundaries4(
        const float OsdTessLevel,
        const float4x4 OsdProjectionMatrix,
        const float4x4 OsdModelViewMatrix,
        float3 corners[4],
        float3 midpoints[4],
        int3 patchParam,
        thread float4& tessOuterLo, thread float4& tessOuterHi)
{
    tessOuterLo = float4(0);
    tessOuterHi = float4(0);

    int transitionMask = OsdGetPatchTransitionMask(patchParam);

        tessOuterLo[0] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[0], corners[3]);


        tessOuterLo[1] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[0], corners[1]);


        tessOuterLo[2] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[1], corners[2]);

        tessOuterLo[3] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[3], corners[2]);

}

vec3 GetPosAtUv(vec2 uv, OsdPatchParam param, thread vec3 *cv) {
    //TODO THOR we really want an alternative to all the data being passed in here
    float wP[HD_NUM_PATCH_VERTS];
    float wDs[HD_NUM_PATCH_VERTS];
    float wDt[HD_NUM_PATCH_VERTS];
    float wDss[HD_NUM_PATCH_VERTS];
    float wDst[HD_NUM_PATCH_VERTS];
    float wDtt[HD_NUM_PATCH_VERTS];
    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_REGULAR, param, uv.x, uv.y, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));

    vec3 pos = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < 16; i++) {
        pos += cv[i] * wP[i];
    }
    return pos;
}

struct PositionWrapper
{
    vec3 pos;
    vec3 GetPosition() thread {
        return pos;
    }
    vec3 SetPosition(vec3 newPos) thread {
        pos = newPos;
    }
};

void main(void)
{
    ProcessPrimvarsIn();

    MAT4 transform = ApplyInstanceTransform(HdGet_transform());


    ivec3 patchParam = GetPatchParam();

    //Consider if we are doing the work multiple times
    const vec2 corner0Uv = vec2(0.0, 0.0);
    const vec2 corner1Uv = vec2(1.0, 0.0);
    const vec2 corner2Uv = vec2(1.0, 1.0);
    const vec2 corner3Uv = vec2(0.0, 1.0);
    OsdPatchParam osdParam = OsdPatchParamInit(patchParam.x, patchParam.y, 0);
    vec3 corners[4];
    //TODO Thor reconsider this - maybe the arrays don't need to be recreated inside the function
    corners[0] = GetPosAtUv(corner0Uv, osdParam, &(points[0]));
    corners[1] = GetPosAtUv(corner1Uv, osdParam, &(points[0]));
    corners[2] = GetPosAtUv(corner2Uv, osdParam, &(points[0]));
    corners[3] = GetPosAtUv(corner3Uv, osdParam, &(points[0]));
    vec3 midPoints[4];
    midPoints[0] = (corners[0] + corners[1]) / 2.0;
    midPoints[1] = (corners[1] + corners[2]) / 2.0;
    midPoints[2] = (corners[2] + corners[0]) / 2.0;
    midPoints[3] = (corners[2] + corners[0]) / 2.0;

    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    midPoints[0] = ((transitionMask & 8) == 0) ? float3(0) : GetPosAtUv(float2(0.0, 0.5), osdParam, &(points[0]));
    midPoints[1] = ((transitionMask & 2) == 0) ? float3(0) : GetPosAtUv(float2(0.5, 0.0), osdParam, &(points[0]));
    midPoints[2] = ((transitionMask & 2) == 0) ? float3(0) : GetPosAtUv(float2(1.0, 0.5), osdParam, &(points[0]));
    midPoints[3] = ((transitionMask & 4) == 0) ? float3(0) : GetPosAtUv(float2(0.5, 1.0), osdParam, &(points[0]));

    vec4 tessLevelOuter = vec4(0);
    vec2 tessLevelInner = vec2(0);
    vec4 tessOuterLo = vec4(0);
    vec4 tessOuterHi = vec4(0);

    // Gather bezier control points to compute limit surface tess levels
    HdSt_GetTessLevelsFromPatchBoundaries4(
       renderPassState.tessLevel, GetProjectionMatrix(), mat4(1),
        corners, midPoints, patchParam, tessOuterLo, tessOuterHi);

    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);

    device half* tessAsHalf = (device half*)tessFactors + patch_id * 6;
    tessAsHalf[0] = half(tessLevelOuter[0]);
    tessAsHalf[1] = half(tessLevelOuter[1]);
    tessAsHalf[2] = half(tessLevelOuter[2]);
    tessAsHalf[3] = half(tessLevelOuter[3]);

    tessAsHalf[4] = half(tessLevelInner[0]);
    tessAsHalf[5] = half(tessLevelInner[1]);
}

--- --------------------------------------------------------------------------
-- glsl Mesh.TessEval.BezierQuad

layout(quads) in;

patch in vec4 tessOuterLo, tessOuterHi;

in VertexDataTess {
    OsdPerPatchVertexBezier v;
} inpt[gl_MaxPatchVertices];

out VertexData
{
    vec4 Peye;
    vec3 Neye;
} outData;

// XXX: due to NVIDIA shader compiler bug (filed as 1687344)
// we can't put patchCoord into interface block.
out vec4 tesPatchCoord;
out vec2 tesTessCoord;

void main(void)
{
    OsdPerPatchVertexBezier cv[16];
    for (int i = 0; i < 16; ++i) {
        cv[i] = inpt[i].v;
    }
    vec2 UV = OsdGetTessParameterization(gl_TessCoord.xy,
                                         tessOuterLo,
                                         tessOuterHi);

    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);
    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);

    ivec3 patchParam = inpt[0].v.patchParam;
    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);

    outData.Peye = vec4(P, 1);
    outData.Neye = N; // normalized

    tesPatchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    tesTessCoord = UV;

    // Bilinear basis
    vec4 basis = vec4(
        (1.0-UV.x) * (1.0-UV.y), UV.x * (1.0-UV.y),
        (1.0-UV.x) * UV.y, UV.x * UV.y );

    ProcessPrimvarsOut(basis, 5, 6, 9, 10, UV);
}

--- --------------------------------------------------------------------------
-- layout Mesh.PostTessVertex.BezierQuad
[
    ["in", "equal_spacing"],
    ["out block", "VertexData", "outData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ],
    ["out", "vec2", "ptvsBarycentricCoord"],
    ["out", "vec4", "tesPatchCoord"],
    ["out", "vec2", "tesTessCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessVertex.BezierQuad
// OsdPerPatchVertexBezier - used to trigger codegen

void
HdStEvalPatchBezier(int3 patchParam, float2 UV,
                   thread vec3 *cv,
                   thread float3& P, thread float3& dPu, thread float3& dPv,
                   thread float3& N, thread float3& dNu, thread float3& dNv,
                   thread float2& vSegments)
{
    //
    //  Use the recursive nature of the basis functions to compute a 2x2 set
    //  of intermediate points (via repeated linear interpolation).  These
    //  points define a bilinear surface tangent to the desired surface at P
    //  and so containing dPu and dPv.  The cost of computing P, dPu and dPv
    //  this way is comparable to that of typical tensor product evaluation
    //  (if not faster).
    //
    //  If N = dPu X dPv degenerates, it often results from an edge of the
    //  2x2 bilinear hull collapsing or two adjacent edges colinear. In both
    //  cases, the expected non-planar quad degenerates into a triangle, and
    //  the tangent plane of that triangle provides the desired normal N.
    //

    //  Reduce 4x4 points to 2x4 -- two levels of linear interpolation in U
    //  and so 3 original rows contributing to each of the 2 resulting rows:
    float u    = UV.x;
    float uinv = 1.0f - u;

    float u0 = uinv * uinv;
    float u1 = u * uinv * 2.0f;
    float u2 = u * u;

    float3 LROW[4], RROW[4];

    LROW[0] = u0 * cv[ 0] + u1 * cv[ 1] + u2 * cv[ 2];
    LROW[1] = u0 * cv[ 4] + u1 * cv[ 5] + u2 * cv[ 6];
    LROW[2] = u0 * cv[ 8] + u1 * cv[ 9] + u2 * cv[10];
    LROW[3] = u0 * cv[12] + u1 * cv[13] + u2 * cv[14];

    RROW[0] = u0 * cv[ 1] + u1 * cv[ 2] + u2 * cv[ 3];
    RROW[1] = u0 * cv[ 5] + u1 * cv[ 6] + u2 * cv[ 7];
    RROW[2] = u0 * cv[ 9] + u1 * cv[10] + u2 * cv[11];
    RROW[3] = u0 * cv[13] + u1 * cv[14] + u2 * cv[15];

    //  Reduce 2x4 points to 2x2 -- two levels of linear interpolation in V
    //  and so 3 original pairs contributing to each of the 2 resulting:
    float v    = UV.y;
    float vinv = 1.0f - v;

    float v0 = vinv * vinv;
    float v1 = v * vinv * 2.0f;
    float v2 = v * v;

    float3 LPAIR[2], RPAIR[2];
    LPAIR[0] = v0 * LROW[0] + v1 * LROW[1] + v2 * LROW[2];
    RPAIR[0] = v0 * RROW[0] + v1 * RROW[1] + v2 * RROW[2];

    LPAIR[1] = v0 * LROW[1] + v1 * LROW[2] + v2 * LROW[3];
    RPAIR[1] = v0 * RROW[1] + v1 * RROW[2] + v2 * RROW[3];

    //  Interpolate points on the edges of the 2x2 bilinear hull from which
    //  both position and partials are trivially determined:
    float3 DU0 = vinv * LPAIR[0] + v * LPAIR[1];
    float3 DU1 = vinv * RPAIR[0] + v * RPAIR[1];
    float3 DV0 = uinv * LPAIR[0] + u * RPAIR[0];
    float3 DV1 = uinv * LPAIR[1] + u * RPAIR[1];

    int level = OsdGetPatchFaceLevel(patchParam);
    dPu = (DU1 - DU0) * 3 * level;
    dPv = (DV1 - DV0) * 3 * level;

    P = u * DU1 + uinv * DU0;

    //  Compute the normal and test for degeneracy:
    //
    //  We need a geometric measure of the size of the patch for a suitable
    //  tolerance.  Magnitudes of the partials are generally proportional to
    //  that size -- the sum of the partials is readily available, cheap to
    //  compute, and has proved effective in most cases (though not perfect).
    //  The size of the bounding box of the patch, or some approximation to
    //  it, would be better but more costly to compute.
    //
    float proportionalNormalTolerance = 0.00001f;

    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;

    N = cross(dPu, dPv);

    float nLength = length(N);
    if (nLength > nEpsilon) {
        N = N / nLength;
    } else {
        float3 diagCross = cross(RPAIR[1] - LPAIR[0], LPAIR[1] - RPAIR[0]);
        float diagCrossLength = length(diagCross);
        if (diagCrossLength > nEpsilon) {
            N = diagCross / diagCrossLength;
        }
    }
    //
    //  Compute 2nd order partials of P(u,v) in order to compute 1st order partials
    //  for the un-normalized n(u,v) = dPu X dPv, then project into the tangent
    //  plane of normalized N.  With resulting dNu and dNv we can make another
    //  attempt to resolve a still-degenerate normal.
    //
    //  We don't use the Weingarten equations here as they require N != 0 and also
    //  are a little less numerically stable/accurate in single precision.
    //
    float B0u[4], B1u[4], B2u[4];
    float B0v[4], B1v[4], B2v[4];

    OsdUnivar4x4(UV.x, B0u, B1u, B2u);
    OsdUnivar4x4(UV.y, B0v, B1v, B2v);

    float3 dUU = float3(0,0,0);
    float3 dVV = float3(0,0,0);
    float3 dUV = float3(0,0,0);

    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {

            float3 CV = cv[4*i + j];
            dUU += (B0v[i] * B2u[j]) * CV;
            dVV += (B2v[i] * B0u[j]) * CV;
            dUV += (B1v[i] * B1u[j]) * CV;
        }
    }

    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;

    dNu = cross(dUU, dPv) + cross(dPu, dUV);
    dNv = cross(dUV, dPv) + cross(dPu, dVV);

    float nLengthInv = 1.0;
    if (nLength > nEpsilon) {
        nLengthInv = 1.0 / nLength;
    } else {
        //  N may have been resolved above if degenerate, but if N was resolved
        //  we don't have an accurate length for its un-normalized value, and that
        //  length is needed to project the un-normalized dNu and dNv into the
        //  tangent plane of N.
        //
        //  So compute N more accurately with available second derivatives, i.e.
        //  with a 1st order Taylor approximation to un-normalized N(u,v).

        float DU = (UV.x == 1.0f) ? -1.0f : 1.0f;
        float DV = (UV.y == 1.0f) ? -1.0f : 1.0f;

        N = DU * dNu + DV * dNv;

        nLength = length(N);
        if (nLength > nEpsilon) {
            nLengthInv = 1.0f / nLength;
            N = N * nLengthInv;
        }
    }

    //  Project derivatives of non-unit normals into tangent plane of N:
    dNu = (dNu - dot(dNu,N) * N) * nLengthInv;
    dNv = (dNv - dot(dNv,N) * N) * nLengthInv;
}


//TODO Thor verify this
vec4 GetPatchCoord(int index)
{
    vec2 uv[4];
    uv[0] = vec2(0, 0);
    uv[1] = vec2(1, 0);
    uv[2] = vec2(1, 1);
    uv[3] = vec2(0, 1);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoord(uv[index], patchParam);
}

void main(void)
{
    ProcessPrimvarsIn();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    int pointId = GetPointId();
    gl_PointSize = GetPointRasterSize(pointId);
    ProcessPointId(pointId);

    ivec3 patchParam = GetPatchParam();


    //TODO may want to know cv and patch param
    float4 tessOuterLo(0), tessOuterHi(0);
    //TODO HIGHLY LIKELY THAT we need
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    //float tessLevel = min(frameConsts.TessLevel, (float)OSD_MAX_TESS_LEVEL) /
    //                  exp2((float)refinementLevel - 1);
    float tessLevel = min(renderPassState.tessLevel, (float)OSD_MAX_TESS_LEVEL) /
                      exp2((float)refinementLevel - 1);
    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);
    //TODO Thor move tess outer lo and hi from ptcs
    vec2 UV = OsdGetTessParameterization(gl_TessCoord.xy,
                                         tessOuterLo,
                                         tessOuterHi);

    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);
    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);

    float wP[HD_NUM_PATCH_VERTS];
    float wDs[HD_NUM_PATCH_VERTS];
    float wDt[HD_NUM_PATCH_VERTS];
    float wDss[HD_NUM_PATCH_VERTS];
    float wDst[HD_NUM_PATCH_VERTS];
    float wDtt[HD_NUM_PATCH_VERTS];
    //int boundaryMask = OsdPatchParamGetBoundary(patchParam);
    OsdPatchParam osdParam = OsdPatchParamInit(patchParam.x, patchParam.y, 0);
    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_REGULAR, osdParam, UV.x, UV.y, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));
    //if (boundaryMask != 0) {
    //        Osd_boundBasisBoxSplineTri(
    //            boundaryMask, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]) &(wDtt[0]);
   //}

    vec3 p2 = vec3(0.0);
    vec3 p3 = vec3(0.0);
    for (int i = 0; i < 16; i++) {
        P +=  points[i] * wP[i];
    }
    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_REGULAR, osdParam, UV.x + 0.01, UV.y, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));
    for (int i = 0; i < 16; i++) {
        p2 +=  points[i] * wP[i];
    }

    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_REGULAR, osdParam, UV.x, UV.y + 0.01, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));
    for (int i = 0; i < 16; i++) {
        p3 +=  points[i] * wP[i];
    }

    P = (GetWorldToViewMatrix() * transform * vec4(P,1.0)).xyz;
    p2 = (GetWorldToViewMatrix() * transform * vec4(p2,1.0)).xyz;
    p3 = (GetWorldToViewMatrix() * transform * vec4(p3,1.0)).xyz;
    N = normalize(cross(P - p2,P - p3));

    outData.Peye = vec4(P, 1);
    //TODO THOR Maybve we need to multiply by projection matrix
    outData.Neye = N; // normalized

    tesPatchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    tesTessCoord = UV;

    // Bilinear basis
    vec4 basis = vec4(
            (1.0-UV.x) * (1.0-UV.y), UV.x * (1.0-UV.y),
            (1.0-UV.x) * UV.y, UV.x * UV.y );

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    //ptvsBarycentricCoord = gl_TessCoord;
    ptvsBarycentricCoord = UV;
    ProcessPrimvarsOut(basis, 5, 6, 9, 10, UV);
    ApplyClipPlanes(outData.Peye);

    //ProcessPrimvarsOut(basis, 0, 1, 2, 3);
}

--- --------------------------------------------------------------------------
-- glsl Mesh.TessControl.BoxSplineTriangle

layout(vertices = HD_NUM_PATCH_EVAL_VERTS) out;

patch out vec4 tessOuterLo, tessOuterHi;

in VertexData
{
    vec4 Peye;
    vec3 Neye;
} inpt[gl_MaxPatchVertices];

out VertexDataTess
{
    OsdPerPatchVertexBezier v;
} outpt[HD_NUM_PATCH_EVAL_VERTS];

void main(void)
{
    vec3 cv[HD_NUM_PATCH_VERTS];
    for (int i = 0; i < HD_NUM_PATCH_VERTS; ++i) {
        cv[i] = inpt[i].Peye.xyz;
    }

    ivec3 patchParam = GetPatchParam();

    OsdComputePerPatchVertexBoxSplineTriangle(patchParam, gl_InvocationID, cv,
                                              outpt[gl_InvocationID].v);

    // Wait for all basis conversion to be finished
    barrier();

    if (gl_InvocationID == 0) {
        vec4 tessLevelOuter = vec4(0);
        vec2 tessLevelInner = vec2(0);
        // Gather bezier control points to compute limit surface tess levels
        vec3 cpBezier[HD_NUM_PATCH_EVAL_VERTS];
        for (int i = 0; i < HD_NUM_PATCH_EVAL_VERTS; ++i) {
            cpBezier[i] = outpt[i].v.P;
        }
        OsdEvalPatchBezierTriangleTessLevels(cpBezier, patchParam,
                                            tessLevelOuter, tessLevelInner,
                                            tessOuterLo, tessOuterHi);

        gl_TessLevelOuter[0] = tessLevelOuter[0];
        gl_TessLevelOuter[1] = tessLevelOuter[1];
        gl_TessLevelOuter[2] = tessLevelOuter[2];

        gl_TessLevelInner[0] = tessLevelInner[0];
    }

    ProcessPrimvarsOut();
}

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessControl.BoxSplineTriangle
// OsdPerPatchVertexBezier - used to trigger codegen

template<typename VertexType>
vec3
HdStComputePerPatchVertexBoxSplineTriangle(
        int3 patchParam, int ID,
        thread VertexType* cv)
{
    //
    //  Conversion matrix from 12-point Box spline to 15-point quartic Bezier
    //  patch and its common scale factor:
    //
    const float boxToBezierMatrix[12*15] = {
            // L0   L1   L2     L3   L4   L5   L6     L7   L8   L9     L10  L11
            2,   2,   0,     2,  12,   2,   0,     2,   2,   0,     0,   0,  // B0
            1,   3,   0,     0,  12,   4,   0,     1,   3,   0,     0,   0,  // B1
            0,   4,   0,     0,   8,   8,   0,     0,   4,   0,     0,   0,  // B2
            0,   3,   1,     0,   4,  12,   0,     0,   3,   1,     0,   0,  // B3
            0,   2,   2,     0,   2,  12,   2,     0,   2,   2,     0,   0,  // B4
            0,   1,   0,     1,  12,   3,   0,     3,   4,   0,     0,   0,  // B5
            0,   1,   0,     0,  10,   6,   0,     1,   6,   0,     0,   0,  // B6
            0,   1,   0,     0,   6,  10,   0,     0,   6,   1,     0,   0,  // B7
            0,   1,   0,     0,   3,  12,   1,     0,   4,   3,     0,   0,  // B8
            0,   0,   0,     0,   8,   4,   0,     4,   8,   0,     0,   0,  // B9
            0,   0,   0,     0,   6,   6,   0,     1,  10,   1,     0,   0,  // B10
            0,   0,   0,     0,   4,   8,   0,     0,   8,   4,     0,   0,  // B11
            0,   0,   0,     0,   4,   3,   0,     3,  12,   1,     1,   0,  // B12
            0,   0,   0,     0,   3,   4,   0,     1,  12,   3,     0,   1,  // B13
            0,   0,   0,     0,   2,   2,   0,     2,  12,   2,     2,   2   // B14
    };
    const float boxToBezierMatrixScale = 1.0 / 24.0;

    //result.patchParam = patchParam;
    vec3 result = float3(0);

    int cvCoeffBase = 12 * ID;

    for (int i = 0; i < 12; ++i) {
        result += boxToBezierMatrix[cvCoeffBase + i] * cv[i].GetPosition();
    }
        result *= boxToBezierMatrixScale;
    return result;
}

void
HdStEvalPatchBezierTriangleTessLevels(
        const float OsdTessLevel,
        const float4x4 OsdProjectionMatrix,
        const float4x4 OsdModelViewMatrix,
        thread vec3* cv,
        int3 patchParam,
        thread float4& tessOuterLo, thread float4& tessOuterHi)
{
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. When the patch control
    // points have been converted to the Bezier basis, the control points
    // at the corners are on the limit surface (since a Bezier patch
    // interpolates its corner control points). We can compute an adaptive
    // tessellation level for transition edges on the limit surface by
    // evaluating a limit position at the mid point of each transition edge.

    tessOuterLo = float4(0);
    tessOuterHi = float4(0);

    int transitionMask = OsdGetPatchTransitionMask(patchParam);

    float3 corners[3];
    corners[0] = cv[0];
    corners[1] = cv[4];
    corners[2] = cv[14];

    float3 midpoints[3];
    midpoints[0] = ((transitionMask & 4) == 0) ? float3(0) :
        Osd_EvalQuarticBezierCurveMidPoint(cv[0], cv[5], cv[9], cv[12], cv[14]);
    midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :
        Osd_EvalQuarticBezierCurveMidPoint(cv[0], cv[1], cv[2], cv[3], cv[4]);
    midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :
        Osd_EvalQuarticBezierCurveMidPoint(cv[4], cv[8], cv[11], cv[13], cv[14]);

    Osd_GetTessLevelsFromPatchBoundaries3(
        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
        corners, midpoints, patchParam, tessOuterLo, tessOuterHi);
}

vec3 GetPosAtUv(vec2 uv, OsdPatchParam param, thread vec3 *cv) {
    //TODO THOR we really want an alternative to all the data being passed in here
    float wP[HD_NUM_PATCH_VERTS];
    float wDs[HD_NUM_PATCH_VERTS];
    float wDt[HD_NUM_PATCH_VERTS];
    float wDss[HD_NUM_PATCH_VERTS];
    float wDst[HD_NUM_PATCH_VERTS];
    float wDtt[HD_NUM_PATCH_VERTS];
    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_LOOP, param, uv.x, uv.y, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));

    vec3 pos = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < 12; i++) {
        pos += cv[i] * wP[i];
    }
    return pos;
}

void
HdSt_GetTessLevelsFromPatchBoundaries3(
        const float OsdTessLevel,
        const float4x4 OsdProjectionMatrix,
        const float4x4 OsdModelViewMatrix,
        float3 corners[3],
        int3 patchParam,
        thread float4& tessOuterLo, thread float4& tessOuterHi)
{
    tessOuterLo = float4(0);
    tessOuterHi = float4(0);

        tessOuterLo[0] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[0], corners[2]);

        tessOuterLo[1] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[0], corners[1]);

        tessOuterLo[2] = OsdComputeTessLevel(
            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,
            corners[1], corners[2]);
}

void main(void)
{
    ProcessPrimvarsIn();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    ivec3 patchParam = GetPatchParam();

    const vec2 corner0Uv = vec2(0.0, 1.0);
    const vec2 corner1Uv = vec2(1.0, 0.0);
    const vec2 corner2Uv = vec2(0.0, 0.0);
    OsdPatchParam osdParam = OsdPatchParamInit(patchParam.x, patchParam.y, 0);
    vec3 corners[3];
    //TODO Thor reconsider this - maybe the arrays don't need to be recreated inside the function
    corners[0] = GetPosAtUv(corner0Uv, osdParam, &(points[0]));
    corners[1] = GetPosAtUv(corner1Uv, osdParam, &(points[0]));
    corners[2] = GetPosAtUv(corner2Uv, osdParam, &(points[0]));
    vec3 midPoints[3];
    //midPoints[0] = (corners[0] + corners[1]) / 2.0;
    //midPoints[1] = (corners[1] + corners[2]) / 2.0;
    //midPoints[2] = (corners[2] + corners[0]) / 2.0;

    //midPoints[0] = GetPosAtUv((corner0Uv + corner1Uv)/2.0, &(cv[0]));
    //midPoints[1] = GetPosAtUv((corner1Uv + corner2Uv)/2.0, &(cv[0]));
    //midPoints[2] = GetPosAtUv((corner2Uv + corner0Uv)/2.0, &(cv[0]));

    vec4 tessLevelOuter = vec4(0);
    vec2 tessLevelInner = vec2(0);
    vec4 tessOuterLo = vec4(0);
    vec4 tessOuterHi = vec4(0);
    HdSt_GetTessLevelsFromPatchBoundaries3(
       renderPassState.tessLevel, GetProjectionMatrix(), mat4(1),
        corners, patchParam, tessOuterLo, tessOuterHi);
    

    OsdComputeTessLevelsTriangle(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);

    device half* tessAsHalf = (device half*)tessFactors + patch_id * 6;
    int outer0 = tessLevelOuter[0];
    int outer1 = tessLevelOuter[1];
    int outer2 = tessLevelOuter[2];
    int outer3 = tessLevelOuter[3];

    int inner0 = tessLevelInner[0];
    int inner1 = tessLevelInner[1];
    tessAsHalf[0] = half(clamp(outer0, 1, 32));
    tessAsHalf[1] = half(clamp(outer1, 1, 32));
    tessAsHalf[2] = half(clamp(outer2, 1, 32));
    tessAsHalf[3] = half(clamp(outer3, 1, 32));

    tessAsHalf[4] = half(clamp(inner0, 0, 32));
    tessAsHalf[5] = half(clamp(inner1, 0, 32));
}

--- --------------------------------------------------------------------------
-- glsl Mesh.TessEval.BezierTriangle

layout(triangles) in;

patch in vec4 tessOuterLo, tessOuterHi;

in VertexDataTess {
    OsdPerPatchVertexBezier v;
} inpt[gl_MaxPatchVertices];

out VertexData
{
    vec4 Peye;
    vec3 Neye;
} outData;

// XXX: due to NVIDIA shader compiler bug (filed as 1687344)
// we can't put patchCoord into interface block.
out vec4 tesPatchCoord;
out vec2 tesTessCoord;

void main(void)
{
    OsdPerPatchVertexBezier cv[15];
    for (int i = 0; i < 15; ++i) {
        cv[i] = inpt[i].v;
    }
    vec2 UV = OsdGetTessParameterizationTriangle(gl_TessCoord.xyz,
                                                 tessOuterLo,
                                                 tessOuterHi);

    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);
    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);

    ivec3 patchParam = inpt[0].v.patchParam;
    OsdEvalPatchBezierTriangle(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);

    outData.Peye = vec4(P, 1);
    outData.Neye = N; // normalized

    tesPatchCoord = OsdInterpolatePatchCoordTriangle(UV, patchParam);
    tesTessCoord = UV;

    // Barycentric basis
    vec4 basis = vec4(
        (1.0f-UV.x-UV.y), UV.x, UV.y, 0.0f);

    ProcessPrimvarsOut(basis, 4, 5, 8, 0, UV);
}

--- --------------------------------------------------------------------------
-- layout Mesh.PostTessVertex.BezierTriangle

[
    ["in", "equal_spacing"],
    ["out block", "VertexData", "outData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ],
    ["out", "vec3", "ptvsBarycentricCoord"],
    ["out", "vec4", "tesPatchCoord"],
    ["out", "vec2", "tesTessCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessVertex.BezierTriangle
// OsdPerPatchVertexBezier - used to trigger codegen

template<typename VertexType>
vec3
HdStComputePerPatchVertexBoxSplineTriangle(
        int3 patchParam, int ID,
        thread VertexType* cv)
{
    //
    //  Conversion matrix from 12-point Box spline to 15-point quartic Bezier
    //  patch and its common scale factor:
    //
    const float boxToBezierMatrix[12*15] = {
            // L0   L1   L2     L3   L4   L5   L6     L7   L8   L9     L10  L11
            2,   2,   0,     2,  12,   2,   0,     2,   2,   0,     0,   0,  // B0
            1,   3,   0,     0,  12,   4,   0,     1,   3,   0,     0,   0,  // B1
            0,   4,   0,     0,   8,   8,   0,     0,   4,   0,     0,   0,  // B2
            0,   3,   1,     0,   4,  12,   0,     0,   3,   1,     0,   0,  // B3
            0,   2,   2,     0,   2,  12,   2,     0,   2,   2,     0,   0,  // B4
            0,   1,   0,     1,  12,   3,   0,     3,   4,   0,     0,   0,  // B5
            0,   1,   0,     0,  10,   6,   0,     1,   6,   0,     0,   0,  // B6
            0,   1,   0,     0,   6,  10,   0,     0,   6,   1,     0,   0,  // B7
            0,   1,   0,     0,   3,  12,   1,     0,   4,   3,     0,   0,  // B8
            0,   0,   0,     0,   8,   4,   0,     4,   8,   0,     0,   0,  // B9
            0,   0,   0,     0,   6,   6,   0,     1,  10,   1,     0,   0,  // B10
            0,   0,   0,     0,   4,   8,   0,     0,   8,   4,     0,   0,  // B11
            0,   0,   0,     0,   4,   3,   0,     3,  12,   1,     1,   0,  // B12
            0,   0,   0,     0,   3,   4,   0,     1,  12,   3,     0,   1,  // B13
            0,   0,   0,     0,   2,   2,   0,     2,  12,   2,     2,   2   // B14
    };
    const float boxToBezierMatrixScale = 1.0 / 24.0;

    vec3 result = float3(0);

    int cvCoeffBase = 12 * ID;

    for (int i = 0; i < 12; ++i) {
        result += boxToBezierMatrix[cvCoeffBase + i] * cv[i].GetPosition();
    }
        result *= boxToBezierMatrixScale;
    return result;
}

void
HdStEvalPatchBezierTriangle(int3 patchParam, float2 UV,
                        thread vec3 *cv,
                        thread float3& P, thread float3& dPu, thread float3& dPv,
                        thread float3& N, thread float3& dNu, thread float3& dNv)
{
    float u = UV.x;
    float v = UV.y;
    float w = 1.0 - u - v;

    float uu = u * u;
    float vv = v * v;
    float ww = w * w;

    //
    //  When computing normal derivatives, we need 2nd derivatives, so compute
    //  an intermediate quadratic Bezier triangle from which 2nd derivatives
    //  can be easily computed, and which in turn yields the triangle that gives
    //  the position and 1st derivatives.
    //
    //  Quadratic barycentric basis functions (in addition to those above):
    float uv = u * v * 2.0;
    float vw = v * w * 2.0;
    float wu = w * u * 2.0;

    float3 Q0 = ww * cv[ 0] + wu * cv[ 1] + uu * cv[ 2] +
              uv * cv[ 6] + vv * cv[ 9] + vw * cv[ 5];
    float3 Q1 = ww * cv[ 1] + wu * cv[ 2] + uu * cv[ 3] +
              uv * cv[ 7] + vv * cv[10] + vw * cv[ 6];
    float3 Q2 = ww * cv[ 2] + wu * cv[ 3] + uu * cv[ 4] +
              uv * cv[ 8] + vv * cv[11] + vw * cv[ 7];
    float3 Q3 = ww * cv[ 5] + wu * cv[ 6] + uu * cv[ 7] +
              uv * cv[10] + vv * cv[12] + vw * cv[ 9];
    float3 Q4 = ww * cv[ 6] + wu * cv[ 7] + uu * cv[ 8] +
              uv * cv[11] + vv * cv[13] + vw * cv[10];
    float3 Q5 = ww * cv[ 9] + wu * cv[10] + uu * cv[11] +
              uv * cv[13] + vv * cv[14] + vw * cv[12];

    float3 V0 = w * Q0 + u * Q1 + v * Q3;
    float3 V1 = w * Q1 + u * Q2 + v * Q4;
    float3 V2 = w * Q3 + u * Q4 + v * Q5;

    //
    //  Compute P, du and dv all from the triangle formed from the three Vi:
    //
    P = w * V0 + u * V1 + v * V2;

    int dSign = OsdGetPatchIsTriangleRotated(patchParam) ? -1 : 1;
    int level = OsdGetPatchFaceLevel(patchParam);

    float d1Scale = dSign * level * 4;

    dPu = (V1 - V0) * d1Scale;
    dPv = (V2 - V0) * d1Scale;

    //  Compute N and test for degeneracy:
    //
    //  We need a geometric measure of the size of the patch for a suitable
    //  tolerance.  Magnitudes of the partials are generally proportional to
    //  that size -- the sum of the partials is readily available, cheap to
    //  compute, and has proved effective in most cases (though not perfect).
    //  The size of the bounding box of the patch, or some approximation to
    //  it, would be better but more costly to compute.
    //
    float proportionalNormalTolerance = 0.00001f;

    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;

    N = cross(dPu, dPv);
    float nLength = length(N);

    //
    //  Compute normal derivatives using 2nd order partials, then use the
    //  normal derivatives to resolve a degenerate normal:
    //
    float d2Scale = dSign * level * level * 12;

    float3 dUU = (Q0 - 2 * Q1 + Q2)  * d2Scale;
    float3 dVV = (Q0 - 2 * Q3 + Q5)  * d2Scale;
    float3 dUV = (Q0 - Q1 + Q4 - Q3) * d2Scale;

    dNu = cross(dUU, dPv) + cross(dPu, dUV);
    dNv = cross(dUV, dPv) + cross(dPu, dVV);

    if (nLength < nEpsilon) {
        //  Use 1st order Taylor approximation of N(u,v) within patch interior:
        if (w > 0.0) {
            N =  dNu + dNv;
        } else if (u >= 1.0) {
            N = -dNu + dNv;
        } else if (v >= 1.0) {
            N =  dNu - dNv;
        } else {
            N = -dNu - dNv;
        }

        nLength = length(N);
        if (nLength < nEpsilon) {
            nLength = 1.0;
        }
    }
    N = N / nLength;

    //  Project derivs of non-unit normal function onto tangent plane of N:
    dNu = (dNu - dot(dNu,N) * N) / nLength;
    dNv = (dNv - dot(dNv,N) * N) / nLength;
}

vec4 GetPatchCoord(int index)
{
    vec2 uv[3];
    uv[0] = vec2(0, 0); // (0, 0, 1);
    uv[1] = vec2(1, 0); // (1, 0, 0);
    uv[2] = vec2(0, 1); // (0, 1, 0);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoordTriangle(uv[index], patchParam);
}

struct PositionWrapper
{
    vec3 pos;
    vec3 GetPosition() thread {
        return pos;
    }
    vec3 SetPosition(vec3 newPos) thread {
        pos = newPos;
    }
};


void main(void)
{
    ProcessPrimvarsIn();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    int pointId = GetPointId();
    gl_PointSize = GetPointRasterSize(pointId);
    ProcessPointId(pointId);


    ivec3 patchParam = GetPatchParam();

    float4 tessOuterLo(0), tessOuterHi(0);
    //TODO HIGHLY LIKELY THAT we need
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    //float tessLevel = min(frameConsts.TessLevel, (float)OSD_MAX_TESS_LEVEL) /
    //                  exp2((float)refinementLevel - 1);
    float tessLevel = min(renderPassState.tessLevel, (float)OSD_MAX_TESS_LEVEL) /
                      exp2((float)refinementLevel - 1);
    OsdGetTessLevelsUniformTriangle(tessLevel, patchParam, tessOuterLo, tessOuterHi);
    //TODO Thor move tess outer lo and hi from ptcs

    vec2 UV = OsdGetTessParameterizationTriangle(gl_TessCoord.xyz,
                                                 tessOuterLo,
                                                 tessOuterHi);

    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);
    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);
                         P, dPu, dPv, N, dNu, dNv);

    float wP[HD_NUM_PATCH_VERTS];
    float wDs[HD_NUM_PATCH_VERTS];
    float wDt[HD_NUM_PATCH_VERTS];
    float wDss[HD_NUM_PATCH_VERTS];
    float wDst[HD_NUM_PATCH_VERTS];
    float wDtt[HD_NUM_PATCH_VERTS];
    //int boundaryMask = OsdPatchParamGetBoundary(patchParam);
    OsdPatchParam osdParam = OsdPatchParamInit(patchParam.x, patchParam.y, 0);
    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_LOOP, osdParam, UV.x, UV.y, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));
    //if (boundaryMask != 0) {
    //        Osd_boundBasisBoxSplineTri(
    //            boundaryMask, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]) &(wDtt[0]);
   //}

    vec3 p2 = vec3(0.0);
    vec3 p3 = vec3(0.0);
    for (int i = 0; i < 12; i++) {
        P +=  points[i] * wP[i];
    }
    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_LOOP, osdParam, UV.x + 0.01, UV.y, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));
    for (int i = 0; i < 12; i++) {
        p2 +=  points[i] * wP[i];
    }

    OsdEvaluatePatchBasisNormalized(OSD_PATCH_DESCRIPTOR_LOOP, osdParam, UV.x, UV.y + 0.01, &(wP[0]), &(wDs[0]), &(wDt[0]), &(wDss[0]), &(wDst[0]), &(wDtt[0]));
    for (int i = 0; i < 12; i++) {
        p3 +=  points[i] * wP[i];
    }
    //maybe this has to be in eye space
    P = (GetWorldToViewMatrix() * transform * vec4(P,1.0)).xyz;
    p2 = (GetWorldToViewMatrix() * transform * vec4(p2,1.0)).xyz;
    p3 = (GetWorldToViewMatrix() * transform * vec4(p3,1.0)).xyz;
    N = normalize(cross(P - p2,P - p3));

    outData.Peye = vec4(P, 1);
    outData.Neye = N; // normalized

    tesPatchCoord = OsdInterpolatePatchCoordTriangle(UV, patchParam);
    tesTessCoord = UV;
    gl_Position =  vec4(GetProjectionMatrix() * outData.Peye);
    //TODO verify this
    ptvsBarycentricCoord = vec3(0.0, UV.y, UV.x);
    //ptvsBarycentricCoord = gl_TessCoord;
    // Barycentric basis
    vec4 basis = vec4(
            (1.0f-UV.x-UV.y), UV.x, UV.y, 0.0f);

    ProcessPrimvarsOut(basis, 4, 5, 8, 0, UV);
    //end
    ApplyClipPlanes(outData.Peye);

}

--- --------------------------------------------------------------------------
-- glsl Mesh.Geometry.TriangleTess

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in VertexData
{
    vec4 Peye;
    vec3 Neye;
} inData[3];

in vec4 tesPatchCoord[3];
in vec2 tesTessCoord[3];

out VertexData
{
    vec4 Peye;
    vec3 Neye;
} outData;

out vec4 gsPatchCoord;

vec4 GetPatchCoord(int index)
{
    return tesPatchCoord[index];
}

void emit(int index, vec4 Peye, vec3 Neye)
{
    outData.Peye = Peye;
    outData.Neye = Neye;
    gsPatchCoord = GetPatchCoord(index);
    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(index, tesTessCoord[index]);

    EmitVertex();
}

FORWARD_DECL(vec4 ComputeSelectionOffset()); // selection.glslfx

void main(void)
{
    gl_PrimitiveID = gl_PrimitiveIDIn;

    bool isFlipped = IsFlipped(); // consider handedness AND negative-scale

    vec3 Neye0 = isFlipped ? -inData[0].Neye : inData[0].Neye;
    Neye0 = GetNormal(Neye0, 0, tesTessCoord[0]);
    Neye0 = GetTriGeometryNormal(Neye0, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);
    vec3 Neye1 = isFlipped ? -inData[1].Neye : inData[1].Neye;
    Neye1 = GetNormal(Neye1, 0, tesTessCoord[1]);
    Neye1 = GetTriGeometryNormal(Neye1, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);
    vec3 Neye2 = isFlipped ? -inData[2].Neye : inData[2].Neye;
    Neye2 = GetNormal(Neye2, 0, tesTessCoord[2]);
    Neye2 = GetTriGeometryNormal(Neye2, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);

    vec4 Peye0 = DisplacementTerminal(
        0, inData[0].Peye, Neye0, GetPatchCoord(0));
    vec4 Peye1 = DisplacementTerminal(
        1, inData[1].Peye, Neye1, GetPatchCoord(1));
    vec4 Peye2 = DisplacementTerminal(
        2, inData[2].Peye, Neye2, GetPatchCoord(2));

    // For wireframe, add a polygon offset to selected faces to ensure they
    // rasterize over unselected faces.
    vec4 selOffset = ComputeSelectionOffset();
    Peye0 += selOffset;
    Peye1 += selOffset;
    Peye2 += selOffset;

    // triangle 0: vertices (0,1,2)
    emit(0, Peye0, Neye0);
    emit(1, Peye1, Neye1);
    emit(2, Peye2, Neye2);

    EndPrimitive();
}

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessVertex.VaryingInterpolation

template <typename T>
T InterpolatePrimvar(
T inPv0, T inPv1, T inPv2, T inPv3, vec4 basis, vec2 uv = vec2()) {
    return
    inPv0 * basis[0] +
    inPv1 * basis[1] +
    inPv2 * basis[2] +
    inPv3 * basis[3];
}

--- --------------------------------------------------------------------------
-- glsl Mesh.TessEval.VaryingInterpolation

float InterpolatePrimvar(float inPv0, float inPv1, float inPv2, float inPv3, 
                         vec4 basis, vec2 uv)
{   
    return basis[0] * inPv0 + 
           basis[1] * inPv1 + 
           basis[2] * inPv2 + 
           basis[3] * inPv3;
}

vec2 InterpolatePrimvar(vec2 inPv0, vec2 inPv1, vec2 inPv2, vec2 inPv3, 
                        vec4 basis, vec2 uv)
{   
    return basis[0] * inPv0 + 
           basis[1] * inPv1 + 
           basis[2] * inPv2 + 
           basis[3] * inPv3;
}

vec3 InterpolatePrimvar(vec3 inPv0, vec3 inPv1, vec3 inPv2, vec3 inPv3, 
                        vec4 basis, vec2 uv)
{   
    return basis[0] * inPv0 + 
           basis[1] * inPv1 + 
           basis[2] * inPv2 + 
           basis[3] * inPv3;
}

vec4 InterpolatePrimvar(vec4 inPv0, vec4 inPv1, vec4 inPv2, vec4 inPv3, 
                        vec4 basis, vec2 uv)
{   
    return basis[0] * inPv0 + 
           basis[1] * inPv1 + 
           basis[2] * inPv2 + 
           basis[3] * inPv3;
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Geometry.Triangle

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in VertexData
{
    vec4 Peye;
    vec3 Neye;
} inData[3];

out VertexData
{
    vec4 Peye;
    vec3 Neye;
} outData;

out vec4 gsPatchCoord;

vec4 GetPatchCoord(int index)
{
    vec2 uv[3];
    uv[0] = vec2(0, 0); // (0, 0, 1);
    uv[1] = vec2(1, 0); // (1, 0, 0);
    uv[2] = vec2(0, 1); // (0, 1, 0);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoordTriangle(uv[index], patchParam);
}

void emit(int index, vec4 Peye, vec3 Neye)
{
    outData.Peye = Peye;
    outData.Neye = Neye;

    gsPatchCoord = GetPatchCoord(index);

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(index);

    EmitVertex();
}

FORWARD_DECL(vec4 ComputeSelectionOffset()); // selection.glslfx

void main(void)
{
    gl_PrimitiveID = gl_PrimitiveIDIn;

    bool isFlipped = IsFlipped(); // consider handedness AND negative-scale

    vec3 Neye0 = GetNormal(inData[0].Neye, 0);
    Neye0 = GetTriGeometryNormal(Neye0, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);
    vec3 Neye1 = GetNormal(inData[1].Neye, 1);
    Neye1 = GetTriGeometryNormal(Neye1, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);
    vec3 Neye2 = GetNormal(inData[2].Neye, 2);
    Neye2 = GetTriGeometryNormal(Neye2, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);

    vec4 Peye0 = DisplacementTerminal(
        0, inData[0].Peye, Neye0, GetPatchCoord(0));
    vec4 Peye1 = DisplacementTerminal(
        1, inData[1].Peye, Neye1, GetPatchCoord(1));
    vec4 Peye2 = DisplacementTerminal(
        2, inData[2].Peye, Neye2, GetPatchCoord(2));

    // For wireframe, add a polygon offset to selected faces to ensure they
    // rasterize over unselected faces.
    vec4 selOffset = ComputeSelectionOffset();
    Peye0 += selOffset;
    Peye1 += selOffset;
    Peye2 += selOffset;

    // triangle 0: vertices (0,1,2)
    emit(0, Peye0, Neye0);
    emit(1, Peye1, Neye1);
    emit(2, Peye2, Neye2);

    EndPrimitive();
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Geometry.TriQuad

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in VertexData
{
    vec4 Peye;
    vec3 Neye;
} inData[3];

out VertexData
{
    vec4 Peye;
    vec3 Neye;
} outData;

vec4 GetPatchCoord(int index)
{
    vec2 uv[4];
    uv[0] = vec2(0, 0);
    uv[1] = vec2(1, 0);
    uv[2] = vec2(1, 1);
    uv[3] = vec2(0, 1);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoord(uv[index], patchParam);
}

void emit(int index, vec4 Peye, vec3 Neye)
{
    outData.Peye = Peye;
    outData.Neye = Neye;

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(index);

    EmitVertex();
}

FORWARD_DECL(vec4 ComputeSelectionOffset()); // selection.glslfx

void main(void)
{
    gl_PrimitiveID = gl_PrimitiveIDIn;

    bool isFlipped = IsFlipped(); // consider handedness AND negative-scale

    vec3 Neye0 = GetNormal(inData[0].Neye, 0);
    Neye0 = GetTriGeometryNormal(Neye0, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);
    vec3 Neye1 = GetNormal(inData[1].Neye, 1);
    Neye1 = GetTriGeometryNormal(Neye1, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);
    vec3 Neye2 = GetNormal(inData[2].Neye, 2);
    Neye2 = GetTriGeometryNormal(Neye2, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, isFlipped);

    vec4 Peye0 = DisplacementTerminal(
        0, inData[0].Peye, Neye0, GetPatchCoord(0));
    vec4 Peye1 = DisplacementTerminal(
        1, inData[1].Peye, Neye1, GetPatchCoord(1));
    vec4 Peye2 = DisplacementTerminal(
        2, inData[2].Peye, Neye2, GetPatchCoord(2));

    // For wireframe, add a polygon offset to selected faces to ensure they
    // rasterize over unselected faces.
    vec4 selOffset = ComputeSelectionOffset();
    Peye0 += selOffset;
    Peye1 += selOffset;
    Peye2 += selOffset;

    // triangle 0: vertices (0,1,2)
    emit(0, Peye0, Neye0);
    emit(1, Peye1, Neye1);
    emit(2, Peye2, Neye2);
    EndPrimitive();
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Geometry.Quad

layout(lines_adjacency) in;
layout(triangle_strip, max_vertices = 6) out;

in VertexData
{
    vec4 Peye;
    vec3 Neye;
} inData[4];

out VertexData
{
    vec4 Peye;
    vec3 Neye;
} outData;

out vec4 gsPatchCoord;

vec4 GetPatchCoord(int index)
{
    vec2 uv[4];
    uv[0] = vec2(0, 0);
    uv[1] = vec2(1, 0);
    uv[2] = vec2(1, 1);
    uv[3] = vec2(0, 1);

    ivec3 patchParam = GetPatchParam();
    return OsdInterpolatePatchCoord(uv[index], patchParam);
}

void emit(int index, vec4 Peye, vec3 Neye)
{
    outData.Peye = Peye;
    outData.Neye = Neye;

    gsPatchCoord = GetPatchCoord(index);

    gl_Position = vec4(GetProjectionMatrix() * outData.Peye);
    ApplyClipPlanes(outData.Peye);

    ProcessPrimvarsOut(index);

    EmitVertex();
}

FORWARD_DECL(vec4 ComputeSelectionOffset()); // selection.glslfx

void main(void)
{
    gl_PrimitiveID = gl_PrimitiveIDIn;

    bool isFlipped = IsFlipped(); // consider handedness AND negative-scale

    vec3 Neye0 = GetNormal(inData[0].Neye, 0);
    Neye0 = GetQuadGeometryNormal(Neye0, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, inData[3].Peye, isFlipped);
    vec3 Neye1 = GetNormal(inData[1].Neye, 1);
    Neye1 = GetQuadGeometryNormal(Neye1, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, inData[3].Peye, isFlipped);
    vec3 Neye2 = GetNormal(inData[2].Neye, 2);
    Neye2 = GetQuadGeometryNormal(Neye2, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, inData[3].Peye, isFlipped);
    vec3 Neye3 = GetNormal(inData[3].Neye, 3);
    Neye3 = GetQuadGeometryNormal(Neye3, inData[0].Peye, inData[1].Peye,
        inData[2].Peye, inData[3].Peye, isFlipped);

    vec4 Peye0 = DisplacementTerminal(
        0, inData[0].Peye, Neye0, GetPatchCoord(0));
    vec4 Peye1 = DisplacementTerminal(
        1, inData[1].Peye, Neye1, GetPatchCoord(1));
    vec4 Peye2 = DisplacementTerminal(
        2, inData[2].Peye, Neye2, GetPatchCoord(2));
    vec4 Peye3 = DisplacementTerminal(
        3, inData[3].Peye, Neye3, GetPatchCoord(3));

    // Generate triangles (3,0,2) and (1,2,0)
    //  3---2
    //  |  .|
    //  | . |
    //  |.  |
    //  0---1
    // The indices post-quadrangulation/subdivision follow the convention:
    // 0   -> original (hull) vertex
    // 1,3 -> edge vertices
    // 2   -> center vertex
    //
    // By having index 2 in both the triangles, we ensure the pre-quadrangulated
    // face's normal (at the center) is part of the rasterizer interpolation,
    // which matters when we use smooth/limit normals.
    // In the case of flat normals, we use the vertex positions, so it doesn't
    // matter.

    // For wireframe, add a polygon offset to selected faces to ensure they
    // rasterize over unselected faces.
    vec4 selOffset = ComputeSelectionOffset();
    Peye0 += selOffset;
    Peye1 += selOffset;
    Peye2 += selOffset;
    Peye3 += selOffset;

    // triangle 0: vertices (3,0,2)
    emit(3, Peye3, Neye3);
    emit(0, Peye0, Neye0);
    emit(2, Peye2, Neye2);
    EndPrimitive();

    // triangle 1: vertices (1,2,0)
    emit(1, Peye1, Neye1);
    emit(2, Peye2, Neye2);
    emit(0, Peye0, Neye0);
    EndPrimitive();
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.ControlPointBarycentric

vec3 GetPatchControlPoint()
{
    return GetBarycentricCoord();
}

--- --------------------------------------------------------------------------
-- layout Mesh.Fragment.PatchCoord.ControlPointTessCoord.Triangle

[
    ["in", "vec3", "ptvsBarycentricCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.ControlPointTessCoord.Triangle

vec3 GetPatchControlPoint()
{
    return ptvsBarycentricCoord;
}

--- --------------------------------------------------------------------------
-- layout Mesh.Fragment.PatchCoord.ControlPointTessCoord.Quad

[
    ["in", "vec2", "ptvsBarycentricCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.ControlPointTessCoord.Quad

vec3 GetPatchControlPoint()
{
    return vec3(0.0, ptvsBarycentricCoord.y, ptvsBarycentricCoord.x);
}


--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessellationVertex.PatchCoord.Triangle

vec2 GetPatchCoordLocalST()
{
    vec3 barycentric = gl_TessCoord;
    return barycentric.yz;
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoordTriangle(
        GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessellationVertex.PatchCoord.Quad


vec2 GetPatchCoordLocalST()
{
    return gl_TessCoord;
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoordTriangle(
        GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- glsl Mesh.PostTessellationVertex.PatchCoord.TriQuad

vec2 GetPatchCoordLocalST()
{
    return gl_TessCoord;
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoord(GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord

in vec4 gsPatchCoord;

vec4 GetInterpolatedPatchCoord()
{
    return gsPatchCoord;
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.Triangle

vec2 GetPatchCoordLocalST()
{
    vec3 barycentric = GetPatchControlPoint();
    return barycentric.yz;
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoordTriangle(
                        GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.Quad

vec2 GetPatchCoordLocalST()
{
    vec3 barycentric = GetPatchControlPoint();
    return barycentric.yz;
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoord(GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- layout Mesh.Fragment.PatchCoord.TriQuadPTVS

[
    ["in", "vec2", "ptvsBarycentricCoord"]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.TriQuadPTVS

vec2 GetPatchCoordLocalST()
{
    return ptvsBarycentricCoord;
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoord(GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment.PatchCoord.TriQuad

vec2 GetPatchCoordLocalST()
{
    vec3 barycentric = GetPatchControlPoint();
    if (GetTriQuadID() == 0) {
        vec2 uv[3] = { vec2(0,0), vec2(1,0), vec2(1,1) };
        return uv[0]*barycentric.x + uv[1]*barycentric.y + uv[2]*barycentric.z;
    } else {
        vec2 uv[3] = { vec2(1,1), vec2(0,1), vec2(0,0) };
        return uv[0]*barycentric.x + uv[1]*barycentric.y + uv[2]*barycentric.z;
    }
}

vec4 GetInterpolatedPatchCoord()
{
    return OsdInterpolatePatchCoord(GetPatchCoordLocalST(), GetPatchParam());
}

--- --------------------------------------------------------------------------
-- layout Mesh.Fragment

[
    ["in block", "VertexData", "inData",
        ["vec4", "Peye"],
        ["vec3", "Neye"]
    ]
]

--- --------------------------------------------------------------------------
-- glsl Mesh.Fragment

#ifndef HD_HAS_ptexFaceOffset
#define HD_HAS_ptexFaceOffset
int HdGet_ptexFaceOffset()
{
    return 0;
}
#endif

vec4 GetPatchCoord(int localIndex)
{
    vec4 patchCoord = GetInterpolatedPatchCoord();
    return vec4(patchCoord.xyz, patchCoord.w + HdGet_ptexFaceOffset());
}

vec4 GetPatchCoord()
{
    return GetPatchCoord(0);
}

vec3 ComputeScreenSpacePeye()
{
    return inData.Peye.xyz / inData.Peye.w;
}

vec3 ComputeScreenSpaceNeye()
{
    vec3 Peye = ComputeScreenSpacePeye();
    vec3 Neye = normalize(cross(dFdx(Peye), dFdy(Peye)));
    return (gl_FrontFacing ? Neye : -Neye);
}

void main(void)
{
    bool isFlipped = IsFlipped();

    DiscardBasedOnShading(gl_FrontFacing, isFlipped);

    DiscardBasedOnTopologicalVisibility();

    vec4 color = vec4(0.5, 0.5, 0.5, 1);
#ifdef HD_HAS_displayColor
    color.rgb = HdGet_displayColor().rgb;
#endif
#ifdef HD_HAS_displayOpacity
    color.a = HdGet_displayOpacity();
#endif

    vec3 Peye = ComputeScreenSpacePeye();

    vec3 Neye = inData.Neye;
    // Normalize Neye after rasterizer interpolation.
    if (length(Neye) > 0.0) {
        Neye = normalize(Neye);
    }
    // Give the shader key a chance to override the normal.
    Neye = GetNormal(Neye, 0);
    // Orient the normal for shading.
    Neye = GetShadingNormal(Neye, isFlipped);

    vec4 patchCoord = GetPatchCoord();
    color = ShadingTerminal(vec4(Peye, 1), Neye, color, patchCoord);

    color = ApplyEdgeColor(color, patchCoord);

#ifdef HD_MATERIAL_TAG_MASKED   
    if (ShouldDiscardByAlpha(color)) {
        discard;
    }
#endif

    RenderOutput(vec4(Peye, 1), Neye, color, patchCoord);
}
