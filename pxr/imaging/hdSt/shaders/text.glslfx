-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

--- This is what an import might look like.
--- #import $TOOLS/hdSt/shaders/text.glslfx

#import $TOOLS/hdSt/shaders/instancing.glslfx
#import $TOOLS/hdSt/shaders/renderPass.glslfx
#import $TOOLS/hdSt/shaders/terminals.glslfx
#import $TOOLS/hdSt/shaders/pointId.glslfx

--- --------------------------------------------------------------------------
-- layout VSShaderText

[
    ["out block", "VSOutputShaderData", "outData",
        ["vec4", "Peye"],
        ["vec4", "TextCoord"],
        ["vec3", "TextColor", "", "flat"],
        ["float", "TextOpacity", "", "flat"]
    ]
]

--- --------------------------------------------------------------------------
-- glsl VSShaderText

// Vertex shader
void main(void)
{
    // The position in object space.
    vec4 position = vec4(HdGet_points(), 1.0);

    // Transform the position from object space to clip space for output.
    const MAT4 worldToViewMatrix = GetWorldToViewMatrix();
    const MAT4 projectionMatrix = GetProjectionMatrix();
    MAT4 transform = ApplyInstanceTransform(HdGet_transform());

    outData.Peye = vec4(worldToViewMatrix * transform * position);

    // Pass the texture coordinates and TriType.
    outData.TextCoord = HdGet_textCoord();

    // Pass the text color and opacity.
#ifdef HD_HAS_textColor
    outData.TextColor = HdGet_textColor();
#elif defined(HD_HAS_displayColor)
    outData.TextColor = HdGet_displayColor().rgb;
#else
    outData.TextColor = vec3(0.0, 0.0, 0.0);
#endif
#ifdef HD_HAS_textOpacity
    outData.TextOpacity = HdGet_textOpacity();
#elif defined(HD_HAS_displayOpacity)
    outData.TextOpacity = HdGet_displayOpacity();
#else
    outData.TextOpacity = 1.0;
#endif

    gl_Position = vec4(projectionMatrix * outData.Peye);
    ApplyClipPlanes(outData.Peye);
}

--- --------------------------------------------------------------------------
-- layout PSShaderText

[
    ["in block", "VSOutputShaderData", "inData",
        ["vec4", "Peye"],
        ["vec4", "TextCoord"],
        ["vec3", "TextColor", "", "flat"],
        ["float", "TextOpacity", "", "flat"]
    ]
]

--- --------------------------------------------------------------------------
-- glsl PSShaderText

// Pixel shader

int GetPrimitiveEdgeId() {
    return -1;
}

bool IsFragmentOnEdge() {
    return false;
}

float GetSelectedEdgeOpacity() {
    return 0.0;
}

// Pixel shader
void main(void)
{
    float alpha = inData.TextOpacity;

    alpha = alpha * getOpacity(inData.TextCoord);

    // The curve primitive have alpha natively. So here we first get the override color, then
    // multiply the alpha of the primitive with the override alpha, and finally set the alpha
    // to the final color.
    vec4 overrideColor = ApplyColorOverrides(vec4(inData.TextColor, 1.0));
    alpha = alpha * overrideColor.a;
    vec4 finalColor = vec4(overrideColor.rgb, alpha);

    vec3 Peye = inData.Peye.xyz / inData.Peye.w;
    RenderOutput(vec4(Peye, 1), vec3(0, 0, 1), finalColor, vec4(1));

}
